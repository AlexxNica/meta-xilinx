From 4f0ccec7959038636f19e6e3d01bc65908c3838e Mon Sep 17 00:00:00 2001
From: Sipke Vriend <sipke.vriend@xilinx.com>
Date: Wed, 15 May 2013 15:15:36 +1000
Subject: [PATCH 02/24] Microblaze changes to arch

Signed-off-by: Sipke Vriend <sipke.vriend@xilinx.com>
---
 arch/microblaze/Kconfig               |    5 +
 arch/microblaze/Makefile              |    9 +-
 arch/microblaze/boot/.gitignore       |    3 +
 arch/microblaze/include/asm/irq.h     |   16 +-
 arch/microblaze/include/asm/uaccess.h |   30 +-
 arch/microblaze/kernel/.gitignore     |    1 +
 arch/microblaze/kernel/cpu/cpuinfo.c  |    5 +
 arch/microblaze/kernel/intc.c         |    2 +
 arch/microblaze/kernel/reset.c        |    6 +-
 arch/microblaze/lib/uaccess_old.S     |    9 +-
 arch/microblaze/pci/Makefile          |    2 +
 arch/microblaze/pci/msi.c             |  148 ++++++
 arch/microblaze/pci/pci-common.c      |   15 +-
 arch/microblaze/pci/xilinx_axipcie.c  |  840 +++++++++++++++++++++++++++++++++
 arch/microblaze/pci/xilinx_axipcie.h  |  156 ++++++
 15 files changed, 1219 insertions(+), 28 deletions(-)
 create mode 100644 arch/microblaze/boot/.gitignore
 create mode 100644 arch/microblaze/kernel/.gitignore
 create mode 100644 arch/microblaze/pci/msi.c
 create mode 100644 arch/microblaze/pci/xilinx_axipcie.c
 create mode 100644 arch/microblaze/pci/xilinx_axipcie.h

diff --git a/arch/microblaze/Kconfig b/arch/microblaze/Kconfig
index ba3b7c8..aa8976e 100644
--- a/arch/microblaze/Kconfig
+++ b/arch/microblaze/Kconfig
@@ -283,6 +283,11 @@ config PCI_XILINX
 	bool "Xilinx PCI host bridge support"
 	depends on PCI
 
+config XILINX_AXIPCIE
+	bool "Xilinx AXI PCIe host bridge support"
+	depends on PCI
+	select ARCH_SUPPORTS_MSI
+
 source "drivers/pci/Kconfig"
 
 endmenu
diff --git a/arch/microblaze/Makefile b/arch/microblaze/Makefile
index d26fb90..0a603d3 100644
--- a/arch/microblaze/Makefile
+++ b/arch/microblaze/Makefile
@@ -69,16 +69,13 @@ export MMU DTB
 
 all: linux.bin
 
-# With make 3.82 we cannot mix normal and wildcard targets
-BOOT_TARGETS1 = linux.bin linux.bin.gz
-BOOT_TARGETS2 = simpleImage.%
-
 archclean:
 	$(Q)$(MAKE) $(clean)=$(boot)
 
-$(BOOT_TARGETS1): vmlinux
+linux.bin linux.bin.gz: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
-$(BOOT_TARGETS2): vmlinux
+
+simpleImage.%: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
 
 define archhelp
diff --git a/arch/microblaze/boot/.gitignore b/arch/microblaze/boot/.gitignore
new file mode 100644
index 0000000..bf04591
--- /dev/null
+++ b/arch/microblaze/boot/.gitignore
@@ -0,0 +1,3 @@
+*.dtb
+linux.bin*
+simpleImage.*
diff --git a/arch/microblaze/include/asm/irq.h b/arch/microblaze/include/asm/irq.h
index bab3b13..85e9182 100644
--- a/arch/microblaze/include/asm/irq.h
+++ b/arch/microblaze/include/asm/irq.h
@@ -9,7 +9,21 @@
 #ifndef _ASM_MICROBLAZE_IRQ_H
 #define _ASM_MICROBLAZE_IRQ_H
 
-#define NR_IRQS		(32 + 1)
+/*
+ * Linux IRQ# is currently offset by one to map to the hardware
+ * irq number. So hardware IRQ0 maps to Linux irq 1.
+ */
+#define NO_IRQ_OFFSET	1
+#define IRQ_OFFSET	NO_IRQ_OFFSET
+/* AXI PCIe MSI support */
+#if defined(CONFIG_XILINX_AXIPCIE) && defined(CONFIG_PCI_MSI)
+#define IRQ_XILINX_MSI_0	128
+#define XILINX_NUM_MSI_IRQS	32
+#define NR_IRQS		(32 + IRQ_XILINX_MSI_0 + IRQ_OFFSET)
+#else
+#define NR_IRQS		(32 + IRQ_OFFSET)
+#endif
+
 #include <asm-generic/irq.h>
 
 struct pt_regs;
diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index a1ab5f0..efe59d8 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -90,17 +90,25 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 
 #else
 
-/*
- * Address is valid if:
- *  - "addr", "addr + size" and "size" are all below the limit
- */
-#define access_ok(type, addr, size) \
-	(get_fs().seg >= (((unsigned long)(addr)) | \
-		(size) | ((unsigned long)(addr) + (size))))
-
-/* || printk("access_ok failed for %s at 0x%08lx (size %d), seg 0x%08x\n",
- type?"WRITE":"READ",addr,size,get_fs().seg)) */
-
+static inline int access_ok(int type, const void __user *addr,
+							unsigned long size)
+{
+	if (!size)
+		goto ok;
+
+	if ((get_fs().seg < ((unsigned long)addr)) ||
+			(get_fs().seg < ((unsigned long)addr + size - 1))) {
+		pr_debug("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
+			type ? "WRITE" : "READ ", (u32)addr, (u32)size,
+			(u32)get_fs().seg);
+		return 0;
+	}
+ok:
+	pr_debug("ACCESS OK: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
+			type ? "WRITE" : "READ ", (u32)addr, (u32)size,
+			(u32)get_fs().seg);
+	return 1;
+}
 #endif
 
 #ifdef CONFIG_MMU
diff --git a/arch/microblaze/kernel/.gitignore b/arch/microblaze/kernel/.gitignore
new file mode 100644
index 0000000..c5f676c
--- /dev/null
+++ b/arch/microblaze/kernel/.gitignore
@@ -0,0 +1 @@
+vmlinux.lds
diff --git a/arch/microblaze/kernel/cpu/cpuinfo.c b/arch/microblaze/kernel/cpu/cpuinfo.c
index eab6abf..3ffd337 100644
--- a/arch/microblaze/kernel/cpu/cpuinfo.c
+++ b/arch/microblaze/kernel/cpu/cpuinfo.c
@@ -37,6 +37,8 @@ const struct cpu_ver_key cpu_ver_lookup[] = {
 	{"8.20.a", 0x15},
 	{"8.20.b", 0x16},
 	{"8.30.a", 0x17},
+	{"8.40.a", 0x18},
+	{"8.40.b", 0x19},
 	{NULL, 0},
 };
 
@@ -57,6 +59,9 @@ const struct family_string_key family_string_lookup[] = {
 	{"virtex6", 0xe},
 	/* FIXME There is no key code defined for spartan2 */
 	{"spartan2", 0xf0},
+	{"kintex7", 0x10},
+	{"artix7", 0x11},
+	{"zynq7000", 0x12},
 	{NULL, 0},
 };
 
diff --git a/arch/microblaze/kernel/intc.c b/arch/microblaze/kernel/intc.c
index 7a1a8d4..9422699 100644
--- a/arch/microblaze/kernel/intc.c
+++ b/arch/microblaze/kernel/intc.c
@@ -172,4 +172,6 @@ void __init init_IRQ(void)
 	 * and commits this patch.  ~~gcl */
 	root_domain = irq_domain_add_linear(intc, nr_irq, &xintc_irq_domain_ops,
 							(void *)intr_mask);
+
+	irq_set_default_host(root_domain);
 }
diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index 2e5079a..059ccfe 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -67,7 +67,11 @@ static void gpio_system_reset(void)
 		pr_notice("Reset GPIO unavailable - halting!\n");
 }
 #else
-#define gpio_system_reset() do {} while (0)
+static void gpio_system_reset(void)
+{
+	printk(KERN_NOTICE "No reset GPIO present - halting!\n");
+}
+
 void of_platform_reset_gpio_probe(void)
 {
 	return;
diff --git a/arch/microblaze/lib/uaccess_old.S b/arch/microblaze/lib/uaccess_old.S
index f085995..0e8cc27 100644
--- a/arch/microblaze/lib/uaccess_old.S
+++ b/arch/microblaze/lib/uaccess_old.S
@@ -38,15 +38,14 @@ __strncpy_user:
 	addik	r3,r7,0		/* temp_count = len */
 1:
 	lbu	r4,r6,r0
+	beqid	r4,2f
 	sb	r4,r5,r0
 
-	addik	r3,r3,-1
-	beqi	r3,2f		/* break on len */
-
 	addik	r5,r5,1
-	bneid	r4,1b
 	addik	r6,r6,1		/* delay slot */
-	addik	r3,r3,1		/* undo "temp_count--" */
+
+	addik	r3,r3,-1
+	bnei	r3,1b		/* break on len */
 2:
 	rsubk	r3,r3,r7	/* temp_count = len - temp_count */
 3:
diff --git a/arch/microblaze/pci/Makefile b/arch/microblaze/pci/Makefile
index d1114fb..20c1c1f 100644
--- a/arch/microblaze/pci/Makefile
+++ b/arch/microblaze/pci/Makefile
@@ -4,3 +4,5 @@
 
 obj-$(CONFIG_PCI)		+= pci-common.o indirect_pci.o iomap.o
 obj-$(CONFIG_PCI_XILINX)	+= xilinx_pci.o
+obj-$(CONFIG_XILINX_AXIPCIE)	+= xilinx_axipcie.o
+obj-$(CONFIG_PCI_MSI)		+= msi.o
diff --git a/arch/microblaze/pci/msi.c b/arch/microblaze/pci/msi.c
new file mode 100644
index 0000000..1e0e1ed
--- /dev/null
+++ b/arch/microblaze/pci/msi.c
@@ -0,0 +1,148 @@
+/*
+ * Xilinx PCIe IP hardware MSI initialisation
+ *
+ * Copyright (c) 2010-2011 Xilinx, Inc.
+ *
+ * This program has adopted some work from PCI/PCIE support for AMCC
+ * PowerPC boards written by Benjamin Herrenschmidt.
+ * Copyright 2007 Ben. Herrenschmidt <benh@kernel.crashing.org>, IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/pci.h>
+#include <linux/msi.h>
+#include <asm/irq.h>
+#include "xilinx_axipcie.h"
+
+static DECLARE_BITMAP(msi_irq_in_use, XILINX_NUM_MSI_IRQS);
+
+/*
+ * Dynamic irq allocate and deallocation
+ */
+
+/**
+* create_irq- Dynamic irq allocate
+* void
+*
+* @return: Interrupt number allocated/ error
+*
+* @note: None
+*/
+int create_irq(void)
+{
+	int irq, pos;
+again:
+	pos = find_first_zero_bit(msi_irq_in_use, XILINX_NUM_MSI_IRQS);
+
+	irq = IRQ_XILINX_MSI_0 + pos;
+	if (irq > NR_IRQS)
+		return -ENOSPC;
+
+	/* test_and_set_bit operates on 32-bits at a time */
+	if (test_and_set_bit(pos, msi_irq_in_use))
+		goto again;
+
+	dynamic_irq_init(irq);
+
+	return irq;
+}
+
+/**
+* destroy_irq- Dynamic irq de-allocate
+* @irq: Interrupt number to de-allocate
+*
+* @return: None
+*
+* @note: None
+*/
+void destroy_irq(unsigned int irq)
+{
+	int pos = irq - IRQ_XILINX_MSI_0;
+
+	dynamic_irq_cleanup(irq);
+
+	clear_bit(pos, msi_irq_in_use);
+}
+
+/**
+* arch_teardown_msi_irq-Teardown the Interrupt
+* @irq: Interrupt number to teardown
+*
+* @return: None
+*
+* @note: This function  is called when pci_disable_msi is called
+*/
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+/**
+* xilinx_msi_nop-No operation handler
+* @irq: Interrupt number
+*
+* @return: None
+*
+* @note: None
+*/
+static void xilinx_msi_nop(struct irq_data *d)
+{
+	return;
+}
+
+static struct irq_chip xilinx_msi_chip = {
+		.name = "PCI-MSI",
+		.irq_ack = xilinx_msi_nop,
+		.irq_enable = unmask_msi_irq,
+		.irq_disable = mask_msi_irq,
+		.irq_mask = mask_msi_irq,
+		.irq_unmask = unmask_msi_irq,
+};
+
+/**
+* arch_setup_msi_irq-Setup MSI interrupt
+* @pdev: Pointer to current pci device structure
+* @desc: Pointer to MSI description structure
+*
+* @return: Error/ no-error
+*
+* @note: This function  is called when pci_enable_msi is called
+*/
+
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int irq = create_irq();
+	struct msi_msg msg;
+
+	if (irq < 0)
+		return irq;
+
+	irq_set_msi_desc(irq, desc);
+
+	msg.address_hi = 0x00000000;
+	msg.address_lo = msg_addr;
+	msg.data = irq;
+
+	DBG("irq %d addr_hi %08x low %08x data %08x\n",
+			irq, msg.address_hi, msg.address_lo, msg.data);
+
+	write_msi_msg(irq, &msg);
+
+	irq_set_chip_and_handler(irq, &xilinx_msi_chip, handle_simple_irq);
+
+	return 0;
+}
diff --git a/arch/microblaze/pci/pci-common.c b/arch/microblaze/pci/pci-common.c
index 9641655..b087a56 100644
--- a/arch/microblaze/pci/pci-common.c
+++ b/arch/microblaze/pci/pci-common.c
@@ -187,10 +187,12 @@ int pcibios_add_platform_entries(struct pci_dev *pdev)
 	return device_create_file(&pdev->dev, &dev_attr_devspec);
 }
 
+#ifndef CONFIG_XILINX_AXIPCIE
 void pcibios_set_master(struct pci_dev *dev)
 {
 	/* No special bus mastering setup handling */
 }
+#endif
 
 /*
  * Reads the interrupt pin to determine if interrupt is use by card.
@@ -660,6 +662,7 @@ void pci_process_bridge_OF_ranges(struct pci_controller *hose,
 {
 	const u32 *ranges;
 	int rlen;
+	/* The address cells of PCIe parent node */
 	int pna = of_n_addr_cells(dev);
 	int np = pna + 5;
 	int memno = 0, isa_hole = -1;
@@ -680,7 +683,7 @@ void pci_process_bridge_OF_ranges(struct pci_controller *hose,
 	pr_debug("Parsing ranges property...\n");
 	while ((rlen -= np * 4) >= 0) {
 		/* Read next ranges element */
-		pci_space = ranges[0];
+		pci_space = be32_to_cpup(ranges);
 		pci_addr = of_read_number(ranges + 1, 2);
 		cpu_addr = of_translate_address(dev, ranges + 3);
 		size = of_read_number(ranges + pna + 3, 2);
@@ -702,7 +705,7 @@ void pci_process_bridge_OF_ranges(struct pci_controller *hose,
 		/* Now consume following elements while they are contiguous */
 		for (; rlen >= np * sizeof(u32);
 		     ranges += np, rlen -= np * 4) {
-			if (ranges[0] != pci_space)
+			if (be32_to_cpup(ranges) != pci_space)
 				break;
 			pci_next = of_read_number(ranges + 1, 2);
 			cpu_next = of_translate_address(dev, ranges + 3);
@@ -983,7 +986,12 @@ void pcibios_setup_bus_devices(struct pci_bus *bus)
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		/* Setup OF node pointer in archdata */
+#ifdef CONFIG_XILINX_AXIPCIE
+		/* Get the root complex node */
+		dev->dev.of_node = pcibios_get_phb_of_node(dev->bus);
+#else
 		dev->dev.of_node = pci_device_to_OF_node(dev);
+#endif
 
 		/* Fixup NUMA node as it may not be setup yet by the generic
 		 * code and is needed by the DMA init
@@ -1055,7 +1063,7 @@ EXPORT_SYMBOL(pcibios_align_resource);
  * Reparent resource children of pr that conflict with res
  * under res, and make res replace those children.
  */
-static int __init reparent_resources(struct resource *parent,
+static int reparent_resources(struct resource *parent,
 				     struct resource *res)
 {
 	struct resource *p, **pp;
@@ -1376,7 +1384,6 @@ void pcibios_claim_one_bus(struct pci_bus *bus)
 	list_for_each_entry(child_bus, &bus->children, node)
 		pcibios_claim_one_bus(child_bus);
 }
-EXPORT_SYMBOL_GPL(pcibios_claim_one_bus);
 
 
 /* pcibios_finish_adding_to_bus
diff --git a/arch/microblaze/pci/xilinx_axipcie.c b/arch/microblaze/pci/xilinx_axipcie.c
new file mode 100644
index 0000000..86c7516
--- /dev/null
+++ b/arch/microblaze/pci/xilinx_axipcie.c
@@ -0,0 +1,840 @@
+/*
+ * Xilinx AXI PCIe IP hardware initialation, setup and
+ * configuration spaces access file.
+ *
+ * Copyright (c) 2010-2011 Xilinx, Inc.
+ *
+ * This program has adopted some work from PCI/PCIE support for AMCC
+ * PowerPC boards written by Benjamin Herrenschmidt.
+ * Copyright 2007 Ben. Herrenschmidt <benh@kernel.crashing.org>, IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/bootmem.h>
+#include <linux/delay.h>
+#include <linux/compiler.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <asm/pci-bridge.h>
+#include <linux/interrupt.h>
+#include "xilinx_axipcie.h"
+
+static struct xilinx_axipcie_port *xilinx_axipcie_ports;
+static unsigned int xilinx_axipcie_port_count;
+
+static const struct of_device_id xilinx_axipcie_match[] = {
+	{ .compatible = "xlnx,axi-pcie-1.05.a" ,},
+	{}
+};
+
+static int last_bus_on_record;
+
+#ifdef CONFIG_PCI_MSI
+unsigned long msg_addr;
+#endif
+
+/* Macros */
+#define is_link_up(base_address)	\
+	((in_le32(((u8 *)base_address) + AXIPCIE_REG_PSCR) &	\
+	AXIPCIE_REG_PSCR_LNKUP) ? 1 : 0)
+
+#define bridge_enable(base_address)	\
+	out_le32((((u8 *)base_address) + AXIPCIE_REG_RPSC),	\
+		(in_le32(((u8 *)base_address) + AXIPCIE_REG_RPSC) |	\
+		AXIPCIE_REG_RPSC_BEN))
+
+/**
+ * xilinx_get_axipcie_ip_config_info - Read info from device tree
+ * @dev: A pointer to device node to read from
+ * @ip_config_info: A pointer to xilinx_pcie_node struct to write device tree
+ *			info into to.
+ *
+ * @return: Error / no error
+ *
+ * @note: Read related info from device tree
+ */
+int xilinx_get_axipcie_ip_config_info(struct device_node *dev,
+		struct xilinx_axipcie_node *ip_config_info)
+{
+	u32 *ip_setup_parameter;
+	u32 rlen;
+
+	ip_config_info->number_of_instances = 1;
+
+	ip_setup_parameter = (u32 *) of_get_property(dev,
+						"xlnx,device-num", &rlen);
+	ip_config_info->device_id = 0;
+
+	ip_setup_parameter = (u32 *) of_get_property(dev,
+						"xlnx,include-rc", &rlen);
+
+	if (ip_setup_parameter)
+		ip_config_info->device_type = be32_to_cpup(ip_setup_parameter);
+	else
+		return -ENODEV;
+
+	ip_setup_parameter = (u32 *) of_get_property(dev,
+						"reg", &rlen);
+
+	if (ip_setup_parameter) {
+		ip_config_info->reg_base =
+					be32_to_cpup(ip_setup_parameter);
+		ip_config_info->reg_len =
+					be32_to_cpup(ip_setup_parameter + 1);
+	} else
+		return -ENODEV;
+
+	ip_setup_parameter = (u32 *) of_get_property(dev,
+						"xlnx,pciebar-num", &rlen);
+
+	if (ip_setup_parameter)
+		ip_config_info->bars_num = be32_to_cpup(ip_setup_parameter);
+	else
+		return -ENODEV;
+
+	ip_config_info->irq_num = irq_of_parse_and_map(dev, 0);
+
+	/* Get address translation parameters */
+	ip_setup_parameter = (u32 *) of_get_property(dev,
+					"xlnx,pciebar2axibar-0", &rlen);
+
+	if (ip_setup_parameter)
+		ip_config_info->pcie2axibar_0 =
+					be32_to_cpup(ip_setup_parameter);
+	else
+		return -ENODEV;
+
+	ip_setup_parameter = (u32 *) of_get_property(dev,
+					"xlnx,pciebar2axibar-1", &rlen);
+
+	if (ip_setup_parameter)
+		ip_config_info->pcie2axibar_1 =
+					be32_to_cpup(ip_setup_parameter);
+	else
+		ip_config_info->pcie2axibar_1 = 0x0;
+
+	return 0;
+}
+
+/**
+ * fixup_xilinx_axipcie_bridge
+ * @dev: A pointer to device pcie device struct
+ *
+ * @return: None
+ *
+ * @note: A fix up routine to be called by kernel during enumeration
+ */
+static void fixup_xilinx_axipcie_bridge(struct pci_dev *dev)
+{
+	struct pci_controller *hose;
+	int i;
+
+	if (dev->devfn != 0 || dev->bus->self != NULL)
+		return;
+
+	hose = pci_bus_to_host(dev->bus);
+	if (hose == NULL)
+		return;
+
+	if (!of_match_node(xilinx_axipcie_match, hose->dn))
+		return;
+
+	/* Hide the PCI host BARs from the kernel as their content doesn't
+	 * fit well in the resource management
+	 */
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		dev->resource[i].start = dev->resource[i].end = 0;
+		dev->resource[i].flags = 0;
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, fixup_xilinx_axipcie_bridge);
+
+/**
+ * xilinx_init_axipcie_port - Initialize hardware
+ * @port: A pointer to a pcie port that needs to be initialized
+ *
+ * @return: Error / no error
+ *
+ * @note: None
+ */
+static int xilinx_init_axipcie_port(struct xilinx_axipcie_port *port)
+{
+	void __iomem *base_addr_remap = NULL;
+
+	/* base_addr_remap = ioremap(port->reg_base, PORT_REG_SIZE); */
+	base_addr_remap = ioremap(port->reg_base, port->reg_len);
+	if (!base_addr_remap)
+		return -ENOMEM;
+
+	port->base_addr_remap = base_addr_remap;
+
+	/* make sure it is root port before touching header */
+	if (port->type) {
+
+		port->header_remap = base_addr_remap;
+		out_le32((((u8 *)port->base_addr_remap) + PCIE_CFG_CMD),
+							BUS_MASTER_ENABLE);
+	}
+
+#ifdef CONFIG_PCI_MSI
+	msg_addr = port->reg_base & ~0xFFF;	/* 4KB aligned */
+	out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_MSIBASE1),
+							0x00000000);
+	out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_MSIBASE2),
+							msg_addr);
+#endif
+
+	port->link = is_link_up(port->base_addr_remap);
+	if (!port->link)
+		pr_info("LINK IS DOWN\n");
+	else
+		pr_info("LINK IS UP\n");
+
+	/* Disable all interrupts*/
+	out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_IMR),
+					~AXIPCIE_REG_IDR_MASKALL);
+	/* Clear pending interrupts*/
+	out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_IDR),
+		in_le32(((u8 *)port->base_addr_remap) + AXIPCIE_REG_IDR) &
+					AXIPCIE_REG_IMR_MASKALL);
+	/* Enable all interrupts*/
+	out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_IMR),
+					AXIPCIE_REG_IMR_MASKALL);
+
+	/* Bridge enable must be done after enumeration,
+		but there is no callback defined */
+	bridge_enable(port->base_addr_remap);
+
+	return 0;
+}
+
+/**
+ * xilinx_axipcie_verify_config
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: device/function
+ *
+ * @return: Error / no error
+ *
+ * @note: Make sure we can handle this configuration call on our
+ *        device.
+ */
+static int xilinx_axipcie_verify_config(struct xilinx_axipcie_port *port,
+				struct pci_bus *bus,
+				unsigned int devfn)
+{
+	static int message;
+
+	/* Endpoint can not generate upstream(remote) config cycles */
+	if ((!port->type) && bus->number != port->hose->first_busno)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* Check we are within the mapped range */
+	if (bus->number > port->hose->last_busno) {
+		if (!message) {
+			printk(KERN_WARNING "Warning! Probing bus %u"
+			       " out of range !\n", bus->number);
+			message++;
+		}
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	/* The other side of the RC has only one device as well */
+	if (bus->number == (port->hose->first_busno + 1) &&
+	    PCI_SLOT(devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* Check if we have a link */
+	if (!port->link)
+		port->link = is_link_up(port->base_addr_remap);
+
+	if ((bus->number != port->hose->first_busno) && !port->link)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return 0;
+}
+
+/**
+ * xilinx_axipcie_get_config_base
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: Device/function
+ *
+ * @return: Base address of the configuration space needed to be
+ *          accessed.
+ *
+ * @note: Get the base address of the configuration space for this
+ *        pcie device.
+ */
+static void __iomem *xilinx_axipcie_get_config_base(
+					struct xilinx_axipcie_port *port,
+					struct pci_bus *bus,
+					unsigned int devfn)
+{
+	int relbus;
+
+	relbus = ((bus->number << BUS_LOC_SHIFT) | (devfn << DEV_LOC_SHIFT));
+
+	if (relbus == 0)
+		return (void __iomem *)port->header_remap;
+
+	return (void __iomem *)port->hose->cfg_data + relbus;
+}
+
+/**
+ * xilinx_axipcie_read_config - Read config reg.
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: Device/function
+ * @offset: Offset from base
+ * @len: Byte/word/dword
+ * @val: A pointer to value read
+ *
+ * @return: Error / no error
+ *
+ *
+ * @note: Read byte/word/dword from pcie device config reg.
+ */
+static int xilinx_axipcie_read_config(struct pci_bus *bus,
+				unsigned int devfn,
+				int offset,
+				int len,
+				u32 *val)
+{
+	struct pci_controller *hose = (struct pci_controller *) bus->sysdata;
+	struct xilinx_axipcie_port *port =
+				&xilinx_axipcie_ports[hose->indirect_type];
+	void __iomem *addr;
+
+	if (xilinx_axipcie_verify_config(port, bus, devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	addr = xilinx_axipcie_get_config_base(port, bus, devfn);
+
+	if ((bus->number == 0) && devfn > 0) {
+		*val = 0xFFFFFFFF;
+		return PCIBIOS_SUCCESSFUL;
+	}
+
+	switch (len) {
+	case 1:
+		*val = in_8((u8 *)(addr + offset));
+		break;
+	case 2:
+		*val = in_le16((u16 *)(addr + offset));
+		break;
+	default:
+		*val = in_le32((u32 *)(addr + offset));
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/**
+ * xilinx_axipcie_write_config - Write config reg.
+ * @port: A pointer to a pcie port that needs to be handled
+ * @bus: Bus structure of current bus
+ * @devfun: Device/function
+ * @offset: Offset from base
+ * @len: Byte/word/dword
+ * @val: Value to be written to device
+ *
+ * @return: Error / no error
+ *
+ *
+ * @note: Write byte/word/dword to pcie device config reg.
+ */
+static int xilinx_axipcie_write_config(struct pci_bus *bus,
+				unsigned int devfn,
+				int offset,
+				int len,
+				u32 val)
+{
+	struct pci_controller *hose = (struct pci_controller *) bus->sysdata;
+	struct xilinx_axipcie_port *port =
+				&xilinx_axipcie_ports[hose->indirect_type];
+	void __iomem  *addr;
+
+	if (xilinx_axipcie_verify_config(port, bus, devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	addr = xilinx_axipcie_get_config_base(port, bus, devfn);
+
+	if ((bus->number == 0) && devfn > 0)
+		return PCIBIOS_SUCCESSFUL;
+
+	switch (len) {
+	case 1:
+		out_8((u8 *)(addr + offset), val);
+		break;
+	case 2:
+		out_le16((u16 *)(addr + offset), val);
+		break;
+	default:
+		out_le32((u32 *)(addr + offset), val);
+		break;
+	}
+
+	wmb();
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops xlnx_pcie_pci_ops = {
+	.read  = xilinx_axipcie_read_config,
+	.write = xilinx_axipcie_write_config,
+};
+
+/**
+ * xilinx_set_bridge_resource - Setup base & limit registers of config space.
+ * @port: Pointer to a root port
+ *
+ * @return: None
+ *
+ * @note: None
+ */
+void xilinx_set_bridge_resource(struct xilinx_axipcie_port *port)
+{
+	const u32 *ranges;
+	int rlen;
+	/* The address cells of PCIe parent node */
+	int pna = of_n_addr_cells(port->node);
+	int np = pna + 5;
+	u32 pci_space;
+	unsigned long long pci_addr, size;
+	struct device_node *dev;
+	u32 val = 0;
+
+	dev = port->node;
+
+	/* Get ranges property */
+	ranges = of_get_property(dev, "ranges", &rlen);
+	if (ranges == NULL) {
+		printk(KERN_DEBUG "%s:Didnot get any ranges property\n",
+								__func__);
+		return;
+	}
+
+	while ((rlen -= np * 4) >= 0) {
+		pci_space = be32_to_cpup(ranges);
+		pci_addr = of_read_number(ranges + 1, 2);
+		size = of_read_number(ranges + pna + 3, 2);
+
+		printk(KERN_INFO "%s:pci_space: 0x%08x pci_addr:0x%016llx size:"
+			"0x%016llx\n", __func__, pci_space, pci_addr, size);
+
+		ranges += np;
+
+		switch ((pci_space >> 24) & 0x3) {
+		case 1:		/* PCI IO space */
+			printk(KERN_INFO "%s:Setting resource in IO Space\n",
+								__func__);
+
+			val = ((pci_addr >> 8) & 0x000000F0) |
+					((pci_addr + size - 1) & 0x0000F000);
+
+			out_le32((((u8 *)port->header_remap) + PCIE_CFG_IO),
+									val);
+
+			val = ((pci_addr >> 16) & 0x0000FFFF) |
+					((pci_addr + size - 1) & 0xFFFF0000);
+
+			out_le32((((u8 *)port->header_remap) +
+						PCIE_CFG_IO_UPPER), val);
+
+			break;
+		case 2:		/* PCI Memory space */
+			printk(KERN_INFO "%s:Setting resource in Memory Space\n",
+								__func__);
+			val = ((pci_addr >> 16) & 0xfff0) |
+					((pci_addr + size - 1) & 0xfff00000);
+
+			/* out_le32((((u8 *)port->header_remap) + PCIE_CFG_MEM),
+								val); */
+
+			break;
+		case 3:		/* PCI 64 bits Memory space */
+			printk(KERN_INFO "%s:Setting resource in Prefetchable"
+					" Memory Space\n", __func__);
+
+			val = ((pci_addr >> 16) & 0xfff0) |
+					((pci_addr + size - 1) & 0xfff00000);
+
+			out_le32((((u8 *)port->header_remap) +
+						PCIE_CFG_PREF_MEM), val);
+
+			val = ((pci_addr >> 32) & 0xffffffff);
+			out_le32((((u8 *)port->header_remap) +
+					PCIE_CFG_PREF_BASE_UPPER), val);
+
+			val = (((pci_addr + size - 1) >> 32) & 0xffffffff);
+			out_le32((((u8 *)port->header_remap) +
+					PCIE_CFG_PREF_LIMIT_UPPER), val);
+
+			break;
+		}
+	}
+
+	/* EP initiated memory access */
+	out_le32((((u8 *)port->header_remap) + PCIE_CFG_AD1),
+						port->pcie2axibar_0);
+	out_le32((((u8 *)port->header_remap) + PCIE_CFG_AD2),
+						port->pcie2axibar_1);
+}
+
+/**
+ * xilinx_setup_axipcie_root_port - Setup root port
+ * @port: Pointer to a root port
+ *
+ * @return: Error / no error
+ *
+ * @note: This is a root port so set it up accordingly
+ */
+static int __init xilinx_setup_axipcie_root_port(
+					struct xilinx_axipcie_port *port)
+{
+	struct pci_controller *hose = NULL;
+	u32 val = 0;
+
+	/* Allocate the host controller data structure */
+	hose = pcibios_alloc_controller(port->node);
+	if (!hose) {
+		iounmap(port->base_addr_remap);
+		iounmap(port->header_remap);
+		return -ENOMEM;
+	}
+
+	hose->indirect_type = port->index;
+
+	/* Get bus range */
+	hose->first_busno = last_bus_on_record;
+
+	val = in_le32(((u8 *)port->header_remap) + AXIPCIE_REG_BIR);
+	val = (val >> 16) & 0x7;
+	hose->last_busno = (((port->reg_base - port->reg_len - 1) >> 20)
+							& 0xFF) & val;
+
+	/* Write primary, secondary and subordinate bus numbers */
+	val = hose->first_busno;
+	val |= ((hose->first_busno + 1) << 8);
+	val |= (hose->last_busno << 16);
+
+	out_le32((((u8 *)port->header_remap) + PCIE_CFG_BUS), val);
+	last_bus_on_record = hose->last_busno + 1;
+
+	port->ecam_remap = port->header_remap;
+
+	/* Setup config space */
+	hose->cfg_addr = port->header_remap;
+	hose->cfg_data = port->ecam_remap;
+	hose->ops = &xlnx_pcie_pci_ops;
+	port->hose = hose;
+
+	xilinx_set_bridge_resource(port);
+	/* Parse outbound mapping resources */
+	pci_process_bridge_OF_ranges(hose, port->node, PRIMARY_BUS);
+
+	return 0;
+}
+
+/**
+ * Interrupt handler
+ */
+static irqreturn_t xilinx_axipcie_intr_handler(int irq, void *data)
+{
+	struct xilinx_axipcie_port *port = (struct xilinx_axipcie_port *)data;
+	u32 val = 0, mask = 0;
+	u32 status;
+	u32 msi_addr = 0;
+	u32 msi_data = 0;
+
+	/* Read interrupt decode and mask registers */
+	val = in_le32(((u8 *)port->header_remap) + AXIPCIE_REG_IDR);
+	mask = in_le32(((u8 *)port->header_remap) + AXIPCIE_REG_IMR);
+
+	status = val & mask;
+	if (!status)
+		return IRQ_NONE;
+
+	if (status & AXIPCIE_INTR_LINK_DOWN)
+		printk(KERN_ERR "Link Down\n");
+
+	if (status & AXIPCIE_INTR_ECRC_ERR)
+		printk(KERN_WARNING "ECRC failed\n");
+
+	if (status & AXIPCIE_INTR_STR_ERR)
+		printk(KERN_WARNING "Streaming error\n");
+
+	if (status & AXIPCIE_INTR_HOT_RESET)
+		printk(KERN_INFO "Hot reset\n");
+
+	if (status & AXIPCIE_INTR_CFG_TIMEOUT)
+		printk(KERN_WARNING "ECAM access timeout\n");
+
+	if (status & AXIPCIE_INTR_CORRECTABLE) {
+		printk(KERN_WARNING "Correctable error message\n");
+		val = in_le32(((u8 *)port->header_remap) +
+				AXIPCIE_REG_RPEFR);
+		if (val & (1 << 18)) {
+			out_le32((((u8 *)port->base_addr_remap) +
+				AXIPCIE_REG_RPEFR), 0xFFFFFFFF);
+			DBG("Requester ID %d\n", (val & 0xffff));
+		}
+	}
+
+	if (status & AXIPCIE_INTR_NONFATAL) {
+		printk(KERN_WARNING "Non fatal error message\n");
+		val = in_le32(((u8 *)port->header_remap) +
+				AXIPCIE_REG_RPEFR);
+		if (val & (1 << 18)) {
+			out_le32((((u8 *)port->base_addr_remap) +
+				AXIPCIE_REG_RPEFR), 0xFFFFFFFF);
+			DBG("Requester ID %d\n", (val & 0xffff));
+		}
+	}
+
+	if (status & AXIPCIE_INTR_FATAL) {
+		printk(KERN_WARNING "Fatal error message\n");
+		val = in_le32(((u8 *)port->header_remap) +
+				AXIPCIE_REG_RPEFR);
+		if (val & (1 << 18)) {
+			out_le32((((u8 *)port->base_addr_remap) +
+				AXIPCIE_REG_RPEFR), 0xFFFFFFFF);
+			DBG("Requester ID %d\n", (val & 0xffff));
+		}
+	}
+
+	if (status & AXIPCIE_INTR_INTX) {
+		/* INTx interrupt received */
+		val = in_le32(((u8 *)port->header_remap) + AXIPCIE_REG_RPIFR1);
+
+		/* Check whether interrupt valid */
+		if (!(val & (1 << 31))) {
+			printk(KERN_WARNING "RP Intr FIFO1 read error\n");
+			return IRQ_HANDLED;
+		}
+
+		/* Check MSI or INTX */
+		if (!(val & (1 << 30))) {
+			if (val & (1 << 29))
+				DBG("INTx assert\n");
+			else
+				DBG("INTx deassert\n");
+		}
+
+		/* Clear interrupt FIFO register 1 */
+		out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_RPIFR1),
+								0xFFFFFFFF);
+	}
+
+	if (status & AXIPCIE_INTR_MSI) {
+		/* MSI Interrupt */
+		val = in_le32(((u8 *)port->header_remap) + AXIPCIE_REG_RPIFR1);
+
+		if (!(val & (1 << 31))) {
+			printk(KERN_WARNING "RP Intr FIFO1 read error\n");
+			return IRQ_HANDLED;
+		}
+
+		if (val & (1 << 30)) {
+			msi_addr = (val >> 16) & 0x7FF;
+			msi_data = in_le32(((u8 *)port->header_remap) +
+						AXIPCIE_REG_RPIFR2) & 0xFFFF;
+			DBG("%s: msi_addr %08x msi_data %08x\n",
+					__func__, msi_addr, msi_data);
+		}
+
+		/* Clear interrupt FIFO register 1 */
+		out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_RPIFR1),
+								0xFFFFFFFF);
+#ifdef CONFIG_PCI_MSI
+		/* Handle MSI Interrupt */
+		if (msi_data >= IRQ_XILINX_MSI_0)
+			generic_handle_irq(msi_data);
+#endif
+	}
+
+	if (status & AXIPCIE_INTR_SLV_UNSUPP)
+		printk(KERN_WARNING "Slave unsupported request\n");
+
+	if (status & AXIPCIE_INTR_SLV_UNEXP)
+		printk(KERN_WARNING "Slave unexpected completion\n");
+
+	if (status & AXIPCIE_INTR_SLV_COMPL)
+		printk(KERN_WARNING "Slave completion timeout\n");
+
+	if (status & AXIPCIE_INTR_SLV_ERRP)
+		printk(KERN_WARNING "Slave Error Poison\n");
+
+	if (status & AXIPCIE_INTR_SLV_CMPABT)
+		printk(KERN_WARNING "Slave Completer Abort\n");
+
+	if (status & AXIPCIE_INTR_SLV_ILLBUR)
+		printk(KERN_WARNING "Slave Illegal Burst\n");
+
+	if (status & AXIPCIE_INTR_MST_DECERR)
+		printk(KERN_WARNING "Master decode error\n");
+
+	if (status & AXIPCIE_INTR_MST_SLVERR)
+		printk(KERN_WARNING "Master slave error\n");
+
+	if (status & AXIPCIE_INTR_MST_ERRP)
+		printk(KERN_WARNING "Master error poison\n");
+
+	/* Clear the Interrupt Decode register */
+	out_le32((((u8 *)port->base_addr_remap) + AXIPCIE_REG_IDR), status);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * xilinx_probe_axipcie_node
+ * @np: Pointer to device node to be probed
+ *
+ * @return: Error / no error
+ *
+ * @note: Find out how this pcie node is configured
+ */
+static int __init xilinx_probe_axipcie_node(struct device_node *np)
+{
+	struct xilinx_axipcie_port *port;
+	struct xilinx_axipcie_node ip_setup_info;
+	int portno;
+	int error;
+	int ret;
+
+	printk(KERN_INFO "Probing Xilinx PCI Express root complex device\n");
+
+	error = xilinx_get_axipcie_ip_config_info(np , &ip_setup_info);
+
+	if (error) {
+		printk(KERN_INFO "Error while getting pcie config info\n");
+		return error;
+	}
+
+	if (!xilinx_axipcie_port_count) {
+		xilinx_axipcie_port_count = ip_setup_info.number_of_instances;
+
+		if (xilinx_axipcie_port_count) {
+
+			xilinx_axipcie_ports =
+					kzalloc(xilinx_axipcie_port_count *
+			sizeof(struct xilinx_axipcie_port), GFP_KERNEL);
+
+			if (!xilinx_axipcie_ports) {
+				printk(KERN_INFO "Memory allocation failed\n");
+				return -ENOMEM;
+			}
+		} else /* not suppose to be here
+			* when we don't have pcie ports */
+			return -ENODEV;
+	}
+
+	/* Initialize this port vital info. struct */
+	portno = ip_setup_info.device_id;
+
+	port = &xilinx_axipcie_ports[portno];
+	port->node = of_node_get(np);
+	port->index = portno;
+	port->type = ip_setup_info.device_type;
+	port->reg_base = ip_setup_info.reg_base;
+	port->reg_len = ip_setup_info.reg_len;
+	port->bars_num  = ip_setup_info.bars_num;
+	port->irq_num	= ip_setup_info.irq_num;
+	port->header_addr = port->reg_base + AXIPCIE_LOCAL_CNFG_BASE;
+	port->pcie2axibar_0 = ip_setup_info.pcie2axibar_0;
+	port->pcie2axibar_1 = ip_setup_info.pcie2axibar_1;
+
+	irq_set_chip_data(port->irq_num, port);
+
+	/* initialize hardware */
+	error = xilinx_init_axipcie_port(port);
+	if (error) {
+		printk(KERN_INFO "Error while initialize pcie port\n");
+		return error;
+	}
+
+	/* Register interrupt handler */
+	ret = request_irq(port->irq_num, xilinx_axipcie_intr_handler,
+						IRQF_SHARED, "xaxipcie", port);
+	if (ret) {
+		printk(KERN_ERR "%s: Could not allocate interrupt\n", __func__);
+		return ret;
+	}
+
+	/* Setup hose data structure */
+	if (port->type) {
+		error = xilinx_setup_axipcie_root_port(port);
+		if (error) {
+			printk(KERN_INFO "Error while initialize "
+							"pcie root port\n");
+			return error;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * pcibios_set_master - Architecture specific function
+ * @dev: A pointer to device pcie device struct
+ *
+ * @return: Error / no error
+ * @note: Enables Bridge Enable bit during the rescan process
+ */
+void pcibios_set_master(struct pci_dev *dev)
+{
+	struct pci_controller *hose =
+			(struct pci_controller *) dev->bus->sysdata;
+	struct xilinx_axipcie_port *port =
+			&xilinx_axipcie_ports[hose->indirect_type];
+
+	if (port->link)
+		bridge_enable(port->base_addr_remap);
+}
+
+/**
+ * xilinx_find_axipcie_nodes - Entry function
+ * void
+ *
+ * @return: Error / no error
+ * @note: Find pcie nodes in device tree
+ */
+static int __init xilinx_find_axipcie_nodes(void)
+{
+	struct device_node *np;
+	const struct of_device_id *matches = xilinx_axipcie_match;
+	int error = 0;
+
+	printk(KERN_INFO "Initialising Xilinx PCI Express root"
+						" complex device\n");
+	for_each_matching_node(np, matches) {
+		error = xilinx_probe_axipcie_node(np);
+		if (error)
+			return error;
+	}
+	return 0;
+}
+
+arch_initcall(xilinx_find_axipcie_nodes);
diff --git a/arch/microblaze/pci/xilinx_axipcie.h b/arch/microblaze/pci/xilinx_axipcie.h
new file mode 100644
index 0000000..15194e1
--- /dev/null
+++ b/arch/microblaze/pci/xilinx_axipcie.h
@@ -0,0 +1,156 @@
+/*
+ * Header file for Xilinx AXI PCIe IP driver.
+ *
+ * Copyright (c) 2010-2011 Xilinx, Inc.
+ *
+ * This program has adopted some work from PCI/PCIE support for AMCC
+ * PowerPC boards written by Benjamin Herrenschmidt.
+ * Copyright 2007 Ben. Herrenschmidt <benh@kernel.crashing.org>, IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef XILINX_AXIPCIE_H_
+#define XILINX_AXIPCIE_H_
+
+/* Register definitions */
+#define PCIE_CFG_CMD			0x00000004
+#define PCIE_CFG_CLS			0x00000008
+#define PCIE_CFG_HDR			0x0000000C
+#define PCIE_CFG_AD1			0x00000010
+#define PCIE_CFG_AD2			0x00000014
+#define PCIE_CFG_BUS			0x00000018
+#define PCIE_CFG_IO			0x0000001C
+#define PCIE_CFG_MEM			0x00000020
+#define PCIE_CFG_PREF_MEM		0x00000024
+#define PCIE_CFG_PREF_BASE_UPPER	0x00000028
+#define PCIE_CFG_PREF_LIMIT_UPPER	0x0000002c
+#define PCIE_CFG_IO_UPPER		0x00000030
+
+#define AXIPCIE_REG_VSECC		0x00000128
+#define AXIPCIE_REG_VSECH		0x0000012c
+#define AXIPCIE_REG_BIR			0x00000130
+#define AXIPCIE_REG_BSCR		0x00000134
+#define AXIPCIE_REG_IDR			0x00000138
+#define AXIPCIE_REG_IMR			0x0000013c
+#define AXIPCIE_REG_BLR			0x00000140
+#define AXIPCIE_REG_PSCR		0x00000144
+#define AXIPCIE_REG_RPSC		0x00000148
+#define AXIPCIE_REG_MSIBASE1		0x0000014c
+#define AXIPCIE_REG_MSIBASE2		0x00000150
+#define AXIPCIE_REG_RPEFR		0x00000154
+#define AXIPCIE_REG_RPIFR1		0x00000158
+#define AXIPCIE_REG_RPIFR2		0x0000015c
+#define AXIPCIE_REG_VSECC2		0x00000200
+#define AXIPCIE_REG_VSECH2		0x00000204
+
+/* Interrupt register defines */
+#define AXIPCIE_INTR_LINK_DOWN		(1 << 0)
+#define AXIPCIE_INTR_ECRC_ERR		(1 << 1)
+#define AXIPCIE_INTR_STR_ERR		(1 << 2)
+#define AXIPCIE_INTR_HOT_RESET		(1 << 3)
+#define AXIPCIE_INTR_CFG_COMPL		(7 << 5)
+#define AXIPCIE_INTR_CFG_TIMEOUT	(1 << 8)
+#define AXIPCIE_INTR_CORRECTABLE	(1 << 9)
+#define AXIPCIE_INTR_NONFATAL		(1 << 10)
+#define AXIPCIE_INTR_FATAL		(1 << 11)
+#define AXIPCIE_INTR_INTX		(1 << 16)
+#define AXIPCIE_INTR_MSI		(1 << 17)
+#define AXIPCIE_INTR_SLV_UNSUPP		(1 << 20)
+#define AXIPCIE_INTR_SLV_UNEXP		(1 << 21)
+#define AXIPCIE_INTR_SLV_COMPL		(1 << 22)
+#define AXIPCIE_INTR_SLV_ERRP		(1 << 23)
+#define AXIPCIE_INTR_SLV_CMPABT		(1 << 24)
+#define AXIPCIE_INTR_SLV_ILLBUR		(1 << 25)
+#define AXIPCIE_INTR_MST_DECERR		(1 << 26)
+#define AXIPCIE_INTR_MST_SLVERR		(1 << 27)
+#define AXIPCIE_INTR_MST_ERRP		(1 << 28)
+
+#define BUS_LOC_SHIFT			20
+#define DEV_LOC_SHIFT			12
+#define PRIMARY_BUS			1
+#define PORT_REG_SIZE			0x1000
+#define PORT_HEADER_SIZE		0x128
+
+#define AXIPCIE_LOCAL_CNFG_BASE		0x00000000
+#define AXIPCIE_REG_BASE		0x00000128
+#define AXIPCIE_REG_PSCR_LNKUP		0x00000800
+#define AXIPCIE_REG_IMR_MASKALL		0x1FF30FED
+#define AXIPCIE_REG_IDR_MASKALL		0xFFFFFFFF
+#define AXIPCIE_REG_RPSC_BEN		0x00000001
+#define BUS_MASTER_ENABLE		0x00000004
+
+/* debug */
+//#define XILINX_AXIPCIE_DEBUG
+#ifdef XILINX_AXIPCIE_DEBUG
+#define DBG(x...) ((void)printk(x))
+#else
+#define DBG(x...)	\
+	do {		\
+	} while(0)
+#endif
+
+/* Xilinx CR# 657412 */
+/* Byte swapping */
+#define xpcie_out_be32(a, v) __raw_writel(__cpu_to_be32(v), (a))
+#define xpcie_out_be16(a, v) __raw_writew(__cpu_to_be16(v), (a))
+
+#define xpcie_in_be32(a) __be32_to_cpu(__raw_readl(a))
+#define xpcie_in_be16(a) __be16_to_cpu(__raw_readw(a))
+
+#ifdef CONFIG_PCI_MSI
+extern unsigned long msg_addr;
+#endif
+
+struct xilinx_axipcie_node {
+	u32 number_of_instances;
+	u32 device_id;
+	u32 device_type;
+	u32 ecam_base;
+	u32 ecam_high;
+	u32 baseaddr;
+	u32 highaddr;
+	u32 bars_num;
+	u32 irq_num;
+	u32 reg_base;
+	u32 reg_len;
+	u32 pcie2axibar_0;
+	u32 pcie2axibar_1;
+};
+
+struct xilinx_axipcie_port {
+	struct pci_controller	*hose;
+	struct device_node	*node;
+	u32			reg_base;
+	u32			reg_len;
+	u32			ecam_base;
+	u32			ecam_high;
+	u32			baseaddr;
+	u32			highaddr;
+	u32			header_addr;
+	u8			index;
+	u8			type;
+	u8			link;
+	u8			bars_num;
+	u32			irq_num;
+	unsigned int __iomem	*base_addr_remap;
+	unsigned int __iomem	*header_remap;
+	unsigned int __iomem	*ecam_remap;
+	u32 pcie2axibar_0;
+	u32 pcie2axibar_1;
+};
+
+#endif /* XILINX_AXIPCIE_H_ */
-- 
1.7.5.4

