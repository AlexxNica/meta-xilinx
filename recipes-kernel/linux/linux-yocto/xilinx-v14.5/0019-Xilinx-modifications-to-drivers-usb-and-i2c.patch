From e07a0f13cc37d7bfb005479f8fdbe95c4b705d76 Mon Sep 17 00:00:00 2001
From: Sipke Vriend <sipke.vriend@xilinx.com>
Date: Wed, 15 May 2013 15:29:38 +1000
Subject: [PATCH 19/24] Xilinx modifications to drivers usb and i2c

Signed-off-by: Sipke Vriend <sipke.vriend@xilinx.com>
---
 drivers/i2c/busses/Kconfig            |    6 +
 drivers/i2c/busses/Makefile           |    1 +
 drivers/i2c/busses/i2c-xilinx_ps.c    |  988 +++++++++++
 drivers/usb/Kconfig                   |    1 +
 drivers/usb/c67x00/c67x00-drv.c       |   53 +-
 drivers/usb/c67x00/c67x00-hcd.h       |    4 +-
 drivers/usb/c67x00/c67x00-sched.c     |   13 +-
 drivers/usb/core/hub.c                |    4 +
 drivers/usb/gadget/Kconfig            |   49 +-
 drivers/usb/gadget/Makefile           |    2 +
 drivers/usb/gadget/xilinx_udc.c       | 2379 +++++++++++++++++++++++++
 drivers/usb/gadget/xilinx_usbps_udc.c | 3099 +++++++++++++++++++++++++++++++++
 drivers/usb/host/Kconfig              |   14 +
 drivers/usb/host/Makefile             |    1 +
 drivers/usb/host/ehci-hcd.c           |   55 +-
 drivers/usb/host/ehci-hub.c           |   20 +
 drivers/usb/host/ehci-xilinx-usbps.c  |  542 ++++++
 drivers/usb/host/ehci-xilinx-usbps.h  |   33 +
 drivers/usb/host/ehci.h               |    8 +
 drivers/usb/host/xusbps-dr-of.c       |  336 ++++
 drivers/usb/otg/Kconfig               |   12 +
 drivers/usb/otg/Makefile              |    1 +
 drivers/usb/otg/ulpi.c                |    2 +
 drivers/usb/otg/xilinx_usbps_otg.c    | 2316 ++++++++++++++++++++++++
 include/linux/usb/xilinx_usbps_otg.h  |  216 +++
 include/linux/xilinx_devices.h        |   70 +
 26 files changed, 10214 insertions(+), 11 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-xilinx_ps.c
 create mode 100644 drivers/usb/gadget/xilinx_udc.c
 create mode 100644 drivers/usb/gadget/xilinx_usbps_udc.c
 create mode 100644 drivers/usb/host/ehci-xilinx-usbps.c
 create mode 100644 drivers/usb/host/ehci-xilinx-usbps.h
 create mode 100644 drivers/usb/host/xusbps-dr-of.c
 create mode 100644 drivers/usb/otg/xilinx_usbps_otg.c
 create mode 100644 include/linux/usb/xilinx_usbps_otg.h
 create mode 100644 include/linux/xilinx_devices.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index bdca511..cf167ac 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -700,6 +700,12 @@ config I2C_VERSATILE
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-versatile.
 
+config I2C_XILINX_PS
+	tristate "XILINX PS I2C Controller"
+	depends on ARCH_ZYNQ
+	help
+	  Say yes here to select Xilnx PS I2C Host Controller
+
 config I2C_OCTEON
 	tristate "Cavium OCTEON I2C bus support"
 	depends on CPU_CAVIUM_OCTEON
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 6181f3f..2a3e08e 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -69,6 +69,7 @@ obj-$(CONFIG_I2C_SIRF)		+= i2c-sirf.o
 obj-$(CONFIG_I2C_STU300)	+= i2c-stu300.o
 obj-$(CONFIG_I2C_TEGRA)		+= i2c-tegra.o
 obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
+obj-$(CONFIG_I2C_XILINX_PS)	+= i2c-xilinx_ps.o
 obj-$(CONFIG_I2C_OCTEON)	+= i2c-octeon.o
 obj-$(CONFIG_I2C_XILINX)	+= i2c-xiic.o
 obj-$(CONFIG_I2C_XLR)		+= i2c-xlr.o
diff --git a/drivers/i2c/busses/i2c-xilinx_ps.c b/drivers/i2c/busses/i2c-xilinx_ps.c
new file mode 100644
index 0000000..1191a8b
--- /dev/null
+++ b/drivers/i2c/busses/i2c-xilinx_ps.c
@@ -0,0 +1,988 @@
+/*
+ * Xilinx I2C bus driver for the PS I2C Interfaces.
+ *
+ * 2009-2011 (c) Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it
+ * and/or modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2 of the License, or (at your option) any
+ * later version.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
+ * 02139, USA.
+ *
+ *
+ * Workaround in Receive Mode
+ *	If there is only one message to be processed, then based on length of
+ *	the message we set the HOLD bit.
+ *	If the length is less than the FIFO depth, then we will directly
+ *	receive a COMP interrupt and the transaction is done.
+ *	If the length is more than the FIFO depth, then we enable the HOLD bit
+ *	and write FIFO depth to the transfer size register.
+ *	We will receive the DATA interrupt, we calculate the remaining bytes
+ *	to receive and write to the transfer size register and we process the
+ *	data in FIFO.
+ *	In the meantime, we are receiving the complete interrupt also and the
+ *	controller waits for the default timeout period before generating a stop
+ *	condition even though the HOLD bit is set. So we are unable to generate
+ *	the data interrupt again.
+ *	To avoid this, we wrote the expected bytes to receive as FIFO depth + 1
+ *	instead of FIFO depth. This generated the second DATA interrupt as there
+ *	are still outstanding bytes to be received.
+ *
+ *	The bus hold flag logic provides support for repeated start.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_i2c.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/xilinx_devices.h>
+
+/*
+ * Register Map
+ * Register offsets for the I2C device.
+ */
+#define XI2CPS_CR_OFFSET	0x00 /* Control Register, RW */
+#define XI2CPS_SR_OFFSET	0x04 /* Status Register, RO */
+#define XI2CPS_ADDR_OFFSET	0x08 /* I2C Address Register, RW */
+#define XI2CPS_DATA_OFFSET	0x0C /* I2C Data Register, RW */
+#define XI2CPS_ISR_OFFSET	0x10 /* Interrupt Status Register, RW */
+#define XI2CPS_XFER_SIZE_OFFSET 0x14 /* Transfer Size Register, RW */
+#define XI2CPS_SLV_PAUSE_OFFSET 0x18 /* Slave monitor pause Register, RW */
+#define XI2CPS_TIME_OUT_OFFSET	0x1C /* Time Out Register, RW */
+#define XI2CPS_IMR_OFFSET	0x20 /* Interrupt Mask Register, RO */
+#define XI2CPS_IER_OFFSET	0x24 /* Interrupt Enable Register, WO */
+#define XI2CPS_IDR_OFFSET	0x28 /* Interrupt Disable Register, WO */
+
+/*
+ * Control Register Bit mask definitions
+ * This register contains various control bits that affect the operation of the
+ * I2C controller.
+ */
+#define XI2CPS_CR_HOLD_BUS_MASK 0x00000010 /* Hold Bus bit */
+#define XI2CPS_CR_RW_MASK	0x00000001 /* Read or Write Master transfer
+					    * 0= Transmitter, 1= Receiver */
+#define XI2CPS_CR_CLR_FIFO_MASK 0x00000040 /* 1 = Auto init FIFO to zeroes */
+
+/*
+ * I2C Address Register Bit mask definitions
+ * Normal addressing mode uses [6:0] bits. Extended addressing mode uses [9:0]
+ * bits. A write access to this register always initiates a transfer if the I2C
+ * is in master mode.
+ */
+#define XI2CPS_ADDR_MASK	0x000003FF /* I2C Address Mask */
+
+/*
+ * I2C Interrupt Registers Bit mask definitions
+ * All the four interrupt registers (Status/Mask/Enable/Disable) have the same
+ * bit definitions.
+ */
+#define XI2CPS_IXR_ALL_INTR_MASK 0x000002FF /* All ISR Mask */
+
+#define XI2CPS_FIFO_DEPTH	16		/* FIFO Depth */
+#define XI2CPS_TIMEOUT		(50 * HZ)	/* Timeout for bus busy check */
+#define XI2CPS_ENABLED_INTR	0x2EF		/* Enabled Interrupts */
+
+#define XI2CPS_DATA_INTR_DEPTH (XI2CPS_FIFO_DEPTH - 2)/* FIFO depth at which
+							 * the DATA interrupt
+							 * occurs
+							 */
+
+#define DRIVER_NAME		"xi2cps"
+
+#define xi2cps_readreg(offset)		__raw_readl(id->membase + offset)
+#define xi2cps_writereg(val, offset)	__raw_writel(val, id->membase + offset)
+
+/**
+ * struct xi2cps - I2C device private data structure
+ * @membase:		Base address of the I2C device
+ * @adap:		I2C adapter instance
+ * @p_msg:		Message pointer
+ * @err_status:		Error status in Interrupt Status Register
+ * @xfer_done:		Transfer complete status
+ * @p_send_buf:		Pointer to transmit buffer
+ * @p_recv_buf:		Pointer to receive buffer
+ * @send_count:		Number of bytes still expected to send
+ * @recv_count:		Number of bytes still expected to receive
+ * @irq:		IRQ number
+ * @cur_timeout:	The current timeout value used by the device
+ * @input_clk:		Input clock to I2C controller
+ * @i2c_clk:		Current I2C frequency
+ * @bus_hold_flag:	Flag used in repeated start for clearing HOLD bit
+ * @clk			Pointer to struct clk
+ * @clk_rate_change_nb	Notifier block for clock rate changes
+ */
+struct xi2cps {
+	void __iomem *membase;
+	struct i2c_adapter adap;
+	struct i2c_msg	*p_msg;
+	int err_status;
+	struct completion xfer_done;
+	unsigned char *p_send_buf;
+	unsigned char *p_recv_buf;
+	int send_count;
+	int recv_count;
+	int irq;
+	int cur_timeout;
+	unsigned int input_clk;
+	unsigned int i2c_clk;
+	unsigned int bus_hold_flag;
+	struct clk	*clk;
+	struct notifier_block	clk_rate_change_nb;
+};
+
+#define to_xi2cps(_nb)	container_of(_nb, struct xi2cps,\
+		clk_rate_change_nb)
+#define MAX_F_ERR 10000
+
+/**
+ * xi2cps_isr - Interrupt handler for the I2C device
+ * @irq:	irq number for the I2C device
+ * @ptr:	void pointer to xi2cps structure
+ *
+ * Returns IRQ_HANDLED always
+ *
+ * This function handles the data interrupt, transfer complete interrupt and
+ * the error interrupts of the I2C device.
+ */
+static irqreturn_t xi2cps_isr(int irq, void *ptr)
+{
+	unsigned int isr_status, avail_bytes;
+	unsigned int bytes_to_recv, bytes_to_send;
+	unsigned int ctrl_reg = 0;
+	struct xi2cps *id = ptr;
+
+	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
+
+	/* Handling Nack interrupt */
+	if (isr_status & 0x00000004)
+		complete(&id->xfer_done);
+
+	/* Handling Arbitration lost interrupt */
+	if (isr_status & 0x00000200)
+		complete(&id->xfer_done);
+
+	/* Handling Data interrupt */
+	if (isr_status & 0x00000002) {
+		/*
+		 * In master mode, if the device has more data to receive.
+		 * Calculate received bytes and update the receive count.
+		 */
+		if ((id->recv_count) > XI2CPS_FIFO_DEPTH) {
+			/* FIXME: snapshotting this value is a race condition as
+			 * the hardware is still recieving bytes at this time.
+			 * The number of bytes recieved (N) is read here ....
+			 */
+			bytes_to_recv = (XI2CPS_FIFO_DEPTH + 1) -
+				xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
+			id->recv_count -= bytes_to_recv;
+		/*
+		 * Calculate the expected bytes to be received further and
+		 * update in transfer size register. If the expected bytes
+		 * count is less than FIFO size then clear hold bit if there
+		 * are no further messages to be processed
+		 */
+			/* ... but supposed one more byte is read by the
+			 * hardware by this time ....
+			 */
+			if (id->recv_count > XI2CPS_FIFO_DEPTH) {
+				xi2cps_writereg(XI2CPS_FIFO_DEPTH + 1,
+						XI2CPS_XFER_SIZE_OFFSET);
+			} else {
+				/* Then the number bytes still to recv (M) is
+				 * updated based on old value of tx XFER_SIZE.
+				 * Hardware will recieve a total of N + M or
+				 * N + M + 1 bytes depending on whether or not
+				 * the hardware gets an extra byte between the
+				 * snapshot and here.
+				 */
+				xi2cps_writereg(id->recv_count,
+						XI2CPS_XFER_SIZE_OFFSET);
+				if (id->bus_hold_flag == 0)
+					/* Clear the hold bus bit */
+					xi2cps_writereg(
+					     (xi2cps_readreg(XI2CPS_CR_OFFSET) &
+					     (~XI2CPS_CR_HOLD_BUS_MASK)),
+					     XI2CPS_CR_OFFSET);
+			}
+			/* Process the data received */
+			while (bytes_to_recv) {
+				*(id->p_recv_buf)++ =
+					xi2cps_readreg(XI2CPS_DATA_OFFSET);
+				bytes_to_recv = bytes_to_recv - 1;
+			}
+		}
+	}
+
+	/* Handling Transfer Complete interrupt */
+	if (isr_status & 0x00000001) {
+		if ((id->p_recv_buf) == NULL) {
+			/*
+			 * If the device is sending data If there is further
+			 * data to be sent. Calculate the available space
+			 * in FIFO and fill the FIFO with that many bytes.
+			 */
+			if (id->send_count > 0) {
+				avail_bytes = XI2CPS_FIFO_DEPTH -
+				xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
+				if (id->send_count > avail_bytes)
+					bytes_to_send = avail_bytes;
+				else
+					bytes_to_send = id->send_count;
+
+				while (bytes_to_send--) {
+					xi2cps_writereg(
+						(*(id->p_send_buf)++),
+						 XI2CPS_DATA_OFFSET);
+					id->send_count--;
+				}
+			} else {
+		/*
+		 * Signal the completion of transaction and clear the hold bus
+		 * bit if there are no further messages to be processed.
+		 */
+				complete(&id->xfer_done);
+			}
+			if (id->send_count == 0) {
+				if (id->bus_hold_flag == 0) {
+					/* Clear the hold bus bit */
+					ctrl_reg =
+					xi2cps_readreg(XI2CPS_CR_OFFSET);
+					if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
+						== XI2CPS_CR_HOLD_BUS_MASK)
+						xi2cps_writereg(
+						(ctrl_reg &
+						(~XI2CPS_CR_HOLD_BUS_MASK)),
+						XI2CPS_CR_OFFSET);
+				}
+			}
+		} else {
+			if (id->bus_hold_flag == 0) {
+				/* Clear the hold bus bit */
+				ctrl_reg =
+				xi2cps_readreg(XI2CPS_CR_OFFSET);
+				if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK)
+					== XI2CPS_CR_HOLD_BUS_MASK)
+					xi2cps_writereg(
+					(ctrl_reg &
+					(~XI2CPS_CR_HOLD_BUS_MASK)),
+					XI2CPS_CR_OFFSET);
+			}
+		/*
+		 * If the device is receiving data, then signal the completion
+		 * of transaction and read the data present in the FIFO.
+		 * Signal the completion of transaction.
+		 */
+			while (xi2cps_readreg(XI2CPS_SR_OFFSET)
+							& 0x00000020) {
+				*(id->p_recv_buf)++ =
+					xi2cps_readreg(XI2CPS_DATA_OFFSET);
+				id->recv_count--;
+			}
+			complete(&id->xfer_done);
+		}
+	}
+
+	/* Update the status for errors */
+	id->err_status = isr_status & 0x000002EC;
+	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
+	return IRQ_HANDLED;
+}
+
+/**
+ * xi2cps_mrecv - Prepare and start a master receive operation
+ * @id:		pointer to the i2c device structure
+ *
+ */
+static void xi2cps_mrecv(struct xi2cps *id)
+{
+	unsigned int ctrl_reg;
+	unsigned int isr_status;
+
+	id->p_recv_buf = id->p_msg->buf;
+	id->recv_count = id->p_msg->len;
+
+	/*
+	 * Set the controller in master receive mode and clear the FIFO.
+	 * Set the slave address in address register.
+	 * Check for the message size against FIFO depth and set the
+	 * HOLD bus bit if it is more than FIFO depth.
+	 * Clear the interrupts in interrupt status register.
+	 */
+	ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
+	ctrl_reg |= (XI2CPS_CR_RW_MASK | XI2CPS_CR_CLR_FIFO_MASK);
+
+	if ((id->p_msg->flags & I2C_M_RECV_LEN) == I2C_M_RECV_LEN)
+		id->recv_count = I2C_SMBUS_BLOCK_MAX + 1;
+
+	if (id->recv_count > XI2CPS_FIFO_DEPTH)
+		ctrl_reg |= XI2CPS_CR_HOLD_BUS_MASK;
+
+	xi2cps_writereg(ctrl_reg, XI2CPS_CR_OFFSET);
+
+	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
+	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
+
+	xi2cps_writereg((id->p_msg->addr & XI2CPS_ADDR_MASK),
+						XI2CPS_ADDR_OFFSET);
+	/*
+	 * The no. of bytes to receive is checked against the limit of
+	 * FIFO depth. Set transfer size register with no. of bytes to
+	 * receive if it is less than FIFO depth and FIFO depth + 1 if
+	 * it is more. Enable the interrupts.
+	 */
+	if (id->recv_count > XI2CPS_FIFO_DEPTH) {
+		xi2cps_writereg(XI2CPS_FIFO_DEPTH + 1,
+				XI2CPS_XFER_SIZE_OFFSET);
+	} else {
+		xi2cps_writereg(id->recv_count, XI2CPS_XFER_SIZE_OFFSET);
+
+	/*
+	 * Clear the bus hold flag if bytes to receive is less than FIFO size.
+	 */
+		if (id->bus_hold_flag == 0 &&
+		((id->p_msg->flags & I2C_M_RECV_LEN) != I2C_M_RECV_LEN)) {
+			/* Clear the hold bus bit */
+			ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
+			if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK) ==
+					XI2CPS_CR_HOLD_BUS_MASK)
+				xi2cps_writereg(
+					(ctrl_reg & (~XI2CPS_CR_HOLD_BUS_MASK)),
+					XI2CPS_CR_OFFSET);
+		}
+	}
+	xi2cps_writereg(XI2CPS_ENABLED_INTR, XI2CPS_IER_OFFSET);
+}
+
+/**
+ * xi2cps_msend - Prepare and start a master send operation
+ * @id:		pointer to the i2c device
+ *
+ */
+static void xi2cps_msend(struct xi2cps *id)
+{
+	unsigned int avail_bytes;
+	unsigned int bytes_to_send;
+	unsigned int ctrl_reg;
+	unsigned int isr_status;
+
+	id->p_recv_buf = NULL;
+	id->p_send_buf = id->p_msg->buf;
+	id->send_count = id->p_msg->len;
+
+	/*
+	 * Set the controller in Master transmit mode and clear the FIFO.
+	 * Set the slave address in address register.
+	 * Check for the message size against FIFO depth and set the
+	 * HOLD bus bit if it is more than FIFO depth.
+	 * Clear the interrupts in interrupt status register.
+	 */
+	ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
+	ctrl_reg &= ~XI2CPS_CR_RW_MASK;
+	ctrl_reg |= XI2CPS_CR_CLR_FIFO_MASK;
+
+	if ((id->send_count) > XI2CPS_FIFO_DEPTH)
+		ctrl_reg |= XI2CPS_CR_HOLD_BUS_MASK;
+	xi2cps_writereg(ctrl_reg, XI2CPS_CR_OFFSET);
+
+	isr_status = xi2cps_readreg(XI2CPS_ISR_OFFSET);
+	xi2cps_writereg(isr_status, XI2CPS_ISR_OFFSET);
+
+	/*
+	 * Calculate the space available in FIFO. Check the message length
+	 * against the space available, and fill the FIFO accordingly.
+	 * Enable the interrupts.
+	 */
+	avail_bytes = XI2CPS_FIFO_DEPTH -
+				xi2cps_readreg(XI2CPS_XFER_SIZE_OFFSET);
+
+	if (id->send_count > avail_bytes)
+		bytes_to_send = avail_bytes;
+	else
+		bytes_to_send = id->send_count;
+
+	while (bytes_to_send--) {
+		xi2cps_writereg((*(id->p_send_buf)++), XI2CPS_DATA_OFFSET);
+		id->send_count--;
+	}
+
+	xi2cps_writereg((id->p_msg->addr & XI2CPS_ADDR_MASK),
+						XI2CPS_ADDR_OFFSET);
+
+	/*
+	 * Clear the bus hold flag if there is no more data
+	 * and if it is the last message.
+	 */
+	if (id->bus_hold_flag == 0 && id->send_count == 0) {
+		/* Clear the hold bus bit */
+		ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
+		if ((ctrl_reg & XI2CPS_CR_HOLD_BUS_MASK) ==
+				XI2CPS_CR_HOLD_BUS_MASK)
+			xi2cps_writereg(
+				(ctrl_reg & (~XI2CPS_CR_HOLD_BUS_MASK)),
+				XI2CPS_CR_OFFSET);
+	}
+	xi2cps_writereg(XI2CPS_ENABLED_INTR, XI2CPS_IER_OFFSET);
+}
+
+/**
+ * xi2cps_master_xfer - The main i2c transfer function
+ * @adap:	pointer to the i2c adapter driver instance
+ * @msgs:	pointer to the i2c message structure
+ * @num:	the number of messages to transfer
+ *
+ * Returns number of msgs processed on success, negative error otherwise
+ *
+ * This function waits for the bus idle condition and updates the timeout if
+ * modified by user. Then initiates the send/recv activity based on the
+ * transfer message received.
+ */
+static int xi2cps_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+				int num)
+{
+	struct xi2cps *id = adap->algo_data;
+	unsigned int count, retries;
+	unsigned long timeout;
+
+	/* Waiting for bus-ready. If bus not ready, it returns after timeout */
+	timeout = jiffies + XI2CPS_TIMEOUT;
+	while ((xi2cps_readreg(XI2CPS_SR_OFFSET)) & 0x00000100) {
+		if (time_after(jiffies, timeout)) {
+			dev_warn(id->adap.dev.parent,
+					"timedout waiting for bus ready\n");
+			return -ETIMEDOUT;
+		}
+		schedule_timeout(1);
+	}
+
+
+	/* The bus is free. Set the new timeout value if updated */
+	if (id->adap.timeout != id->cur_timeout) {
+		xi2cps_writereg((id->adap.timeout & 0xFF),
+					XI2CPS_TIME_OUT_OFFSET);
+		id->cur_timeout = id->adap.timeout;
+	}
+
+	/*
+	 * Set the flag to one when multiple messages are to be
+	 * processed with a repeated start.
+	 */
+	if (num > 1) {
+		id->bus_hold_flag = 1;
+		xi2cps_writereg((xi2cps_readreg(XI2CPS_CR_OFFSET) |
+				XI2CPS_CR_HOLD_BUS_MASK), XI2CPS_CR_OFFSET);
+	} else {
+		id->bus_hold_flag = 0;
+	}
+
+	/* Process the msg one by one */
+	for (count = 0; count < num; count++, msgs++) {
+
+		if (count == (num - 1))
+			id->bus_hold_flag = 0;
+		retries = adap->retries;
+retry:
+		id->err_status = 0;
+		id->p_msg = msgs;
+		init_completion(&id->xfer_done);
+
+		/* Check for the TEN Bit mode on each msg */
+		if (msgs->flags & I2C_M_TEN) {
+			xi2cps_writereg((xi2cps_readreg(XI2CPS_CR_OFFSET) &
+					(~0x00000004)), XI2CPS_CR_OFFSET);
+		} else {
+			if ((xi2cps_readreg(XI2CPS_CR_OFFSET) & 0x00000004)
+								== 0)
+				xi2cps_writereg(
+					(xi2cps_readreg(XI2CPS_CR_OFFSET) |
+					 (0x00000004)), XI2CPS_CR_OFFSET);
+		}
+
+		/* Check for the R/W flag on each msg */
+		if (msgs->flags & I2C_M_RD)
+			xi2cps_mrecv(id);
+		else
+			xi2cps_msend(id);
+
+		/* Wait for the signal of completion */
+		wait_for_completion_interruptible(&id->xfer_done);
+		xi2cps_writereg(XI2CPS_IXR_ALL_INTR_MASK, XI2CPS_IDR_OFFSET);
+
+		/* If it is bus arbitration error, try again */
+		if (id->err_status & 0x00000200) {
+			dev_dbg(id->adap.dev.parent,
+				 "Lost ownership on bus, trying again\n");
+			if (retries--) {
+				mdelay(2);
+				goto retry;
+			}
+			dev_err(id->adap.dev.parent,
+					 "Retries completed, exit\n");
+			num = -EREMOTEIO;
+			break;
+		}
+		/* Report the other error interrupts to application as EIO */
+		if (id->err_status & 0x000000E4) {
+			num = -EIO;
+			break;
+		}
+	}
+
+	id->p_msg = NULL;
+	id->err_status = 0;
+
+	return num;
+}
+
+/**
+ * xi2cps_func - Returns the supported features of the I2C driver
+ * @adap:	pointer to the i2c adapter structure
+ *
+ * Returns 32 bit value, each bit corresponding to a feature
+ */
+static u32 xi2cps_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |
+		(I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK) |
+		I2C_FUNC_SMBUS_BLOCK_DATA;
+}
+
+static const struct i2c_algorithm xi2cps_algo = {
+	.master_xfer	= xi2cps_master_xfer,
+	.functionality	= xi2cps_func,
+};
+
+/**
+ * xi2cps_calc_divs() - Calculate clock dividers
+ * @f:		I2C clock frequency
+ * @input_clk:	Input clock frequency
+ * @a:		First divider (return value)
+ * @b:		Second divider (return value)
+ * @err:	Frequency error
+ * Return 0 on success, negative errno otherwise.
+ *
+ * f is used as input and output variable. As input it is used as target I2C
+ * frequency. On function exit f holds the actually resulting I2C frequency.
+ */
+static int xi2cps_calc_divs(unsigned int *f, unsigned int input_clk,
+		unsigned int *a, unsigned int *b, unsigned int *err)
+{
+	unsigned int fscl = *f;
+	unsigned int div_a, div_b, calc_div_a = 0, calc_div_b = 0;
+	unsigned int best_div_a = 0, best_div_b = 0;
+	unsigned int last_error = 0, current_error = 0;
+	unsigned int best_fscl = *f, actual_fscl, temp, templimit;
+
+	/* Assume div_a is 0 and calculate (divisor_a+1) x (divisor_b+1) */
+	temp = input_clk / (22 * fscl);
+
+	/*
+	 * If the calculated value is negative or 0, the fscl input is out of
+	 * range. Return error.
+	 */
+	if (temp == 0)
+		return -EINVAL;
+
+	/*
+	 * tempLimit helps in iterating over the consecutive value of temp to
+	 * find the closest clock rate achievable with divisors.
+	 */
+	templimit = (input_clk % (22 * fscl)) ? (temp + 1) : temp;
+	*err = fscl;
+
+	for ( ; temp < templimit+1; temp++) {
+		last_error = fscl;
+		calc_div_a = 0;
+		calc_div_b = 0;
+		current_error = 0;
+
+		for (div_b = 0; div_b < 64; div_b++) {
+			div_a = temp / (div_b + 1);
+
+			if (div_a != 0)
+				div_a = div_a - 1;
+
+			if (div_a > 3)
+				continue;
+
+			actual_fscl =
+				input_clk / (22 * (div_a + 1) * (div_b + 1));
+
+			current_error =
+				((actual_fscl > fscl) ? (actual_fscl - fscl) :
+							(fscl - actual_fscl));
+
+			if (last_error > current_error) {
+				calc_div_a = div_a;
+				calc_div_b = div_b;
+				best_fscl = actual_fscl;
+				last_error = current_error;
+			}
+		}
+
+		/*
+		 * Used to capture the best divisors.
+		 */
+		if (last_error < *err) {
+			*err = last_error;
+			best_div_a = calc_div_a;
+			best_div_b = calc_div_b;
+			*f = best_fscl;
+		}
+	}
+
+	*a = best_div_a;
+	*b = best_div_b;
+
+	return 0;
+}
+/**
+ * xi2cps_setclk - This function sets the serial clock rate for the I2C device
+ * @fscl:	The clock frequency in Hz
+ * @id:		Pointer to the I2C device structure
+ *
+ * Returns zero on success, negative error otherwise
+ *
+ * The device must be idle rather than busy transferring data before setting
+ * these device options.
+ * The data rate is set by values in the control register.
+ * The formula for determining the correct register values is
+ *	Fscl = Fpclk/(22 x (divisor_a+1) x (divisor_b+1))
+ * See the hardware data sheet for a full explanation of setting the serial
+ * clock rate. The clock can not be faster than the input clock divide by 22.
+ * The two most common clock rates are 100KHz and 400KHz.
+ */
+static int xi2cps_setclk(unsigned int fscl, struct xi2cps *id)
+{
+	unsigned int div_a, div_b;
+	unsigned int ctrl_reg;
+	unsigned int err;
+	int ret = 0;
+
+	ret = xi2cps_calc_divs(&fscl, id->input_clk, &div_a, &div_b, &err);
+	if (ret)
+		return ret;
+
+	ctrl_reg = xi2cps_readreg(XI2CPS_CR_OFFSET);
+	ctrl_reg &= ~(0x0000C000 | 0x00003F00);
+	ctrl_reg |= ((div_a << 14) | (div_b << 8));
+	xi2cps_writereg(ctrl_reg, XI2CPS_CR_OFFSET);
+
+	return 0;
+}
+
+/**
+ * xi2cps_clk_notifier_cb - Clock rate change callback
+ * @nb:		Pointer to notifier block
+ * @event:	Notification reason
+ * @data:	Pointer to notification data object
+ * Returns NOTIFY_STOP if the rate change should be aborted, NOTIFY_OK
+ * otherwise.
+ *
+ * This function is called when the xi2cps input clock frequency changes. In the
+ * pre-rate change notification here it is determined if the rate change may be
+ * allowed or not.
+ * In th post-change case necessary adjustments are conducted.
+ */
+static int xi2cps_clk_notifier_cb(struct notifier_block *nb, unsigned long
+		event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct xi2cps *id = to_xi2cps(nb);
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+	{
+		/*
+		 * if a rate change is announced we need to check whether we can
+		 * maintain the current frequency by changing the clock
+		 * dividers. Probably we could also define an acceptable
+		 * frequency range.
+		 */
+		unsigned int input_clk = (unsigned int)ndata->new_rate;
+		unsigned int fscl = id->i2c_clk;
+		unsigned int div_a, div_b;
+		unsigned int err = 0;
+		int ret;
+
+		ret = xi2cps_calc_divs(&fscl, input_clk, &div_a, &div_b, &err);
+		if (ret)
+			return NOTIFY_STOP;
+		if (err > MAX_F_ERR)
+			return NOTIFY_STOP;
+
+		return NOTIFY_OK;
+	}
+	case POST_RATE_CHANGE:
+		id->input_clk = ndata->new_rate;
+		/* We probably need to stop the HW before this and restart
+		 * afterwards */
+		xi2cps_setclk(id->i2c_clk, id);
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+#ifdef CONFIG_PM_SLEEP
+/**
+ * xi2cps_suspend - Suspend method for the driver
+ * @dev:	Address of the platform_device structure
+ * Returns 0 on success and error value on error
+ *
+ * Put the driver into low power mode.
+ */
+static int xi2cps_suspend(struct device *_dev)
+{
+	struct platform_device *pdev = container_of(_dev,
+			struct platform_device, dev);
+	struct xi2cps *xi2c = platform_get_drvdata(pdev);
+
+	clk_disable(xi2c->clk);
+
+	return 0;
+}
+
+/**
+ * xi2cps_resume - Resume from suspend
+ * @dev:	Address of the platform_device structure
+ * Returns 0 on success and error value on error
+ *
+ * Resume operation after suspend.
+ */
+static int xi2cps_resume(struct device *_dev)
+{
+	struct platform_device *pdev = container_of(_dev,
+			struct platform_device, dev);
+	struct xi2cps *xi2c = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = clk_enable(xi2c->clk);
+	if (ret) {
+		dev_err(_dev, "Cannot enable clock.\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops xi2cps_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xi2cps_suspend, xi2cps_resume)
+};
+#define XI2CPS_PM	(&xi2cps_dev_pm_ops)
+
+#else /* ! CONFIG_PM_SLEEP */
+#define XI2CPS_PM	NULL
+#endif /* ! CONFIG_PM_SLEEP */
+
+/************************/
+/* Platform bus binding */
+/************************/
+
+/**
+ * xi2cps_probe - Platform registration call
+ * @pdev:	Handle to the platform device structure
+ *
+ * Returns zero on success, negative error otherwise
+ *
+ * This function does all the memory allocation and registration for the i2c
+ * device. User can modify the address mode to 10 bit address mode using the
+ * ioctl call with option I2C_TENBIT.
+ */
+static int xi2cps_probe(struct platform_device *pdev)
+{
+	struct resource *r_mem = NULL;
+	struct xi2cps *id;
+	int ret = 0;
+	const unsigned int *prop;
+	/*
+	 * Allocate memory for xi2cps structure.
+	 * Initialize the structure to zero and set the platform data.
+	 * Obtain the resource base address from platform data and remap it.
+	 * Get the irq resource from platform data.Initialize the adapter
+	 * structure members and also xi2cps structure.
+	 */
+	id = kzalloc(sizeof(*id), GFP_KERNEL);
+	if (!id) {
+		dev_err(&pdev->dev, "no mem for i2c private data\n");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(pdev, id);
+
+	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r_mem) {
+		dev_err(&pdev->dev, "no mmio resources\n");
+		ret = -ENODEV;
+		goto err_free_mem;
+	}
+
+	id->membase = ioremap(r_mem->start, r_mem->end - r_mem->start + 1);
+	if (id->membase == NULL) {
+		dev_err(&pdev->dev, "Couldn't ioremap memory at 0x%08lx\n",
+			(unsigned long)r_mem->start);
+		ret = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	id->irq = platform_get_irq(pdev, 0);
+	if (id->irq < 0) {
+		dev_err(&pdev->dev, "no IRQ resource:%d\n", id->irq);
+		ret = -ENXIO;
+		goto err_unmap;
+	}
+
+	prop = of_get_property(pdev->dev.of_node, "bus-id", NULL);
+	if (prop) {
+		id->adap.nr = be32_to_cpup(prop);
+	} else {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "couldn't determine bus-id\n");
+		goto err_unmap ;
+	}
+	id->adap.dev.of_node = pdev->dev.of_node;
+	id->adap.algo = (struct i2c_algorithm *) &xi2cps_algo;
+	id->adap.timeout = 0x1F;	/* Default timeout value */
+	id->adap.retries = 3;		/* Default retry value. */
+	id->adap.algo_data = id;
+	id->adap.dev.parent = &pdev->dev;
+	snprintf(id->adap.name, sizeof(id->adap.name),
+		 "XILINX I2C at %08lx", (unsigned long)r_mem->start);
+
+	id->cur_timeout = id->adap.timeout;
+	if (id->irq == 80)
+		id->clk = clk_get_sys("I2C1_APER", NULL);
+	else
+		id->clk = clk_get_sys("I2C0_APER", NULL);
+	if (IS_ERR(id->clk)) {
+		dev_err(&pdev->dev, "Clock not found.\n");
+		ret = PTR_ERR(id->clk);
+		goto err_unmap;
+	}
+	ret = clk_prepare_enable(id->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to enable clock.\n");
+		goto err_clk_put;
+	}
+	id->clk_rate_change_nb.notifier_call = xi2cps_clk_notifier_cb;
+	id->clk_rate_change_nb.next = NULL;
+	if (clk_notifier_register(id->clk, &id->clk_rate_change_nb))
+		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
+	id->input_clk = (unsigned int)clk_get_rate(id->clk);
+
+	prop = of_get_property(pdev->dev.of_node, "i2c-clk", NULL);
+	if (prop) {
+		id->i2c_clk = be32_to_cpup(prop);
+	} else {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "couldn't determine i2c-clk\n");
+		goto err_clk_dis;
+	}
+
+	/*
+	 * Set Master Mode,Normal addressing mode (7 bit address),
+	 * Enable Transmission of Ack in Control Register.
+	 * Set the timeout and I2C clock and request the IRQ(ISR mapped).
+	 * Call to the i2c_add_numbered_adapter registers the adapter.
+	 */
+	xi2cps_writereg(0x0000000E, XI2CPS_CR_OFFSET);
+	xi2cps_writereg(id->adap.timeout, XI2CPS_TIME_OUT_OFFSET);
+
+	ret = xi2cps_setclk(id->i2c_clk, id);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "invalid SCL clock: %dkHz\n", id->i2c_clk);
+		ret = -EINVAL;
+		goto err_clk_dis;
+	}
+
+	if (request_irq(id->irq, xi2cps_isr, 0, DRIVER_NAME, id)) {
+		dev_err(&pdev->dev, "cannot get irq %d\n", id->irq);
+		ret = -EINVAL;
+		goto err_clk_dis;
+	}
+
+	ret = i2c_add_numbered_adapter(&id->adap);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "reg adap failed: %d\n", ret);
+		goto err_free_irq;
+	}
+
+	of_i2c_register_devices(&id->adap);
+
+	dev_info(&pdev->dev, "%d kHz mmio %08lx irq %d\n",
+		 id->i2c_clk/1000, (unsigned long)r_mem->start, id->irq);
+
+	return 0;
+
+err_free_irq:
+	free_irq(id->irq, id);
+err_clk_dis:
+	clk_disable_unprepare(id->clk);
+err_clk_put:
+	clk_put(id->clk);
+err_unmap:
+	iounmap(id->membase);
+err_free_mem:
+	kfree(id);
+	return ret;
+}
+
+/**
+ * xi2cps_remove - Unregister the device after releasing the resources
+ * @pdev:	Handle to the platform device structure
+ *
+ * Returns zero always
+ *
+ * This function frees all the resources allocated to the device.
+ */
+static int xi2cps_remove(struct platform_device *pdev)
+{
+	struct xi2cps *id = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(&id->adap);
+	free_irq(id->irq, id);
+	iounmap(id->membase);
+	clk_notifier_unregister(id->clk, &id->clk_rate_change_nb);
+	clk_disable_unprepare(id->clk);
+	clk_put(id->clk);
+	kfree(id);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id xi2cps_of_match[] = {
+	{ .compatible = "xlnx,ps7-i2c-1.00.a", },
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, xi2cps_of_match);
+
+static struct platform_driver xi2cps_drv = {
+	.driver = {
+		.name  = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = xi2cps_of_match,
+		.pm = XI2CPS_PM,
+	},
+	.probe  = xi2cps_probe,
+	.remove = xi2cps_remove,
+};
+
+module_platform_driver(xi2cps_drv);
+
+MODULE_AUTHOR("Xilinx, Inc.");
+MODULE_DESCRIPTION("Xilinx PS I2C bus driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 640ae6c..efb1603 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -45,6 +45,7 @@ config USB_ARCH_HAS_EHCI
 	default y if PLAT_S5P
 	default y if ARCH_MSM
 	default y if MICROBLAZE
+	default y if ARCH_ZYNQ
 	default y if SPARC_LEON
 	default y if ARCH_MMP
 	default y if MACH_LOONGSON1
diff --git a/drivers/usb/c67x00/c67x00-drv.c b/drivers/usb/c67x00/c67x00-drv.c
index fe815ec..84c26ba 100644
--- a/drivers/usb/c67x00/c67x00-drv.c
+++ b/drivers/usb/c67x00/c67x00-drv.c
@@ -42,6 +42,12 @@
 #include <linux/usb.h>
 #include <linux/usb/c67x00.h>
 
+#if defined(CONFIG_OF)
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#endif
+
 #include "c67x00.h"
 #include "c67x00-hcd.h"
 
@@ -132,12 +138,36 @@ static int c67x00_drv_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	pdata = pdev->dev.platform_data;
-	if (!pdata)
+	if (!pdata) {
+#ifdef CONFIG_OF
+		if (!pdev->dev.of_node)
+			return -ENODEV;
+		pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+		unsigned int *p = 0;
+		p = (unsigned int *)of_get_property(pdev->dev.of_node, "hpi-regstep", NULL);
+		if (!p) {
+			ret = -ENODEV;
+			goto free_pdata_of;
+		}
+		pdata->hpi_regstep = be32_to_cpup(p);
+		p = (unsigned int *)of_get_property(pdev->dev.of_node, "sie-config", NULL);
+		if (!p) {
+			ret = -ENODEV;
+			goto free_pdata_of;
+		}
+		pdata->sie_config = be32_to_cpup(p);
+#else
 		return -ENODEV;
+#endif
+	}
 
 	c67x00 = kzalloc(sizeof(*c67x00), GFP_KERNEL);
-	if (!c67x00)
-		return -ENOMEM;
+	if (!c67x00) {
+		ret = -ENOMEM;
+		goto free_pdata_of;
+	}
 
 	if (!request_mem_region(res->start, resource_size(res),
 				pdev->name)) {
@@ -154,7 +184,7 @@ static int c67x00_drv_probe(struct platform_device *pdev)
 
 	spin_lock_init(&c67x00->hpi.lock);
 	c67x00->hpi.regstep = pdata->hpi_regstep;
-	c67x00->pdata = pdev->dev.platform_data;
+	c67x00->pdata = pdata;
 	c67x00->pdev = pdev;
 
 	c67x00_ll_init(c67x00);
@@ -187,6 +217,10 @@ static int c67x00_drv_probe(struct platform_device *pdev)
 	release_mem_region(res->start, resource_size(res));
  request_mem_failed:
 	kfree(c67x00);
+ free_pdata_of:
+	/* kfree platform data for CONFIG_OF */
+	if (!pdev->dev.platform_data)
+		kfree(pdata);
 
 	return ret;
 }
@@ -212,17 +246,28 @@ static int c67x00_drv_remove(struct platform_device *pdev)
 	if (res)
 		release_mem_region(res->start, resource_size(res));
 
+	/* kfree platform data for CONFIG_OF */
+	if (!c67x00->pdev->dev.platform_data)
+		kfree(c67x00->pdata);
 	kfree(c67x00);
 
 	return 0;
 }
 
+/* Match table for OF platform binding - from xilinx_emaclite */
+static struct of_device_id c67x00_of_match[] = {
+	{ .compatible = "cypress,c67x00", },
+	{ /* end of list */ },
+};
+
+
 static struct platform_driver c67x00_driver = {
 	.probe	= c67x00_drv_probe,
 	.remove	= c67x00_drv_remove,
 	.driver	= {
 		.owner = THIS_MODULE,
 		.name = "c67x00",
+		.of_match_table = c67x00_of_match,
 	},
 };
 
diff --git a/drivers/usb/c67x00/c67x00-hcd.h b/drivers/usb/c67x00/c67x00-hcd.h
index e3d493d..8bc3517 100644
--- a/drivers/usb/c67x00/c67x00-hcd.h
+++ b/drivers/usb/c67x00/c67x00-hcd.h
@@ -52,7 +52,9 @@
  */
 
 #define TOTAL_FRAME_BW		12000
-#define DEFAULT_EOT		2250
+#define DEFAULT_EOT		9600 /* This value fits MicroBlaze system.
+					it may requires a bigger value for
+					some USB device. */
 
 #define MAX_FRAME_BW_STD	(TOTAL_FRAME_BW - DEFAULT_EOT)
 #define MAX_FRAME_BW_ISO	2400
diff --git a/drivers/usb/c67x00/c67x00-sched.c b/drivers/usb/c67x00/c67x00-sched.c
index a03fbc1..7a4a44c 100644
--- a/drivers/usb/c67x00/c67x00-sched.c
+++ b/drivers/usb/c67x00/c67x00-sched.c
@@ -100,7 +100,7 @@ struct c67x00_urb_priv {
 #define TD_PIDEP_OFFSET		0x04
 #define TD_PIDEPMASK_PID	0xF0
 #define TD_PIDEPMASK_EP		0x0F
-#define TD_PORTLENMASK_DL	0x02FF
+#define TD_PORTLENMASK_DL	0x03FF
 #define TD_PORTLENMASK_PN	0xC000
 
 #define TD_STATUS_OFFSET	0x07
@@ -590,7 +590,7 @@ static int c67x00_create_td(struct c67x00_hcd *c67x00, struct urb *urb,
 {
 	struct c67x00_td *td;
 	struct c67x00_urb_priv *urbp = urb->hcpriv;
-	const __u8 active_flag = 1, retry_cnt = 1;
+	const __u8 active_flag = 1, retry_cnt = 3;
 	__u8 cmd = 0;
 	int tt = 0;
 
@@ -1033,6 +1033,15 @@ static inline void c67x00_check_td_list(struct c67x00_hcd *c67x00)
 		    !td_acked(td))
 			goto cont;
 
+		/*
+		 * at this point, there are no errors, but it's still possible
+		 * that the td wasn't executed by the c67x00. Confirm it was
+		 * executed or force a retry
+		 */
+		if ((td->retry_cnt & TD_RETRYCNTMASK_ACT_FLG) &&
+		    td->status == 0)
+			goto cont;
+
 		/* Sequence ok and acked, don't need to fix toggle */
 		ack_ok = 1;
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index cbf7168..4e69067 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1708,7 +1708,11 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	pm_runtime_set_autosuspend_delay(&hdev->dev, 0);
 
 	/* Hubs have proper suspend/resume support. */
+#ifdef CONFIG_USB_XUSBPS_OTG
+	usb_disable_autosuspend(hdev);
+#else
 	usb_enable_autosuspend(hdev);
+#endif
 
 	if (hdev->level == MAX_TOPO_LEVEL) {
 		dev_err(&intf->dev,
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 14625fd..46b9aee 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -185,6 +185,37 @@ config USB_FSL_USB2
 	   dynamically linked module called "fsl_usb2_udc" and force
 	   all gadget drivers to also be dynamically linked.
 
+config USB_GADGET_XUSBPS
+	tristate "Xilinx PS Highspeed USB DR Peripheral Controller"
+	depends on ARCH_ZYNQ
+	select USB_GADGET_DUALSPEED
+	select USB_XUSBPS_DR_OF if OF
+	help
+	   Xilinx PS USB controller core supports device mode.
+
+	   Say "y" to link the driver statically, or "m" to build a
+	   dynamically linked module called "xilinx_usbps_udc" and
+	   force all gadget drivers to also be dynamically linked.
+
+config XUSBPS_ERRATA_DT654401
+	bool "USB Errata: Adding a dTD to a Primed Endpoint May Not Get Recognized"
+	depends on USB_GADGET_XUSBPS
+	---help---
+	  There is an issue with the add dTD tripwire semaphore (ATDTW bit
+	  in USBCMD register) that can cause the controller to ignore a dTD
+	  that is added to a primed endpoint. When this happens, the software
+	  can read the tripwire bit and the status bit at '1' even though
+	  the endpoint is unprimed.
+
+	  This issue is only applicable for the Zynq silicon revisions < 3.0.
+	  For silicon versions 3.0 and higher, disable this option.
+
+config USB_XUSBPS
+	tristate
+	depends on USB_GADGET_XUSBPS
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
 config USB_FUSB300
 	tristate "Faraday FUSB300 USB Peripheral Controller"
 	depends on !PHYS_ADDR_T_64BIT
@@ -244,6 +275,20 @@ config USB_R8A66597
 	   dynamically linked module called "r8a66597_udc" and force all
 	   gadget drivers to also be dynamically linked.
 
+config USB_GADGET_XILINX
+	boolean "Xilinx USB Driver"
+	depends on (XILINX_VIRTEX || MICROBLAZE || ARCH_ZYNQ)
+	select USB_GADGET_DUALSPEED
+	help
+	   Sample USB gadget driver
+
+config USB_GADGET_CORE_XILINX
+	tristate
+	depends on USB_GADGET_XILINX
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+	select XILINX_EDK
+
 config USB_RENESAS_USBHS_UDC
 	tristate 'Renesas USBHS controller'
 	depends on USB_RENESAS_USBHS
@@ -593,7 +638,7 @@ config USB_ETH
 	help
 	  This driver implements Ethernet style communication, in one of
 	  several ways:
-	  
+
 	   - The "Communication Device Class" (CDC) Ethernet Control Model.
 	     That protocol is often avoided with pure Ethernet adapters, in
 	     favor of simpler vendor-specific hardware, but is widely
@@ -634,7 +679,7 @@ config USB_ETH_RNDIS
 	   If you say "y" here, the Ethernet gadget driver will try to provide
 	   a second device configuration, supporting RNDIS to talk to such
 	   Microsoft USB hosts.
-	   
+
 	   To make MS-Windows work with this, use Documentation/usb/linux.inf
 	   as the "driver info file".  For versions of MS-Windows older than
 	   XP, you'll need to download drivers from Microsoft's website; a URL
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 8b4acfd..30104a8 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -28,10 +28,12 @@ obj-$(CONFIG_USB_R8A66597)	+= r8a66597-udc.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_S3C_HSUDC)	+= s3c-hsudc.o
+obj-$(CONFIG_USB_GADGET_XILINX)	+= xilinx_udc.o
 obj-$(CONFIG_USB_LPC32XX)	+= lpc32xx_udc.o
 obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
 obj-$(CONFIG_USB_MV_UDC)	+= mv_udc.o
 mv_udc-y			:= mv_udc_core.o
+obj-$(CONFIG_USB_XUSBPS)	+= xilinx_usbps_udc.o
 obj-$(CONFIG_USB_FUSB300)	+= fusb300_udc.o
 obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
 
diff --git a/drivers/usb/gadget/xilinx_udc.c b/drivers/usb/gadget/xilinx_udc.c
new file mode 100644
index 0000000..27b9725
--- /dev/null
+++ b/drivers/usb/gadget/xilinx_udc.c
@@ -0,0 +1,2379 @@
+/*
+ * Xilinx USB peripheral controller driver
+ *
+ * (c) 2010 Xilinx, Inc.
+ *
+ * Copyright (C) 2004 by Thomas Rathbone
+ * Copyright (C) 2005 by HP Labs
+ * Copyright (C) 2005 by David Brownell
+ *
+ * Some parts of this driver code is based on the driver for at91-series
+ * USB peripheral controller (at91_udc.c).
+ *
+ * This program is free software; you can redistribute it
+ * and/or modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation;
+ * either version 2 of the License, or (at your option) any
+ * later version.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
+ * 02139, USA.
+ */
+/***************************** Include Files *********************************/
+
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/prefetch.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_irq.h>
+#include <linux/dma-mapping.h>
+#include "gadget_chips.h"
+
+
+ /* Match table for of_platform binding */
+static const struct of_device_id usb_of_match[] = {
+	{.compatible = "xlnx,xps-usb2-device-4.00.a",},
+	{ /* end of list */ },
+};
+
+MODULE_DEVICE_TABLE(of, usb_of_match);
+
+/****************************************************************************
+DEBUG utilities
+*****************************************************************************/
+#define  DEBUG
+#define  VERBOSE_DEBUG
+
+/****************************************************************************
+Hardware USB controller register map related constants
+****************************************************************************/
+/* Register offsets for the USB device.*/
+#define XUSB_EP0_CONFIG_OFFSET		0x0000  /* EP0 Config Reg Offset */
+#define XUSB_SETUP_PKT_ADDR_OFFSET	0x0080  /* Setup Packet Address */
+#define XUSB_ADDRESS_OFFSET		0x0100  /* Address Register */
+#define XUSB_CONTROL_OFFSET		0x0104  /* Control Register */
+#define XUSB_STATUS_OFFSET		0x0108  /* Status Register */
+#define XUSB_FRAMENUM_OFFSET		0x010C	/* Frame Number Register */
+#define XUSB_IER_OFFSET			0x0110	/* Interrupt Enable Register */
+#define XUSB_BUFFREADY_OFFSET		0x0114	/* Buffer Ready Register */
+#define XUSB_TESTMODE_OFFSET		0x0118	/* Test Mode Register */
+#define XUSB_DMA_RESET_OFFSET		0x0200  /* DMA Soft Reset Register */
+#define XUSB_DMA_CONTROL_OFFSET		0x0204	/* DMA Control Register */
+#define XUSB_DMA_DSAR_ADDR_OFFSET	0x0208	/* DMA source Address Reg */
+#define XUSB_DMA_DDAR_ADDR_OFFSET	0x020C	/* DMA destination Addr Reg */
+#define XUSB_DMA_LENGTH_OFFSET		0x0210	/* DMA Length Register */
+#define XUSB_DMA_STATUS_OFFSET		0x0214	/* DMA Status Register */
+
+/* Endpoint Configuration Space offsets */
+#define XUSB_EP_CFGSTATUS_OFFSET	0x00	/* Endpoint Config Status  */
+#define XUSB_EP_BUF0COUNT_OFFSET	0x08	/* Buffer 0 Count */
+#define XUSB_EP_BUF1COUNT_OFFSET	0x0C	/* Buffer 1 Count */
+
+
+#define XUSB_CONTROL_USB_READY_MASK	0x80000000 /* USB ready Mask */
+
+/* Interrupt register related masks.*/
+#define XUSB_STATUS_GLOBAL_INTR_MASK	0x80000000 /* Global Intr Enable */
+#define XUSB_STATUS_RESET_MASK		0x00800000 /* USB Reset Mask */
+#define XUSB_STATUS_SUSPEND_MASK	0x00400000 /* USB Suspend Mask */
+#define XUSB_STATUS_DISCONNECT_MASK	0x00200000 /* USB Disconnect Mask */
+#define XUSB_STATUS_FIFO_BUFF_RDY_MASK	0x00100000 /* FIFO Buff Ready Mask */
+#define XUSB_STATUS_FIFO_BUFF_FREE_MASK	0x00080000 /* FIFO Buff Free Mask */
+#define XUSB_STATUS_SETUP_PACKET_MASK	0x00040000 /* Setup packet received */
+#define XUSB_STATUS_EP1_BUFF2_COMP_MASK	0x00000200 /* EP 1 Buff 2 Processed */
+#define XUSB_STATUS_EP1_BUFF1_COMP_MASK	0x00000002 /* EP 1 Buff 1 Processed */
+#define XUSB_STATUS_EP0_BUFF2_COMP_MASK	0x00000100 /* EP 0 Buff 2 Processed */
+#define XUSB_STATUS_EP0_BUFF1_COMP_MASK	0x00000001 /* EP 0 Buff 1 Processed */
+#define XUSB_STATUS_HIGH_SPEED_MASK	0x00010000 /* USB Speed Mask */
+/* Suspend,Reset and Disconnect Mask */
+#define XUSB_STATUS_INTR_EVENT_MASK	0x00E00000
+/* Buffers  completion Mask */
+#define XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK	0x0000FEFF
+/* Mask for buffer 0 and buffer 1 completion for all Endpoints */
+#define XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK	0x00000101
+#define XUSB_STATUS_EP_BUFF2_SHIFT	8	   /* EP buffer offset */
+
+/* Endpoint Configuration Status Register */
+#define XUSB_EP_CFG_VALID_MASK		0x80000000 /* Endpoint Valid bit */
+#define XUSB_EP_CFG_STALL_MASK		0x40000000 /* Endpoint Stall bit */
+#define XUSB_EP_CFG_DATA_TOGGLE_MASK	0x08000000 /* Endpoint Data toggle */
+
+/* USB device specific global configuration constants.*/
+#define XUSB_MAX_ENDPOINTS		8	/* Maximum End Points */
+#define XUSB_EP_NUMBER_ZERO		0	/* End point Zero */
+
+/* Test Modes (Set Feature).*/
+#define TEST_J				1	/* Chirp J Test */
+#define TEST_K				2	/* Chirp K Test */
+#define TEST_SE0_NAK			3	/* Chirp SE0 Test */
+#define TEST_PKT			4	/* Packet Test */
+
+#define CONFIGURATION_ONE		0x01	/* USB device configuration*/
+#define STANDARD_OUT_DEVICE		0x00	/* Out device */
+#define STANDARD_OUT_ENDPOINT		0x02	/* Standard Out end point */
+
+#define XUSB_DMA_READ_FROM_DPRAM	0x80000000/**< DPRAM is the source
+							address for DMA transfer
+							*/
+#define XUSB_DMA_DMASR_BUSY		0x80000000 /**< DMA busy*/
+#define XUSB_DMA_DMASR_ERROR		0x40000000 /**< DMA Error */
+
+/*
+ * When this bit is set, the DMA buffer ready bit is set by hardware upon
+ * DMA transfer completion.
+ */
+#define XUSB_DMA_BRR_CTRL		0x40000000 /**< DMA bufready ctrl bit */
+
+/* Phase States */
+#define SETUP_PHASE			0x0000	/* Setup Phase */
+#define DATA_PHASE			0x0001  /* Data Phase */
+#define STATUS_PHASE			0x0002  /* Status Phase */
+
+#define EP_TRANSMIT		0	/* EP is IN endpoint */
+#define DRIVER_VERSION  "10 October 2010" /* Driver version date */
+
+/*****************************************************************************
+	Structures and variable declarations.
+*****************************************************************************/
+/**
+ * USB end point structure.
+ *@ep usb endpoint instance
+ *@queue endpoint message queue
+ *@udc xilinx usb peripheral driver instance pointer
+ *@epnumber endpoint number
+ *@is_in endpoint direction (IN or OUT)
+ *@stopped endpoint active status
+ *@is_iso endpoint type(isochronous or non isochronous)
+ *@maxpacket maximum packet size the endpoint can store
+ *@rambase the endpoint buffer address
+ *@buffer0count the size of the packet recieved in the first buffer
+ *@buffer0ready the busy state of first buffer
+ *@buffer1count the size of the packet received in the second buffer
+ *@buffer1ready the busy state of second buffer
+ *@eptype endpoint transfer type (BULK, INTERRUPT)
+ *@curbufnum current buffer of endpoint that will be processed next
+ *@endpointoffset the endpoint register offset value
+ *@desc pointer to the usb endpoint descriptor
+ **/
+struct xusb_ep {
+	struct usb_ep ep;
+	struct list_head queue;
+	struct xusb_udc *udc;
+	u16 epnumber;
+	u8 is_in;
+	u8 stopped;
+	u8 is_iso;
+	u16 maxpacket;
+	u32 rambase;
+	u16 buffer0count;
+	u8 buffer0ready;
+	u16 buffer1count;
+	u8 buffer1ready;
+	u8 eptype;
+	u8 curbufnum;
+	u32 endpointoffset;
+	const struct usb_endpoint_descriptor *desc;
+};
+
+/**
+ * USB peripheral driver structure
+ *@gadget USB gadget driver instance
+ *@lock instance of spinlock
+ *@ep an array of endpoint structures
+ *@base_address the usb device base address
+ *@driver pointer to the usb gadget driver instance
+ *@dma_enabled flag indicating whether the dma is included in the system
+ *@status status flag indicating the device cofiguration
+ **/
+struct xusb_udc {
+	struct usb_gadget gadget;
+	spinlock_t lock;
+	struct xusb_ep ep[8];
+	void __iomem *base_address;
+	struct usb_gadget_driver *driver;
+	u8 dma_enabled;
+	u8 status;
+	unsigned int (*read_fn) (void __iomem *);
+	void (*write_fn) (u32, void __iomem *);
+};
+static struct xusb_udc controller;
+/**
+ * Xilinx USB device request structure
+ *@req Linux usb request structure
+ *@queue usb device request queue
+ **/
+struct xusb_request {
+	struct usb_request req;
+	struct list_head queue;
+};
+
+/*
+ * Standard USB Command Buffer Structure defined
+ * as unions so that the parameters can be used in the request processing.
+ */
+static struct {
+	struct usb_ctrlrequest setup;
+	u8 *contreadptr;
+	u8 *contwriteptr;
+	u32 contreadcount;
+	u32 contwritecount;
+	u32 setupseqtx;
+	u32 setupseqrx;
+	u8 contreaddatabuffer[64];
+} ch9_cmdbuf;
+
+/*
+ * Initial Fixed locations provided for endpoint memory address
+ * in the USB core. The user needs to modify this as per his application.
+ */
+static u32 rambase[8] = { 0x22, 0x1000, 0x1100, 0x1200, 0x1300, 0x1400, 0x1500,
+			0x1600 };
+
+static const char driver_name[] = "xilinx_udc";
+static const char ep0name[] = "ep0";
+
+/* Control endpoint configuration.*/
+static struct usb_endpoint_descriptor config_bulk_out_desc = {
+	.bLength = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType = USB_DT_ENDPOINT,
+	.bEndpointAddress = USB_DIR_OUT,
+	.bmAttributes = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize = __constant_cpu_to_le16(0x40),
+};
+/**
+ *to_udc() - returns the udc instance pointer
+ *@g pointer to the usb gadget driver instance
+ **/
+static inline struct xusb_udc *to_udc(struct usb_gadget *g)
+{
+
+	return container_of(g, struct xusb_udc, gadget);
+}
+
+static void xusb_write32(u32 val, void __iomem *addr)
+{
+	iowrite32(val, addr);
+}
+
+static unsigned int xusb_read32(void __iomem *addr)
+{
+	return ioread32(addr);
+}
+
+static void xusb_write32_be(u32 val, void __iomem *addr)
+{
+	iowrite32be(val, addr);
+}
+
+static unsigned int xusb_read32_be(void __iomem *addr)
+{
+	return ioread32be(addr);
+}
+
+/**
+ * ep_configure() - Configures the given endpoint.
+ * @ep:		Pointer to the usb device endpoint structure.
+ * @udc:	Pointer to the usb peripheral controller structure.
+ *
+ * This function configures a specific endpoint with the given configuration
+ * data.
+ *
+ **/
+static void ep_configure(struct xusb_ep *ep, struct xusb_udc *udc)
+{
+
+	u32 epcfgreg = 0;
+
+	/*
+	 * Configure the end point direction, type, Max Packet Size and the
+	 * EP buffer location.
+	 */
+	epcfgreg = ((ep->is_in << 29) | (ep->eptype << 28) |
+			(ep->ep.maxpacket << 15) | (ep->rambase));
+	udc->write_fn(epcfgreg, (udc->base_address + ep->endpointoffset));
+
+	/* Set the Buffer count and the Buffer ready bits.*/
+	udc->write_fn(ep->buffer0count,
+			(udc->base_address + ep->endpointoffset +
+			XUSB_EP_BUF0COUNT_OFFSET));
+	udc->write_fn(ep->buffer1count,
+			(udc->base_address + ep->endpointoffset +
+			XUSB_EP_BUF1COUNT_OFFSET));
+	if (ep->buffer0ready == 1)
+		udc->write_fn(1 << ep->epnumber,
+			(udc->base_address + XUSB_BUFFREADY_OFFSET));
+	if (ep->buffer1ready == 1)
+		udc->write_fn(1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT),
+			(udc->base_address + XUSB_BUFFREADY_OFFSET));
+}
+
+/**
+ * ep_sendrecv() - Transmits or receives data to or from an endpoint.
+ * @ep:		Pointer to the usb endpoint configuration structure.
+ * @bufferptr:	Pointer to buffer containing the data to be sent.
+ * @bufferlen:	The number of data bytes to be sent.
+ * @direction:	The direction of data transfer (transmit or receive).
+ *
+ * This function copies the transmit/receive data to/from the end point buffer
+ * and enables the buffer for transmission/reception.
+ *
+ * returns: 0 on success and 1 on failure
+ *
+ **/
+static int ep_sendrecv(struct xusb_ep *ep, u8 *bufferptr, u32 bufferlen,
+			u8 direction)
+{
+	u32 *eprambase;
+	u32 bytestosend;
+	u8 *temprambase;
+	unsigned long timeout;
+	u32 srcaddr = 0;
+	u32 dstaddr = 0;
+	int rc = 0;
+	struct xusb_udc *udc = &controller;
+
+	bytestosend = bufferlen;
+
+	/* Put the transmit buffer into the correct ping-pong buffer.*/
+	if ((!(ep->curbufnum)) && (!(ep->buffer0ready))) {
+		/* Get the Buffer address and copy the transmit data.*/
+		eprambase = (u32 __force *)(ep->udc->base_address +
+				ep->rambase);
+
+		if (ep->udc->dma_enabled) {
+			if (direction == EP_TRANSMIT) {
+				srcaddr = dma_map_single(
+					ep->udc->gadget.dev.parent,
+					bufferptr, bufferlen, DMA_TO_DEVICE);
+				dstaddr = virt_to_phys(eprambase);
+				udc->write_fn(bufferlen,
+						(ep->udc->base_address +
+						ep->endpointoffset +
+						XUSB_EP_BUF0COUNT_OFFSET));
+				udc->write_fn(XUSB_DMA_BRR_CTRL |
+						(1 << (ep->epnumber)),
+						(ep->udc->base_address +
+						XUSB_DMA_CONTROL_OFFSET));
+			} else {
+				srcaddr = virt_to_phys(eprambase);
+				dstaddr = dma_map_single(
+					ep->udc->gadget.dev.parent,
+					bufferptr, bufferlen, DMA_FROM_DEVICE);
+				udc->write_fn(XUSB_DMA_BRR_CTRL |
+					XUSB_DMA_READ_FROM_DPRAM |
+					(1 << (ep->epnumber)),
+					(ep->udc->base_address +
+					XUSB_DMA_CONTROL_OFFSET));
+			}
+			/*
+			 * Set the addresses in the DMA source and destination
+			 * registers and then set the length into the DMA length
+			 * register.
+			 */
+			udc->write_fn(srcaddr, (ep->udc->base_address +
+				XUSB_DMA_DSAR_ADDR_OFFSET));
+			udc->write_fn(dstaddr, (ep->udc->base_address +
+				XUSB_DMA_DDAR_ADDR_OFFSET));
+			udc->write_fn(bufferlen, (ep->udc->base_address +
+					XUSB_DMA_LENGTH_OFFSET));
+		} else {
+
+			while (bytestosend > 3) {
+				if (direction == EP_TRANSMIT)
+					*eprambase++ = *(u32 *) bufferptr;
+				else
+					*(u32 *) bufferptr = *eprambase++;
+				bufferptr += 4;
+				bytestosend -= 4;
+			}
+			temprambase = (u8 *) eprambase;
+			while (bytestosend--) {
+				if (direction == EP_TRANSMIT)
+					*temprambase++ = *bufferptr++;
+				else
+					*bufferptr++ = *temprambase++;
+			}
+			/*
+			 * Set the Buffer count register with transmit length
+			 * and enable the buffer for transmission.
+			 */
+			if (direction == EP_TRANSMIT)
+				udc->write_fn(bufferlen,
+					(ep->udc->base_address +
+					ep->endpointoffset +
+					XUSB_EP_BUF0COUNT_OFFSET));
+			udc->write_fn(1 << ep->epnumber,
+					(ep->udc->base_address +
+					XUSB_BUFFREADY_OFFSET));
+		}
+		ep->buffer0ready = 1;
+		ep->curbufnum = 1;
+
+	} else
+		if ((ep->curbufnum == 1) && (!(ep->buffer1ready))) {
+
+			/* Get the Buffer address and copy the transmit data.*/
+			eprambase = (u32 __force *)(ep->udc->base_address +
+					ep->rambase + ep->ep.maxpacket);
+			if (ep->udc->dma_enabled) {
+				if (direction == EP_TRANSMIT) {
+					srcaddr = dma_map_single(
+						ep->udc->gadget.dev.parent,
+						bufferptr, bufferlen,
+						DMA_TO_DEVICE);
+					dstaddr = virt_to_phys(eprambase);
+					udc->write_fn(bufferlen,
+						(ep->udc->base_address +
+						ep->endpointoffset +
+						XUSB_EP_BUF1COUNT_OFFSET));
+					udc->write_fn(XUSB_DMA_BRR_CTRL |
+						(1 << (ep->epnumber +
+						XUSB_STATUS_EP_BUFF2_SHIFT)),
+						(ep->udc->base_address +
+						XUSB_DMA_CONTROL_OFFSET));
+				} else {
+					srcaddr = virt_to_phys(eprambase);
+					dstaddr = dma_map_single(
+						ep->udc->gadget.dev.parent,
+						bufferptr, bufferlen,
+						DMA_FROM_DEVICE);
+				udc->write_fn(XUSB_DMA_BRR_CTRL |
+						XUSB_DMA_READ_FROM_DPRAM |
+						(1 << (ep->epnumber +
+						XUSB_STATUS_EP_BUFF2_SHIFT)),
+						(ep->udc->base_address +
+						XUSB_DMA_CONTROL_OFFSET));
+				}
+				/*
+				 * Set the addresses in the DMA source and
+				 * destination registers and then set the length
+				 * into the DMA length register.
+				 */
+				udc->write_fn(srcaddr,
+					(ep->udc->base_address +
+					XUSB_DMA_DSAR_ADDR_OFFSET));
+				udc->write_fn(dstaddr,
+					(ep->udc->base_address +
+					XUSB_DMA_DDAR_ADDR_OFFSET));
+				udc->write_fn(bufferlen,
+					(ep->udc->base_address +
+					XUSB_DMA_LENGTH_OFFSET));
+			} else {
+				while (bytestosend > 3) {
+					if (direction == EP_TRANSMIT)
+						*eprambase++ =
+							*(u32 *) bufferptr;
+					else
+						*(u32 *) bufferptr =
+							*eprambase++;
+					bufferptr += 4;
+					bytestosend -= 4;
+				}
+				temprambase = (u8 *) eprambase;
+				while (bytestosend--) {
+					if (direction == EP_TRANSMIT)
+						*temprambase++ = *bufferptr++;
+					else
+						*bufferptr++ = *temprambase++;
+				}
+				/*
+				 * Set the Buffer count register with transmit
+				 * length and enable the buffer for
+				 * transmission.
+				 */
+				if (direction == EP_TRANSMIT)
+					udc->write_fn(bufferlen,
+						(ep->udc->base_address +
+						ep->endpointoffset +
+						XUSB_EP_BUF1COUNT_OFFSET));
+				udc->write_fn(1 << (ep->epnumber +
+						XUSB_STATUS_EP_BUFF2_SHIFT),
+						(ep->udc->base_address +
+						XUSB_BUFFREADY_OFFSET));
+			}
+			ep->buffer1ready = 1;
+			ep->curbufnum = 0;
+		} else
+			/*
+			 * None of the ping-pong buffer is free. Return a
+			 * failure.
+			 */
+			return 1;
+
+	if (ep->udc->dma_enabled) {
+		/*
+		 * Wait till DMA transaction is complete and
+		 * check whether the DMA transaction was
+		 * successful.
+		 */
+		while ((udc->read_fn(ep->udc->base_address +
+			XUSB_DMA_STATUS_OFFSET) & XUSB_DMA_DMASR_BUSY) ==
+			XUSB_DMA_DMASR_BUSY) {
+			timeout = jiffies + 10000;
+
+			if (time_after(jiffies, timeout)) {
+				rc = -ETIMEDOUT;
+				goto clean;
+			}
+
+		}
+		if ((udc->read_fn(ep->udc->base_address +
+			XUSB_DMA_STATUS_OFFSET) & XUSB_DMA_DMASR_ERROR) ==
+			XUSB_DMA_DMASR_ERROR)
+			dev_dbg(&ep->udc->gadget.dev, "DMA Error\n");
+clean:
+		if (direction == EP_TRANSMIT) {
+
+			dma_unmap_single(ep->udc->gadget.dev.parent,
+				srcaddr, bufferlen, DMA_TO_DEVICE);
+		} else {
+
+			dma_unmap_single(ep->udc->gadget.dev.parent,
+				dstaddr, bufferlen, DMA_FROM_DEVICE);
+		}
+
+	}
+	return rc;
+}
+
+/**
+ * done() -	Exeutes the endpoint data transfer completion tasks.
+ * @ep:		Pointer to the usb device endpoint structure.
+ * @req:	Pointer to the usb request structure.
+ * @status:	Status of the data transfer.
+ *
+ * Deletes the message from the queue and updates data transfer completion
+ * status.
+ *
+ **/
+static void done(struct xusb_ep *ep, struct xusb_request *req, int status)
+{
+	u8 stopped = ep->stopped;
+
+	list_del_init(&req->queue);
+
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && status != -ESHUTDOWN)
+		dev_dbg(&ep->udc->gadget.dev, "%s done %p, status %d\n",
+				ep->ep.name, req, status);
+	ep->stopped = 1;
+
+	spin_unlock(&ep->udc->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->udc->lock);
+
+	ep->stopped = stopped;
+}
+
+/**
+ * read_fifo() - Reads the data from the given endpoint buffer.
+ * @ep:		Pointer to the usb device endpoint structure.
+ * @req:	Pointer to the usb request structure.
+ *
+ * Pulls OUT packet data from the endpoint buffer.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int read_fifo(struct xusb_ep *ep, struct xusb_request *req)
+{
+	u8 *buf;
+	u32 is_short, count, bufferspace;
+	u8 bufoffset;
+	u8 two_pkts = 0;
+	struct xusb_udc *udc = &controller;
+
+	if ((ep->buffer0ready == 1) && (ep->buffer1ready == 1)) {
+		dev_dbg(&ep->udc->gadget.dev, "%s: Packet NOT ready!\n",
+				__func__);
+		return -EINVAL;
+	}
+top:
+	if (ep->curbufnum)
+		bufoffset = 0xC;
+	else
+		bufoffset = 0x08;
+		count = udc->read_fn(ep->udc->base_address +
+				ep->endpointoffset + bufoffset);
+	if (!ep->buffer0ready && !ep->buffer1ready)
+		two_pkts = 1;
+
+	dev_dbg(&ep->udc->gadget.dev,
+		"curbufnum is %d  and buf0rdy is %d, buf1rdy is %d\n",
+		ep->curbufnum, ep->buffer0ready, ep->buffer1ready);
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	req->req.actual += min(count, bufferspace);
+	is_short = (count < ep->ep.maxpacket);
+
+	if (count) {
+		if (unlikely(!bufferspace)) {
+			/* This happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				dev_dbg(&ep->udc->gadget.dev,
+					"%s overflow %d\n", ep->ep.name, count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			if (!ep_sendrecv(ep, buf, count, 1)) {
+				dev_dbg(&ep->udc->gadget.dev,
+					"read %s, %d bytes%s req %p %d/%d\n",
+					ep->ep.name, count,
+					is_short ? "/S" : "", req,
+					req->req.actual, req->req.length);
+				bufferspace -= count;
+				/* Completion */
+				if (is_short ||
+				    req->req.actual == req->req.length) {
+					done(ep, req, 0);
+					return 1;
+				}
+
+				if (two_pkts) {
+					two_pkts = 0;
+					goto top;
+				}
+
+			} else {
+				dev_dbg(&ep->udc->gadget.dev,
+				"rcv fail..curbufnum is %d and buf0rdy is"
+				"%d, buf1rdy is %d\n", ep->curbufnum,
+				ep->buffer0ready, ep->buffer1ready);
+				req->req.actual -= min(count, bufferspace);
+				return -EINVAL;
+			}
+		}
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+/**
+ * write_fifo() - Writes data into the given endpoint buffer.
+ * @ep:		Pointer to the usb device endpoint structure.
+ * @req:	Pointer to the usb request structure.
+ *
+ * Loads endpoint buffer for an IN packet.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int write_fifo(struct xusb_ep *ep, struct xusb_request *req)
+{
+	u8 *buf;
+	u32 max;
+	u32 length;
+	int is_last, is_short = 0;
+
+	max = le16_to_cpu(ep->desc->wMaxPacketSize);
+
+	if (req) {
+		buf = req->req.buf + req->req.actual;
+		prefetch(buf);
+		length = req->req.length - req->req.actual;
+	} else {
+		buf = NULL;
+		length = 0;
+	}
+
+	length = min(length, max);
+	if (ep_sendrecv(ep, buf, length, EP_TRANSMIT) == 1) {
+		buf = req->req.buf - req->req.actual;
+		dev_dbg(&ep->udc->gadget.dev, "Send failure\n");
+		return 0;
+	} else {
+		req->req.actual += length;
+
+		if (unlikely(length != max))
+			is_last = is_short = 1;
+		else {
+			if (likely(req->req.length != req->req.actual)
+			    || req->req.zero)
+				is_last = 0;
+			else
+				is_last = 1;
+		}
+		dev_dbg(&ep->udc->gadget.dev,
+			"%s: wrote %s %d bytes%s%s %d left %p\n", __func__,
+			ep->ep.name, length,
+			is_last ? "/L" : "", is_short ? "/S" : "",
+			req->req.length - req->req.actual, req);
+
+		if (is_last) {
+			done(ep, req, 0);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/**
+ * nuke() -	Cleans up the data transfer message list.
+ * @ep:		Pointer to the usb device endpoint structure.
+ * @status:	Status of the data transfer.
+ *
+ **/
+static void nuke(struct xusb_ep *ep, int status)
+{
+	struct xusb_request *req;
+
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct xusb_request, queue);
+
+		done(ep, req, status);
+	}
+}
+
+/***************************** Endpoint related functions*********************/
+/**
+ * xusb_ep_set_halt() -	Stalls/unstalls the given endpoint.
+ * @_ep:	Pointer to the usb device endpoint structure.
+ * @value:	value to indicate stall/unstall.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int xusb_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct xusb_ep *ep = container_of(_ep, struct xusb_ep, ep);
+	unsigned long flags;
+	u32 epcfgreg;
+	struct xusb_udc *udc = &controller;
+
+	if (!_ep || (!ep->desc && ep->epnumber))
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+
+	if (ep->is_in && (!list_empty(&ep->queue)) && value) {
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		return -EAGAIN;
+	}
+	if ((ep->buffer0ready == 1) || (ep->buffer1ready == 1)) {
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		return -EAGAIN;
+	}
+
+	if (value) {
+		/* Stall the device.*/
+		epcfgreg = udc->read_fn(ep->udc->base_address +
+				   ep->endpointoffset);
+		epcfgreg |= XUSB_EP_CFG_STALL_MASK;
+
+		udc->write_fn(epcfgreg,
+			(ep->udc->base_address + ep->endpointoffset));
+		ep->stopped = 1;
+	} else {
+
+		ep->stopped = 0;
+		/* Unstall the device.*/
+		epcfgreg = udc->read_fn(ep->udc->base_address +
+					    ep->endpointoffset);
+		epcfgreg &= ~XUSB_EP_CFG_STALL_MASK;
+		udc->write_fn(epcfgreg,
+		(ep->udc->base_address + ep->endpointoffset));
+		if (ep->epnumber) {
+			/* Reset the toggle bit.*/
+			epcfgreg = udc->read_fn(ep->udc->base_address +
+						    ep->endpointoffset);
+			epcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;
+			udc->write_fn(epcfgreg, (ep->udc->base_address +
+					   ep->endpointoffset));
+		}
+	}
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+	return 0;
+}
+
+/**
+ * xusb_ep_enable() - Enables the given endpoint.
+ * @_ep:	Pointer to the usb device endpoint structure.
+ * @desc:	Pointer to usb endpoint descriptor.
+ *
+ * returns: 0 for success and error value on failure
+ **/
+static int xusb_ep_enable(struct usb_ep *_ep,
+			  const struct usb_endpoint_descriptor *desc)
+{
+	struct xusb_ep *ep = container_of(_ep, struct xusb_ep, ep);
+	struct xusb_udc *dev = ep->udc;
+	u32 tmp;
+	u8 eptype = 0;
+	unsigned long flags;
+	u32 epcfg;
+	struct xusb_udc *udc = &controller;
+
+	/*
+	 * The check for _ep->name == ep0name is not done as this enable i used
+	 * for enabling ep0 also. In other gadget drivers, this ep name is not
+	 * used.
+	 */
+	if (!_ep || !desc || ep->desc ||
+	    desc->bDescriptorType != USB_DT_ENDPOINT) {
+		dev_dbg(&ep->udc->gadget.dev, "first check fails\n");
+		return -EINVAL;
+	}
+
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		dev_dbg(&ep->udc->gadget.dev, "bogus device state\n");
+		return -ESHUTDOWN;
+	}
+
+
+	ep->is_in = ((desc->bEndpointAddress & USB_DIR_IN) != 0);
+	/* The address of the endpoint is encoded as follows:
+	 * Bit 3...0: The endpoint number
+	 * Bit 6...4: Reserved, reset to zero
+	 * Bit 7: Direction, ignored for
+	 * control endpoints
+	 * 0 = OUT endpoint
+	 * 1 = IN endpoint
+	 */
+	ep->epnumber = (desc->bEndpointAddress & 0x0f);
+	ep->stopped = 0;
+	ep->desc = desc;
+	tmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	switch (tmp) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		dev_dbg(&ep->udc->gadget.dev, "only one control endpoint\n");
+		/* NON- ISO */
+		eptype = 0;
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		return -EINVAL;
+	case USB_ENDPOINT_XFER_INT:
+		/* NON- ISO */
+		eptype = 0;
+		if (ep->ep.maxpacket > 64)
+			goto bogus_max;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		/* NON- ISO */
+		eptype = 0;
+		switch (ep->ep.maxpacket) {
+		case 8:
+		case 16:
+		case 32:
+		case 64:
+		case 512:
+		goto ok;
+		}
+bogus_max:
+		dev_dbg(&ep->udc->gadget.dev, "bogus maxpacket %d\n",
+			ep->ep.maxpacket);
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		return -EINVAL;
+	case USB_ENDPOINT_XFER_ISOC:
+		/* ISO */
+		eptype = 1;
+		ep->is_iso = 1;
+		break;
+	}
+
+ok:	ep->eptype = eptype;
+	ep->buffer0ready = 0;
+	ep->buffer1ready = 0;
+	ep->curbufnum = 0;
+	ep->rambase = rambase[ep->epnumber];
+	ep_configure(ep, ep->udc);
+
+	dev_dbg(&ep->udc->gadget.dev, "Enable Endpoint %d max pkt is %d\n",
+		ep->epnumber, ep->ep.maxpacket);
+
+	/* Enable the End point.*/
+	epcfg = udc->read_fn(ep->udc->base_address + ep->endpointoffset);
+	epcfg |= XUSB_EP_CFG_VALID_MASK;
+	udc->write_fn(epcfg,
+		(ep->udc->base_address + ep->endpointoffset));
+	if (ep->epnumber)
+		ep->rambase <<= 2;
+
+	if (ep->epnumber)
+		udc->write_fn((udc->read_fn(ep->udc->base_address +
+				XUSB_IER_OFFSET) |
+				(XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK <<
+				ep->epnumber)),
+				(ep->udc->base_address + XUSB_IER_OFFSET));
+	if ((ep->epnumber) && (!ep->is_in)) {
+
+		/* Set the buffer ready bits.*/
+		udc->write_fn(1 << ep->epnumber, (ep->udc->base_address +
+				  XUSB_BUFFREADY_OFFSET));
+		ep->buffer0ready = 1;
+		udc->write_fn((1 << (ep->epnumber +
+				XUSB_STATUS_EP_BUFF2_SHIFT)),
+				(ep->udc->base_address +
+				XUSB_BUFFREADY_OFFSET));
+		ep->buffer1ready = 1;
+	}
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	return 0;
+}
+
+/**
+ * xusb_ep_disable() - Disables the given endpoint.
+ * @_ep:	Pointer to the usb device endpoint structure.
+ *
+ * returns: 0 for success and error value on failure
+ **/
+static int xusb_ep_disable(struct usb_ep *_ep)
+{
+	struct xusb_ep *ep = container_of(_ep, struct xusb_ep, ep);
+	unsigned long flags;
+	u32 epcfg;
+	struct xusb_udc *udc = &controller;
+
+	if (ep == &ep->udc->ep[XUSB_EP_NUMBER_ZERO]) {
+		dev_dbg(&ep->udc->gadget.dev, "Ep0 disable called\n");
+		return -EINVAL;
+	}
+	spin_lock_irqsave(&ep->udc->lock, flags);
+
+	nuke(ep, -ESHUTDOWN);
+
+	/*
+	 * Restore the endpoint's pristine config
+	 */
+	ep->desc = NULL;
+
+	ep->stopped = 1;
+
+	/* The address of the endpoint is encoded as follows:
+	   Bit 3...0: The endpoint number
+	   Bit 6...4: Reserved, reset to zero
+	   Bit 7: Direction, ignored for
+	   control endpoints
+	   0 = OUT endpoint
+	   1 = IN endpoint */
+	dev_dbg(&ep->udc->gadget.dev, "USB Ep %d disable\n ", ep->epnumber);
+
+	/* Disable the endpoint.*/
+	epcfg = udc->read_fn(ep->udc->base_address + ep->endpointoffset);
+	epcfg &= ~XUSB_EP_CFG_VALID_MASK;
+	udc->write_fn(epcfg, (ep->udc->base_address + ep->endpointoffset));
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+	return 0;
+}
+
+/**
+ * xusb_ep_alloc_request() - Initializes the request queue.
+ * @_ep:	Pointer to the usb device endpoint structure.
+ * @gfp_flags:	Flags related to the request call.
+ *
+ * returns: pointer to request structure on success and a NULL on failure.
+ **/
+static struct usb_request *xusb_ep_alloc_request(struct usb_ep *_ep,
+						 gfp_t gfp_flags)
+{
+	struct xusb_request *req;
+
+	req = kmalloc(sizeof(*req), gfp_flags);
+	if (!req)
+		return NULL;
+
+	memset(req, 0, sizeof(*req));
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+/**
+ * xusb_ep_free_request() - Releases the request from queue.
+ * @_ep:	Pointer to the usb device endpoint structure.
+ * @_req:	Pointer to the usb request structure.
+ *
+ **/
+static void xusb_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct xusb_ep *ep = container_of(_ep, struct xusb_ep, ep);
+	struct xusb_request *req;
+
+	req = container_of(_req, struct xusb_request, req);
+
+	if (!list_empty(&req->queue))
+		dev_warn(&ep->udc->gadget.dev, "Error: No memory to free");
+
+	kfree(req);
+}
+
+/**
+ * xusb_ep_queue() - Adds the request to the queue.
+ * @_ep:	Pointer to the usb device endpoint structure.
+ * @_req:	Pointer to the usb request structure.
+ * @gfp_flags:	Flags related to the request call.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int xusb_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
+			 gfp_t gfp_flags)
+{
+	struct xusb_request *req;
+	struct xusb_ep *ep;
+	struct xusb_udc *dev;
+	unsigned long flags;
+	u8 *buf;
+	u32 length;
+	u8 *corebuf;
+	struct xusb_udc *udc = &controller;
+
+	req = container_of(_req, struct xusb_request, req);
+	ep = container_of(_ep, struct xusb_ep, ep);
+
+	if (!_req || !_req->complete || !_req->buf ||
+	    !list_empty(&req->queue)) {
+		dev_dbg(&ep->udc->gadget.dev, "invalid request\n");
+		return -EINVAL;
+	}
+
+	if (!_ep || (!ep->desc && ep->ep.name != ep0name)) {
+		dev_dbg(&ep->udc->gadget.dev, "invalid ep\n");
+		return -EINVAL;
+	}
+
+	dev = ep->udc;
+	if (!dev || !dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		dev_dbg(&ep->udc->gadget.dev, "%s, bogus device state %p\n",
+			__func__, dev->driver);
+		return -ESHUTDOWN;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	/* Try to kickstart any empty and idle queue */
+	if (list_empty(&ep->queue)) {
+		if (!ep->epnumber) {
+
+			buf = req->req.buf + req->req.actual;
+			prefetch(buf);
+			length = req->req.length - req->req.actual;
+
+			corebuf = (void __force *) ((ep->rambase << 2) +
+					    ep->udc->base_address);
+			while (length--)
+				*corebuf++ = *buf++;
+			udc->write_fn(req->req.length, (ep->udc->base_address +
+					   XUSB_EP_BUF0COUNT_OFFSET));
+			udc->write_fn(1, (ep->udc->base_address +
+					   XUSB_BUFFREADY_OFFSET));
+			req = NULL;
+		} else {
+
+			if (ep->is_in) {
+				dev_dbg(&ep->udc->gadget.dev,
+					"write_fifo called from queue\n");
+				if (write_fifo(ep, req) == 1)
+					req = NULL;
+			} else {
+				dev_dbg(&ep->udc->gadget.dev,
+					"read_fifo called from queue\n");
+				if (read_fifo(ep, req) == 1)
+					req = NULL;
+			}
+		}
+	}
+
+	if (req != NULL)
+		list_add_tail(&req->queue, &ep->queue);
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return 0;
+}
+
+/**
+ * xusb_ep_dequeue() - Removes the request from the queue.
+ * @_ep:	Pointer to the usb device endpoint structure.
+ * @_req:	Pointer to the usb request structure.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int xusb_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct xusb_ep *ep;
+	struct xusb_request *req;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct xusb_ep, ep);
+
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	/* Make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		return -EINVAL;
+	}
+
+	done(ep, req, -ECONNRESET);
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	return 0;
+}
+
+static struct usb_ep_ops xusb_ep_ops = {
+	.enable = xusb_ep_enable,
+	.disable = xusb_ep_disable,
+
+	.alloc_request = xusb_ep_alloc_request,
+	.free_request = xusb_ep_free_request,
+
+	.queue = xusb_ep_queue,
+	.dequeue = xusb_ep_dequeue,
+	.set_halt = xusb_ep_set_halt,
+};
+
+/**
+ * xusb_get_frame() - Reads the current usb frame number.
+ * @gadget:	Pointer to the usb gadget structure.
+ *
+ * returns: current frame number for success and error value on failure.
+ **/
+static int xusb_get_frame(struct usb_gadget *gadget)
+{
+
+	struct xusb_udc *udc = to_udc(gadget);
+	unsigned long flags;
+	int retval;
+
+	if (!gadget)
+		return -ENODEV;
+
+	local_irq_save(flags);
+	retval = udc->read_fn(udc->base_address + XUSB_FRAMENUM_OFFSET);
+	local_irq_restore(flags);
+	return retval;
+}
+
+/**
+ * set_testmode() - Sets the usb device into the given test mode.
+ * @udc:	Pointer to the usb controller structure.
+ * @testmode:	Test mode to which the device is to be set.
+ * @bufptr:	Pointer to the buffer containing the test packet.
+ *
+ *	This function is needed for USB certification tests.
+ * returns: This function never returns if the command is successful
+ *		and -ENOTSUPP on failure.
+ **/
+static int set_testmode(struct xusb_udc *udc, u8 testmode, u8 *bufptr)
+{
+	u32 *src, *dst;
+	u32 count;
+	u32 crtlreg;
+
+	/* Stop the SIE.*/
+	crtlreg = udc->read_fn(udc->base_address + XUSB_CONTROL_OFFSET);
+	crtlreg &= ~XUSB_CONTROL_USB_READY_MASK;
+	udc->write_fn(crtlreg, (udc->base_address + XUSB_CONTROL_OFFSET));
+	if (testmode == TEST_PKT) {
+
+		if (bufptr == NULL)
+			/* Null pointer is passed.*/
+			return -EINVAL;
+
+
+		src = (u32 *) bufptr;
+		dst = (u32 __force *) (udc->base_address);
+		count = 14;
+
+		/* Copy Leurker PKT to DPRAM at 0.*/
+		while (count--)
+			*dst++ = *src++;
+	}
+
+	/* Set the test mode.*/
+	udc->write_fn(testmode, (udc->base_address + XUSB_TESTMODE_OFFSET));
+	/* Re-start the SIE.*/
+	udc->write_fn(XUSB_CONTROL_USB_READY_MASK,
+		(udc->base_address + XUSB_CONTROL_OFFSET));
+
+	while (1)
+		;		/* Only way out is through hardware reset! */
+
+	return 0;
+}
+
+/**
+ * xusb_ioctl() - The i/o control function to call the testmode function.
+ * @gadget:	Pointer to the usb gadget structure.
+ * @code:	Test mode to which the device is to be set.
+ * @param:	Parameter to be sent for the test.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int xusb_ioctl(struct usb_gadget *gadget, unsigned code,
+		      unsigned long param)
+{
+	struct xusb_udc *udc = to_udc(gadget);
+	u8 *BufPtr;
+
+	BufPtr = (u8 *) param;
+
+	if ((code == TEST_J) || (code == TEST_K) ||
+	    (code == TEST_SE0_NAK) || (code == TEST_PKT))
+
+		return set_testmode(udc, code, BufPtr);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int xudc_start(struct usb_gadget_driver *driver,
+				int (*bind)(struct usb_gadget *,
+				struct usb_gadget_driver *driver));
+static int xudc_stop(struct usb_gadget_driver *driver);
+static void xusb_release(struct device *dev);
+
+static const struct usb_gadget_ops xusb_udc_ops = {
+	.get_frame = xusb_get_frame,
+	.ioctl = xusb_ioctl,
+	.start = xudc_start,
+	.stop  = xudc_stop,
+};
+
+
+/*-------------------------------------------------------------------------*/
+static struct xusb_udc controller = {
+	.gadget = {
+		.ops = &xusb_udc_ops,
+		.ep0 = &controller.ep[XUSB_EP_NUMBER_ZERO].ep,
+		.speed = USB_SPEED_HIGH,
+		.max_speed = USB_SPEED_HIGH,
+		.is_otg = 0,
+		.is_a_peripheral = 0,
+		.b_hnp_enable = 0,
+		.a_hnp_support = 0,
+		.a_alt_hnp_support = 0,
+		.name = driver_name,
+		.dev = {
+			.init_name = "xilinx_udc",
+			.release = xusb_release,
+			},
+		},
+	.ep[0] = {
+		  .ep = {
+			 .name = ep0name,
+			 .ops = &xusb_ep_ops,
+			 .maxpacket = 0x40,
+			 },
+			.udc = &controller,
+		.epnumber = 0,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.curbufnum = 0,
+		.eptype = 0,
+		.endpointoffset = 0,
+		},
+	.ep[1] = {
+		  .ep = {
+			 .name = "ep1",
+			 .ops = &xusb_ep_ops,
+			 },
+		.udc = &controller,
+		.epnumber = 1,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.curbufnum = 0,
+		.eptype = 0,
+		.endpointoffset = 0,
+		},
+	.ep[2] = {
+		  .ep = {
+			 .name = "ep2",
+			 .ops = &xusb_ep_ops,
+			 },
+		.udc = &controller,
+		.epnumber = 2,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.curbufnum = 0,
+		.eptype = 0,
+		.endpointoffset = 0,
+		},
+	.ep[3] = {
+		  .ep = {
+			 .name = "ep3",
+			 .ops = &xusb_ep_ops,
+			 },
+		.udc = &controller,
+		.epnumber = 3,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.curbufnum = 0,
+		.eptype = 0,
+		.endpointoffset = 0,
+		},
+	.ep[4] = {
+		  .ep = {
+			 .name = "ep4",
+			 .ops = &xusb_ep_ops,
+			 },
+		.udc = &controller,
+		.epnumber = 4,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.curbufnum = 0,
+		.eptype = 0,
+		.endpointoffset = 0,
+		},
+	.ep[5] = {
+		  .ep = {
+			 .name = "ep5",
+			 .ops = &xusb_ep_ops,
+			 },
+		.udc = &controller,
+		.epnumber = 5,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.curbufnum = 0,
+		.eptype = 0,
+		.endpointoffset = 0,
+		},
+	.ep[6] = {
+		  .ep = {
+			 .name = "ep6",
+			 .ops = &xusb_ep_ops,
+			 },
+		.udc = &controller,
+		.epnumber = 6,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.eptype = 0,
+		.curbufnum = 0,
+		.endpointoffset = 0,
+		},
+	.ep[7] = {
+		  .ep = {
+			 .name = "ep7",
+			 .ops = &xusb_ep_ops,
+			 },
+		.udc = &controller,
+		.epnumber = 7,
+		.buffer0count = 0,
+		.buffer0ready = 0,
+		.buffer1count = 0,
+		.buffer1ready = 0,
+		.curbufnum = 0,
+		.eptype = 0,
+		.endpointoffset = 0,
+		},
+	.status = 0,
+	.write_fn = xusb_write32_be,
+	.read_fn = xusb_read32_be,
+};
+
+/**
+ * xudc_reinit() - Restores inital software state.
+ * @udc:	Pointer to the usb device controller structure.
+ *
+ **/
+static void xudc_reinit(struct xusb_udc *udc)
+{
+	u32 ep_number;
+
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	INIT_LIST_HEAD(&udc->gadget.ep0->ep_list);
+
+	for (ep_number = 0; ep_number < XUSB_MAX_ENDPOINTS; ep_number++) {
+		struct xusb_ep *ep = &udc->ep[ep_number];
+
+		if (ep_number)
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+		ep->desc = NULL;
+		ep->stopped = 0;
+		/*
+		 * The configuration register address offset between
+		 * each endpoint is 0x10.
+		 */
+		ep->endpointoffset = XUSB_EP0_CONFIG_OFFSET +
+					(ep_number * 0x10);
+		ep->is_in = 0;
+		ep->is_iso = 0;
+		ep->maxpacket = 0;
+		ep_configure(ep, udc);
+		udc->status = 0;
+
+		/* Initialize one queue per endpoint */
+		INIT_LIST_HEAD(&ep->queue);
+	}
+}
+
+/**
+ * stop_activity() - Stops any further activity on the device.
+ * @udc:	Pointer to the usb device controller structure.
+ *
+ **/
+static void stop_activity(struct xusb_udc *udc)
+{
+	struct usb_gadget_driver *driver = udc->driver;
+	int i;
+
+	if (udc->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+	udc->gadget.speed = USB_SPEED_HIGH;
+
+	for (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {
+		struct xusb_ep *ep = &udc->ep[i];
+
+		ep->stopped = 1;
+		nuke(ep, -ESHUTDOWN);
+	}
+	if (driver) {
+		spin_unlock(&udc->lock);
+		driver->disconnect(&udc->gadget);
+		spin_lock(&udc->lock);
+	}
+
+	xudc_reinit(udc);
+}
+
+/**
+ * startup_intrhandler() - The usb device controller interrupt handler.
+ * @callbackref:	Pointer to the reference value being passed.
+ * @intrstatus:		The mask value containing the interrupt sources.
+ *
+ *	This handler handles the RESET, SUSPEND and DISCONNECT interrupts.
+ **/
+static void startup_intrhandler(void *callbackref, u32 intrstatus)
+{
+	struct xusb_udc *udc;
+	u32 intrreg;
+
+	udc = (struct xusb_udc *) callbackref;
+
+	if (intrstatus & XUSB_STATUS_RESET_MASK) {
+		dev_dbg(&udc->gadget.dev, "Reset\n");
+		if (intrstatus & XUSB_STATUS_HIGH_SPEED_MASK)
+			udc->gadget.speed = USB_SPEED_HIGH;
+		else
+			udc->gadget.speed = USB_SPEED_FULL;
+		if (udc->status == 1) {
+			udc->status = 0;
+			/* Set device address to 0.*/
+			udc->write_fn(0, (udc->base_address +
+						XUSB_ADDRESS_OFFSET));
+		}
+		/* Disable the Reset interrupt.*/
+		intrreg = udc->read_fn(udc->base_address +
+					XUSB_IER_OFFSET);
+
+		intrreg &= ~XUSB_STATUS_RESET_MASK;
+		udc->write_fn(intrreg, (udc->base_address + XUSB_IER_OFFSET));
+		/* Enable thesuspend and disconnect.*/
+		intrreg =
+			udc->read_fn(udc->base_address + XUSB_IER_OFFSET);
+		intrreg |=
+			(XUSB_STATUS_SUSPEND_MASK |
+			 XUSB_STATUS_DISCONNECT_MASK);
+		udc->write_fn(intrreg, (udc->base_address + XUSB_IER_OFFSET));
+	}
+
+	if (intrstatus & XUSB_STATUS_DISCONNECT_MASK) {
+
+		/* Disable the Disconnect interrupt.*/
+		intrreg =
+			udc->read_fn(udc->base_address + XUSB_IER_OFFSET);
+		intrreg &= ~XUSB_STATUS_DISCONNECT_MASK;
+		udc->write_fn(intrreg, (udc->base_address + XUSB_IER_OFFSET));
+		dev_dbg(&udc->gadget.dev, "Disconnect\n");
+		if (udc->status == 1) {
+			udc->status = 0;
+			/* Set device address to 0.*/
+			udc->write_fn(0, (udc->base_address +
+					XUSB_ADDRESS_OFFSET));
+			/* Enable the USB device.*/
+			udc->write_fn(XUSB_CONTROL_USB_READY_MASK,
+				(udc->base_address + XUSB_CONTROL_OFFSET));
+		}
+
+		/* Enable the suspend and reset interrupts.*/
+		intrreg = (udc->read_fn(udc->base_address + XUSB_IER_OFFSET) |
+				(XUSB_STATUS_SUSPEND_MASK |
+				XUSB_STATUS_RESET_MASK));
+		udc->write_fn(intrreg, (udc->base_address + XUSB_IER_OFFSET));
+		stop_activity(udc);
+	}
+
+	if (intrstatus & XUSB_STATUS_SUSPEND_MASK) {
+		dev_dbg(&udc->gadget.dev, "Suspend\n");
+		/* Disable the Suspend interrupt.*/
+		intrreg = (udc->read_fn(udc->base_address + XUSB_IER_OFFSET) &
+					~XUSB_STATUS_SUSPEND_MASK);
+		udc->write_fn(intrreg, (udc->base_address + XUSB_IER_OFFSET));
+		/* Enable the Disconnect and reset interrupts. */
+		intrreg = (udc->read_fn(udc->base_address + XUSB_IER_OFFSET)|
+				(XUSB_STATUS_DISCONNECT_MASK |
+				XUSB_STATUS_RESET_MASK));
+		udc->write_fn(intrreg, (udc->base_address + XUSB_IER_OFFSET));
+	}
+}
+
+/**
+ * setup_ctrl_wr_status_stage() - Sets up the usb device status stages.
+ * @udc:		Pointer to the usb device controller structure.
+ *
+ **/
+static void setup_ctrl_wr_status_stage(struct xusb_udc *udc)
+{
+	u32 epcfgreg;
+
+	epcfgreg = (udc->read_fn(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset)|
+				XUSB_EP_CFG_DATA_TOGGLE_MASK);
+	udc->write_fn(epcfgreg, (udc->base_address +
+			udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset));
+	udc->write_fn(0, (udc->base_address +
+			udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset +
+			  XUSB_EP_BUF0COUNT_OFFSET));
+	udc->write_fn(1, (udc->base_address + XUSB_BUFFREADY_OFFSET));
+}
+
+/**
+ * set_configuration() - Sets the device configuration.
+ * @udc:		Pointer to the usb device controller structure.
+ *
+ *	Processes the SET_CONFIGURATION command recieved during enumeration.
+ **/
+static void set_configuration(struct xusb_udc *udc)
+{
+	u32 epcfgreg;
+
+	switch (ch9_cmdbuf.setup.wValue) {
+	case 0:
+		/*
+		 * This configuration value resets the device to the
+		 * un configured state like power up.
+		 */
+		udc->status = 0;
+		/* Cause a valid status phase to be issued.*/
+		setup_ctrl_wr_status_stage(udc);
+
+		break;
+	case CONFIGURATION_ONE:
+		udc->status = 1;
+		setup_ctrl_wr_status_stage(udc);
+		break;
+
+		/* Additional configurations can be added here.*/
+	default:
+		/* Stall the end point.*/
+		epcfgreg = (udc->read_fn(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset)|
+				XUSB_EP_CFG_STALL_MASK);
+
+		udc->write_fn(epcfgreg, (udc->base_address +
+			udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset));
+		break;
+	}
+}
+
+/**
+ * setclearfeature() - Executes the set feature and clear feature commands.
+ * @udc:		Pointer to the usb device controller structure.
+ * @flag:		Value deciding the set or clear action.
+ *
+ * Processes the SET_FEATURE and CLEAR_FEATURE commands.
+ **/
+static void set_clear_feature(struct xusb_udc *udc, int flag)
+{
+	u8 endpoint;
+	u8 outinbit;
+	u32 epcfgreg;
+
+	switch (ch9_cmdbuf.setup.bRequestType) {
+	case STANDARD_OUT_DEVICE:
+		switch (ch9_cmdbuf.setup.wValue) {
+		case USB_DEVICE_REMOTE_WAKEUP:
+			/* User needs to add code here.*/
+			break;
+
+		case USB_DEVICE_TEST_MODE:
+			/*
+			 * The Test Mode will be executed
+			 * after the status phase.
+			 */
+			break;
+
+		default:
+			epcfgreg = udc->read_fn(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset);
+			epcfgreg |= XUSB_EP_CFG_STALL_MASK;
+			udc->write_fn(epcfgreg, (udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset));
+			break;
+		}
+		break;
+
+	case STANDARD_OUT_ENDPOINT:
+		if (!ch9_cmdbuf.setup.wValue) {
+			endpoint = ch9_cmdbuf.setup.wIndex & 0xf;
+			outinbit = ch9_cmdbuf.setup.wIndex & 0x80;
+			outinbit = outinbit >> 7;
+
+			/* Make sure direction matches.*/
+			if (outinbit != udc->ep[endpoint].is_in) {
+				epcfgreg = udc->read_fn(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset);
+				epcfgreg |= XUSB_EP_CFG_STALL_MASK;
+
+				udc->write_fn(epcfgreg, (udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset));
+				return;
+			}
+
+			if (!endpoint) {
+				/* Clear the stall.*/
+				epcfgreg = udc->read_fn(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset);
+
+				epcfgreg &= ~XUSB_EP_CFG_STALL_MASK;
+
+				udc->write_fn(epcfgreg, (udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset));
+				break;
+			} else {
+				if (flag == 1) {
+					epcfgreg =
+						udc->read_fn(udc->base_address +
+					udc->ep[XUSB_EP_NUMBER_ZERO].
+					endpointoffset);
+					epcfgreg |= XUSB_EP_CFG_STALL_MASK;
+
+					udc->write_fn(epcfgreg,
+						(udc->base_address +
+						udc->ep[XUSB_EP_NUMBER_ZERO].
+						endpointoffset));
+				} else {
+					/* Unstall the endpoint.*/
+					epcfgreg =
+						udc->read_fn(udc->base_address +
+					udc->ep[endpoint].endpointoffset);
+					epcfgreg &=
+						~(XUSB_EP_CFG_STALL_MASK |
+						  XUSB_EP_CFG_DATA_TOGGLE_MASK);
+					udc->write_fn(epcfgreg,
+						(udc->base_address +
+						udc->ep[endpoint].
+						endpointoffset));
+				}
+			}
+		}
+		break;
+
+	default:
+		epcfgreg = udc->read_fn(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset);
+		epcfgreg |= XUSB_EP_CFG_STALL_MASK;
+		udc->write_fn(epcfgreg, (udc->base_address +
+			udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset));
+		return;
+	}
+
+	/* Cause and valid status phase to be issued.*/
+	setup_ctrl_wr_status_stage(udc);
+
+	return;
+}
+
+/**
+ * execute_command() - Processes the USB specification chapter 9 commands.
+ * @udc:		Pointer to the usb device controller structure.
+ *
+ * returns: 0 for success and the same reuqest command if it is not handled.
+ *
+ **/
+static int execute_command(struct xusb_udc *udc)
+{
+
+	if ((ch9_cmdbuf.setup.bRequestType & USB_TYPE_MASK) ==
+	    USB_TYPE_STANDARD) {
+		/* Process the chapter 9 command.*/
+		switch (ch9_cmdbuf.setup.bRequest) {
+
+		case USB_REQ_CLEAR_FEATURE:
+			set_clear_feature(udc, 0);
+			break;
+
+		case USB_REQ_SET_FEATURE:
+			set_clear_feature(udc, 1);
+			break;
+
+		case USB_REQ_SET_ADDRESS:
+			setup_ctrl_wr_status_stage(udc);
+			break;
+
+		case USB_REQ_SET_CONFIGURATION:
+			set_configuration(udc);
+			return ch9_cmdbuf.setup.bRequest;
+
+		default:
+			/*
+			 * Return the same request to application for
+			 * handling.
+			 */
+			return ch9_cmdbuf.setup.bRequest;
+		}
+
+	} else
+		if ((ch9_cmdbuf.setup.bRequestType & USB_TYPE_MASK) ==
+					USB_TYPE_CLASS)
+			return ch9_cmdbuf.setup.bRequest;
+	return 0;
+}
+
+/**
+ * process_setup_pkt() - Processes the setup packet.
+ * @udc:		Pointer to the usb device controller structure.
+ * @ctrl:		Pointer to the usb control endpoint structure.
+ *
+ * returns: 0 for success and request to be handled by application if
+ *		is not handled by the driver.
+ *
+ **/
+static int process_setup_pkt(struct xusb_udc *udc, struct usb_ctrlrequest *ctrl)
+{
+	u32 *ep0rambase;
+
+	/* Load up the chapter 9 command buffer.*/
+	ep0rambase = (u32 __force *) (udc->base_address +
+				  XUSB_SETUP_PKT_ADDR_OFFSET);
+	memcpy((void *)&ch9_cmdbuf.setup, (void *)ep0rambase, 8);
+
+	ctrl->bRequestType = ch9_cmdbuf.setup.bRequestType;
+	ctrl->bRequest     = ch9_cmdbuf.setup.bRequest;
+	ctrl->wValue       = ch9_cmdbuf.setup.wValue;
+	ctrl->wIndex       = ch9_cmdbuf.setup.wIndex;
+	ctrl->wLength      = ch9_cmdbuf.setup.wLength;
+
+	ch9_cmdbuf.setup.wValue = cpu_to_le16(ch9_cmdbuf.setup.wValue);
+	ch9_cmdbuf.setup.wIndex = cpu_to_le16(ch9_cmdbuf.setup.wIndex);
+	ch9_cmdbuf.setup.wLength = cpu_to_le16(ch9_cmdbuf.setup.wLength);
+
+	/* Restore ReadPtr to data buffer.*/
+	ch9_cmdbuf.contreadptr = &ch9_cmdbuf.contreaddatabuffer[0];
+
+	if (ch9_cmdbuf.setup.bRequestType & USB_DIR_IN) {
+		/* Execute the get command.*/
+		ch9_cmdbuf.setupseqrx = STATUS_PHASE;
+		ch9_cmdbuf.setupseqtx = DATA_PHASE;
+		return execute_command(udc);
+	} else {
+		/* Execute the put command.*/
+		ch9_cmdbuf.setupseqrx = DATA_PHASE;
+		ch9_cmdbuf.setupseqtx = STATUS_PHASE;
+		if (!ch9_cmdbuf.setup.wLength)
+			return execute_command(udc);
+	}
+	/* Control should never come here.*/
+	return 0;
+}
+
+/**
+ * ep0_out_token() - Processes the endpoint 0 OUT token.
+ * @udc:	Pointer to the usb device controller structure.
+ *
+ **/
+static void ep0_out_token(struct xusb_udc *udc)
+{
+	u8 count;
+	u8 *ep0rambase;
+	u16 index;
+
+	switch (ch9_cmdbuf.setupseqrx) {
+	case STATUS_PHASE:
+		/*
+		 * This resets both state machines for the next
+		 * Setup packet.
+		 */
+		ch9_cmdbuf.setupseqrx = SETUP_PHASE;
+		ch9_cmdbuf.setupseqtx = SETUP_PHASE;
+		break;
+
+	case DATA_PHASE:
+		count = udc->read_fn(udc->base_address +
+				XUSB_EP_BUF0COUNT_OFFSET);
+		/* Copy the data to be received from the DPRAM. */
+		ep0rambase =
+			(u8 __force *) (udc->base_address +
+				(udc->ep[XUSB_EP_NUMBER_ZERO].rambase << 2));
+
+		for (index = 0; index < count; index++)
+			*ch9_cmdbuf.contreadptr++ = *ep0rambase++;
+
+		ch9_cmdbuf.contreadcount += count;
+
+		/* Set the Tx packet size and the Tx enable bit.*/
+		udc->write_fn(count, (udc->base_address +
+						 XUSB_EP_BUF0COUNT_OFFSET));
+		udc->write_fn(1, (udc->base_address + XUSB_BUFFREADY_OFFSET));
+
+		if (ch9_cmdbuf.setup.wLength == ch9_cmdbuf.contreadcount)
+			execute_command(udc);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/**
+ * ep0_in_token() - Processes the endpoint 0 IN token.
+ * @udc:	Pointer to the usb device controller structure.
+ *
+ **/
+static void ep0_in_token(struct xusb_udc *udc)
+{
+	u32 epcfgreg;
+	u16 count;
+	u16 index;
+	u8 *ep0rambase;
+
+	switch (ch9_cmdbuf.setupseqtx) {
+	case STATUS_PHASE:
+		if (ch9_cmdbuf.setup.bRequest == USB_REQ_SET_ADDRESS) {
+			/* Set the address of the device.*/
+			udc->write_fn(ch9_cmdbuf.setup.wValue,
+					(udc->base_address +
+					XUSB_ADDRESS_OFFSET));
+		} else
+			if (ch9_cmdbuf.setup.bRequest == USB_REQ_SET_FEATURE) {
+				if (ch9_cmdbuf.setup.bRequestType ==
+					STANDARD_OUT_DEVICE) {
+					if (ch9_cmdbuf.setup.wValue ==
+						USB_DEVICE_TEST_MODE)
+						udc->write_fn(TEST_J,
+							(udc->base_address +
+							XUSB_TESTMODE_OFFSET));
+			}
+		}
+		break;
+
+	case DATA_PHASE:
+		if (!ch9_cmdbuf.contwritecount) {
+			/*
+			 * We're done with data transfer, next
+			 * will be zero length OUT with data toggle of
+			 * 1. Setup data_toggle.
+			 */
+			epcfgreg = udc->read_fn(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset);
+			epcfgreg |= XUSB_EP_CFG_DATA_TOGGLE_MASK;
+			udc->write_fn(epcfgreg,
+				(udc->base_address +
+				udc->ep[XUSB_EP_NUMBER_ZERO].endpointoffset));
+			count = 0;
+
+			ch9_cmdbuf.setupseqtx = STATUS_PHASE;
+
+		} else {
+			if (8 >= ch9_cmdbuf.contwritecount)
+				count = ch9_cmdbuf.contwritecount;
+			else
+				count = 8;
+
+			/* Copy the data to be transmitted into the DPRAM. */
+			ep0rambase = (u8 __force *) (udc->base_address +
+				(udc->ep[XUSB_EP_NUMBER_ZERO].rambase << 2));
+			for (index = 0; index < count; index++)
+				*ep0rambase++ = *ch9_cmdbuf.contwriteptr++;
+
+			ch9_cmdbuf.contwritecount -= count;
+		}
+		udc->write_fn(count, (udc->base_address +
+						XUSB_EP_BUF0COUNT_OFFSET));
+		udc->write_fn(1, (udc->base_address + XUSB_BUFFREADY_OFFSET));
+		break;
+
+	default:
+		break;
+	}
+}
+
+/**
+ * control_ep_intrhandler() - Endpoint 0 interrupt handler.
+ * @callbackref:	Pointer to the call back reference passed by the
+ *			main interrupt handler.
+ * @intrstatus:	It's the mask value for the interrupt sources on endpoint 0.
+ *
+ *	Processes the commands received during enumeration phase.
+ **/
+static void control_ep_intrhandler(void *callbackref, u32 intrstatus)
+{
+	struct xusb_udc *udc;
+	struct usb_ctrlrequest ctrl;
+	int status;
+	int epnum;
+	u32 intrreg;
+
+	udc = (struct xusb_udc *) callbackref;
+
+	/* Process the end point zero buffer interrupt.*/
+	if (intrstatus & XUSB_STATUS_EP0_BUFF1_COMP_MASK) {
+		if (intrstatus & XUSB_STATUS_SETUP_PACKET_MASK) {
+			/*
+			 * Enable the Disconnect, suspend and reset
+			 * interrupts.
+			 */
+			intrreg = udc->read_fn(udc->base_address +
+					XUSB_IER_OFFSET);
+			intrreg |= (XUSB_STATUS_DISCONNECT_MASK |
+					 XUSB_STATUS_SUSPEND_MASK |
+					 XUSB_STATUS_RESET_MASK);
+			udc->write_fn(intrreg,
+				(udc->base_address + XUSB_IER_OFFSET));
+			status = process_setup_pkt(udc, &ctrl);
+			if (status) {
+
+				/*
+				 * Request is to be handled by the gadget
+				 * driver.
+				 */
+				spin_unlock(&udc->lock);
+				udc->driver->setup(&udc->gadget, &ctrl);
+				spin_lock(&udc->lock);
+			} else {
+				if (ctrl.bRequest == USB_REQ_CLEAR_FEATURE) {
+					epnum = ctrl.wIndex & 0xf;
+					udc->ep[epnum].stopped = 0;
+				}
+				if (ctrl.bRequest == USB_REQ_SET_FEATURE) {
+					epnum = ctrl.wIndex & 0xf;
+					udc->ep[epnum].stopped = 1;
+				}
+			}
+		} else
+			if (intrstatus & XUSB_STATUS_FIFO_BUFF_RDY_MASK)
+				ep0_out_token(udc);
+			else if (intrstatus &
+				XUSB_STATUS_FIFO_BUFF_FREE_MASK)
+				ep0_in_token(udc);
+	}
+}
+
+/**
+ * noncontrol_ep_intrhandler() - Non control endpoint interrupt handler.
+ * @callbackref:	Pointer to the call back reference passed by the
+ *			main interrupt handler.
+ * @epnum:	End point number for which the interrupt is to be processed
+ * @intrstatus:	It's the mask value for the interrupt sources on endpoint 0.
+ *
+ **/
+static void noncontrol_ep_intrhandler(void *callbackref, u8 epnum,
+					u32 intrstatus)
+{
+
+	struct xusb_request *req;
+	struct xusb_udc *udc;
+	struct xusb_ep *ep;
+
+	udc = (struct xusb_udc *) callbackref;
+	ep = &udc->ep[epnum];
+
+	/* Process the End point interrupts.*/
+	if (intrstatus & (XUSB_STATUS_EP0_BUFF1_COMP_MASK << epnum))
+		ep->buffer0ready = 0;
+	if (intrstatus & (XUSB_STATUS_EP0_BUFF2_COMP_MASK << epnum))
+		ep->buffer1ready = 0;
+
+	if (list_empty(&ep->queue))
+		req = NULL;
+	else
+		req = list_entry(ep->queue.next, struct xusb_request, queue);
+	if (!req)
+		return;
+	if (ep->is_in)
+		(void)write_fifo(ep, req);
+	else
+		(void)read_fifo(ep, req);
+}
+
+/**
+ * xusb_udc_irq() - The main interrupt handler.
+ * @irq:	The interrupt number.
+ * @_udc:	Pointer to the usb device controller structure.
+ *
+ * returns: IRQ_HANDLED after the interrupt is handled.
+ *
+ **/
+static irqreturn_t xusb_udc_irq(int irq, void *_udc)
+{
+	struct xusb_udc *udc = _udc;
+	u32 intrstatus;
+	u8 index;
+	u32 bufintr;
+
+	spin_lock(&(udc->lock));
+
+	/* Read the Interrupt Status Register.*/
+	intrstatus = udc->read_fn(udc->base_address + XUSB_STATUS_OFFSET);
+	/* Call the handler for the event interrupt.*/
+	if (intrstatus & XUSB_STATUS_INTR_EVENT_MASK) {
+		/*
+		 * Check if there is any action to be done for :
+		 * - USB Reset received {XUSB_STATUS_RESET_MASK}
+		 * - USB Suspend received {XUSB_STATUS_SUSPEND_MASK}
+		 * - USB Disconnect received {XUSB_STATUS_DISCONNECT_MASK}
+		 */
+		startup_intrhandler(udc, intrstatus);
+	}
+
+	/* Check the buffer completion interrupts */
+	if (intrstatus & XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK) {
+		if (intrstatus & XUSB_STATUS_EP0_BUFF1_COMP_MASK)
+			control_ep_intrhandler(udc, intrstatus);
+
+		for (index = 1; index < 8; index++) {
+			bufintr = ((intrstatus &
+					(XUSB_STATUS_EP1_BUFF1_COMP_MASK <<
+							(index - 1))) ||
+				   (intrstatus &
+					(XUSB_STATUS_EP1_BUFF2_COMP_MASK <<
+							(index - 1))));
+
+			if (bufintr)
+				noncontrol_ep_intrhandler(udc, index,
+						intrstatus);
+		}
+	}
+	spin_unlock(&(udc->lock));
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * xudc_start() - Starts the device.
+ * @driver:	Pointer to the usb gadget sturcutre.
+ * @bind:	Function pointer to bind driver
+ * returns: 0 for success and error value on failure
+ *
+ **/
+int xudc_start(struct usb_gadget_driver *driver,
+				int (*bind)(struct usb_gadget *,
+				struct usb_gadget_driver *driver))
+{
+	struct xusb_udc *udc = &controller;
+	int retval;
+	const struct usb_endpoint_descriptor *d = &config_bulk_out_desc;
+
+	/*
+	 * Check whether the driver related structure parameters
+	 * are created properly.
+	 */
+	if (!driver
+	    || driver->max_speed < USB_SPEED_FULL ||
+		!bind || !driver->unbind || !driver->setup) {
+		dev_dbg(&udc->gadget.dev, "bad parameter.\n");
+		return -EINVAL;
+	}
+
+	/* Is the device already declared as a gadget driver.*/
+	if (udc->driver) {
+		dev_dbg(&udc->gadget.dev,
+			"UDC already has a gadget driver\n");
+		return -EBUSY;
+	}
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+	udc->gadget.speed = driver->max_speed;
+	/* Add and bind the USB device to the device structure.*/
+	retval = device_add(&udc->gadget.dev);
+	retval = bind(&udc->gadget, driver);
+	if (retval) {
+		dev_dbg(&udc->gadget.dev,
+			"driver->bind() returned %d\n", retval);
+		udc->driver = NULL;
+		udc->gadget.dev.driver = NULL;
+		return retval;
+	}
+	xusb_ep_enable(&udc->ep[XUSB_EP_NUMBER_ZERO].ep, d);
+	/* Enable the USB device.*/
+	udc->write_fn(XUSB_CONTROL_USB_READY_MASK,
+		(udc->base_address + XUSB_CONTROL_OFFSET));
+	return 0;
+}
+
+/**
+ * xudc_stop() - stops the device.
+ * @driver:	Pointer to the usb gadget sturcutre.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ */
+int xudc_stop(struct usb_gadget_driver *driver)
+{
+	struct xusb_udc *udc = &controller;
+	unsigned long flags;
+	u32 crtlreg;
+
+	if (!driver || driver != udc->driver || !driver->unbind)
+		return -EINVAL;
+
+	/* Disable USB device.*/
+	crtlreg = udc->read_fn(udc->base_address + XUSB_CONTROL_OFFSET);
+	crtlreg &= ~XUSB_CONTROL_USB_READY_MASK;
+	udc->write_fn(crtlreg, (udc->base_address + XUSB_CONTROL_OFFSET));
+	spin_lock_irqsave(&udc->lock, flags);
+	/* Stop any further activity in the device.*/
+	stop_activity(udc);
+	spin_unlock_irqrestore(&udc->lock, flags);
+	driver->unbind(&udc->gadget);
+	device_del(&udc->gadget.dev);
+	udc->gadget.dev.driver = NULL;
+	udc->driver = NULL;
+
+	dev_dbg(&udc->gadget.dev,
+		"unbound from %s\n", driver->driver.name);
+	return 0;
+}
+
+/**
+ * xudc_init() - Initializes the USB device structures.
+ * @dev:		Pointer to the device sturcutre.
+ * @regs_res:	Pointer to the resource structure for memory read.
+ * @irq_res:	Pointer to the resource structure for interrupt
+ *		resources.
+ * returns: 0 for success and error value on failure
+ *
+ */
+static int xudc_init(struct device *dev, struct resource *regs_res,
+		     struct resource *irq_res)
+{
+
+	struct xusb_udc *udc = &controller;
+	void __iomem *v_addr;
+	resource_size_t remap_size;
+	struct platform_device *pdev = to_platform_device(dev);
+	int retval;
+
+	device_initialize(&udc->gadget.dev);
+
+	remap_size = regs_res->end - regs_res->start + 1;
+	if (!request_mem_region(regs_res->start, remap_size,
+			driver_name)) {
+		dev_err(dev, "Couldn't lock memory region at 0x%08X\n",
+			     (u32)regs_res->start);
+		return -EBUSY;
+	}
+
+	v_addr = (void __iomem *)ioremap_nocache(regs_res->start, remap_size);
+
+	if (!v_addr) {
+		dev_err(dev, "Couldn't ioremap memory at 0x%08X\n",
+			(u32)regs_res->start);
+		release_mem_region(regs_res->start, remap_size);
+		return -EFAULT;
+
+	}
+	udc->base_address = v_addr;
+
+	if (regs_res->flags == IORESOURCE_DMA)
+		udc->dma_enabled = 1;
+	else
+		udc->dma_enabled = 0;
+
+	spin_lock_init(&udc->lock);
+
+	/* Check for IP endianness */
+	udc->write_fn(TEST_J, (udc->base_address + XUSB_TESTMODE_OFFSET));
+	if ((udc->read_fn(udc->base_address + XUSB_TESTMODE_OFFSET))
+			!= TEST_J) {
+		controller.write_fn = xusb_write32;
+		controller.read_fn = xusb_read32;
+	}
+	udc->write_fn(0, (udc->base_address + XUSB_TESTMODE_OFFSET));
+	xudc_reinit(udc);
+
+	/* Set device address to 0.*/
+	udc->write_fn(0, (udc->base_address + XUSB_ADDRESS_OFFSET));
+
+	/* Request UDC irqs */
+	if (request_irq
+	    (irq_res->start, xusb_udc_irq, IRQF_SHARED, driver_name, udc)) {
+		device_unregister(&udc->gadget.dev);
+		stop_activity(udc);
+		iounmap(udc->base_address);
+		release_mem_region(regs_res->start, remap_size);
+		return -EBUSY;
+	}
+	retval = device_add(&udc->gadget.dev);
+	if (retval)
+		dev_dbg(dev, "device_add returned %d\n", retval);
+
+	retval = usb_add_gadget_udc(dev, &udc->gadget);
+	if (retval)
+		dev_dbg(dev, "usb_add_gadget_udc returned %d\n", retval);
+
+	/* Enable the interrupts.*/
+	udc->write_fn((XUSB_STATUS_GLOBAL_INTR_MASK |
+		  XUSB_STATUS_RESET_MASK |
+		  XUSB_STATUS_DISCONNECT_MASK |
+		  XUSB_STATUS_SUSPEND_MASK |
+		  XUSB_STATUS_FIFO_BUFF_RDY_MASK |
+		  XUSB_STATUS_FIFO_BUFF_FREE_MASK |
+		  XUSB_STATUS_EP0_BUFF1_COMP_MASK),
+		  (udc->base_address + XUSB_IER_OFFSET));
+	platform_set_drvdata(pdev, udc);
+
+	udc->gadget.dev.parent = &pdev->dev;
+
+	dev_info(dev, "%s version %s\n", driver_name, DRIVER_VERSION);
+	dev_info(dev, "%s #%d at 0x%08X mapped to 0x%08X\n",
+	     driver_name, 0, (u32)regs_res->start, (u32 __force) v_addr);
+	return 0;
+}
+
+/**
+ * xudc_remove() - Releases the resources allocated during the initialization.
+ * @pdev:	Pointer to the platform device structure.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int xudc_remove(struct platform_device *pdev)
+{
+
+	struct xusb_udc *udc = platform_get_drvdata(pdev);
+	struct resource *irq_res;
+	struct resource *res; /* IO mem resources */
+	struct device *dev;
+	dev = &pdev->dev;
+
+	dev_dbg(dev, "remove\n");
+	usb_del_gadget_udc(&udc->gadget);
+	if (udc->driver)
+		return -EBUSY;
+	iounmap(udc->base_address);
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	free_irq(irq_res->start, udc);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static void xusb_release(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xusb_udc *udc = platform_get_drvdata(pdev);
+
+	kfree(udc);
+}
+
+/**
+ * usb_of_probe() - The device probe function for driver initialization.
+ * @op:		Pointer to the platform device structure.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int
+usb_of_probe(struct platform_device *op)
+{
+	struct device_node *np = op->dev.of_node;
+	struct resource res, irq_res;
+	int rc;
+	const u32 *dma;
+
+	dev_dbg(&op->dev, "%s(%p)\n", __func__, op);
+
+	rc = of_address_to_resource(np, 0, &res);
+	if (rc) {
+		dev_err(&op->dev, "invalid address\n");
+		return rc;
+	}
+
+	rc = of_irq_to_resource(np, 0, &irq_res);
+	if (rc <= 0) {
+		dev_err(&op->dev, "No IRQ found\n");
+		return rc;
+	}
+
+	dma = of_get_property(np, "xlnx,include-dma", NULL);
+	if (!dma) {
+		dev_err(&op->dev, "DMA information missing in device tree\n");
+		return -ENODATA;
+	}
+	if (*dma)
+		res.flags = IORESOURCE_DMA;
+	else
+		res.flags = IORESOURCE_IO;
+
+
+	return xudc_init(&op->dev, &res, &irq_res);
+}
+
+/**
+ * usb_of_remove() - The device driver remove function.
+ * @pdev:		Pointer to the platform device structure.
+ *
+ * returns: 0 for success and error value on failure
+ *
+ **/
+static int usb_of_remove(struct platform_device *pdev)
+{
+	return xudc_remove(pdev);
+}
+
+static struct platform_driver usb_of_driver = {
+	.driver = {
+		.name = driver_name,
+		.owner = THIS_MODULE,
+		.of_match_table = usb_of_match,
+	},
+	.probe = usb_of_probe,
+	.remove = usb_of_remove,
+};
+
+module_platform_driver(usb_of_driver);
+
+MODULE_DESCRIPTION("Xilinx udc driver");
+MODULE_AUTHOR("Xilinx, Inc");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/xilinx_usbps_udc.c b/drivers/usb/gadget/xilinx_usbps_udc.c
new file mode 100644
index 0000000..f127fbb
--- /dev/null
+++ b/drivers/usb/gadget/xilinx_usbps_udc.c
@@ -0,0 +1,3099 @@
+/*
+ * Xilinx PS USB Device Controller Driver.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on fsl_udc_core.c file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published bydrive
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#undef VERBOSE
+
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/otg.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx_devices.h>
+#include <linux/dmapool.h>
+#include <linux/delay.h>
+
+#include <linux/io.h>
+#include <asm/byteorder.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <asm/dma.h>
+
+#include <linux/usb/xilinx_usbps_otg.h>
+
+#define	DRIVER_DESC	"Xilinx PS USB Device Controller driver"
+#define	DRIVER_AUTHOR	"Xilinx, Inc."
+#define	DRIVER_VERSION	"Apr 01, 2011"
+
+
+/* USB registers */
+#define USB_MAX_CTRL_PAYLOAD		64
+
+ /* USB DR device mode registers (Little Endian) */
+struct usb_dr_device {
+	/* Capability register */
+	u8 res1[256];
+	u16 caplength;		/* Capability Register Length */
+	u16 hciversion;		/* Host Controller Interface Version */
+	u32 hcsparams;		/* Host Controller Structual Parameters */
+	u32 hccparams;		/* Host Controller Capability Parameters */
+	u8 res2[20];
+	u32 dciversion;		/* Device Controller Interface Version */
+	u32 dccparams;		/* Device Controller Capability Parameters */
+	u8 res3[24];
+	/* Operation register */
+	u32 usbcmd;		/* USB Command Register */
+	u32 usbsts;		/* USB Status Register */
+	u32 usbintr;		/* USB Interrupt Enable Register */
+	u32 frindex;		/* Frame Index Register */
+	u8 res4[4];
+	u32 deviceaddr;		/* Device Address */
+	u32 endpointlistaddr;	/* Endpoint List Address Register */
+	u8 res5[4];
+	u32 burstsize;		/* Master Interface Data Burst Size Register */
+	u32 txttfilltuning;	/* Transmit FIFO Tuning Controls Register */
+	u8 res6[24];
+	u32 configflag;		/* Configure Flag Register */
+	u32 portsc1;		/* Port 1 Status and Control Register */
+	u8 res7[28];
+	u32 otgsc;		/* On-The-Go Status and Control */
+	u32 usbmode;		/* USB Mode Register */
+	u32 endptsetupstat;	/* Endpoint Setup Status Register */
+	u32 endpointprime;	/* Endpoint Initialization Register */
+	u32 endptflush;		/* Endpoint Flush Register */
+	u32 endptstatus;	/* Endpoint Status Register */
+	u32 endptcomplete;	/* Endpoint Complete Register */
+	u32 endptctrl[6];	/* Endpoint Control Registers */
+};
+
+/* ep0 transfer state */
+#define WAIT_FOR_SETUP          0
+#define DATA_STATE_XMIT         1
+#define WAIT_FOR_OUT_STATUS     3
+#define DATA_STATE_RECV         4
+
+/* Device Controller Capability Parameter register */
+#define DCCPARAMS_DC				0x00000080
+#define DCCPARAMS_DEN_MASK			0x0000001f
+
+/* Frame Index Register Bit Masks */
+#define	USB_FRINDEX_MASKS			0x3fff
+/* USB CMD  Register Bit Masks */
+#define  USB_CMD_RUN_STOP                     0x00000001
+#define  USB_CMD_CTRL_RESET                   0x00000002
+#define  USB_CMD_ASYNC_SCHEDULE_EN            0x00000020
+#define  USB_CMD_SUTW                         0x00002000
+#define  USB_CMD_ATDTW                        0x00004000
+
+/* USB STS Register Bit Masks */
+#define  USB_STS_INT                          0x00000001
+#define  USB_STS_ERR                          0x00000002
+#define  USB_STS_PORT_CHANGE                  0x00000004
+#define  USB_STS_SYS_ERR                      0x00000010
+#define  USB_STS_RESET                        0x00000040
+#define  USB_STS_SOF                          0x00000080
+#define  USB_STS_SUSPEND                      0x00000100
+
+/* USB INTR Register Bit Masks */
+#define  USB_INTR_INT_EN                      0x00000001
+#define  USB_INTR_ERR_INT_EN                  0x00000002
+#define  USB_INTR_PTC_DETECT_EN               0x00000004
+#define  USB_INTR_SYS_ERR_EN                  0x00000010
+#define  USB_INTR_RESET_EN                    0x00000040
+#define  USB_INTR_SOF_EN                      0x00000080
+#define  USB_INTR_DEVICE_SUSPEND              0x00000100
+
+/* Device Address bit masks */
+#define  USB_DEVICE_ADDRESS_MASK              0xFE000000
+#define  USB_DEVICE_ADDRESS_BIT_POS           25
+
+/* endpoint list address bit masks */
+#define USB_EP_LIST_ADDRESS_MASK              0xfffff800
+
+/* PORTSCX  Register Bit Masks */
+#define  PORTSCX_CURRENT_CONNECT_STATUS       0x00000001
+#define  PORTSCX_PORT_ENABLE                  0x00000004
+#define  PORTSCX_PORT_EN_DIS_CHANGE           0x00000008
+#define  PORTSCX_OVER_CURRENT_CHG             0x00000020
+#define  PORTSCX_PORT_FORCE_RESUME            0x00000040
+#define  PORTSCX_PORT_SUSPEND                 0x00000080
+#define  PORTSCX_PORT_RESET                   0x00000100
+#define  PORTSCX_PHY_LOW_POWER_SPD            0x00800000
+#define  PORTSCX_PORT_SPEED_MASK              0x0C000000
+#define  PORTSCX_PORT_WIDTH                   0x10000000
+#define  PORTSCX_PHY_TYPE_SEL                 0xC0000000
+
+/* bit 27-26 are port speed */
+#define  PORTSCX_PORT_SPEED_FULL              0x00000000
+#define  PORTSCX_PORT_SPEED_LOW               0x04000000
+#define  PORTSCX_PORT_SPEED_HIGH              0x08000000
+#define  PORTSCX_PORT_SPEED_UNDEF             0x0C000000
+
+/* bit 28 is parallel transceiver width for UTMI interface */
+#define  PORTSCX_PTW_16BIT                    0x10000000
+
+/* bit 31-30 are port transceiver select */
+#define  PORTSCX_PTS_UTMI                     0x00000000
+#define  PORTSCX_PTS_ULPI                     0x80000000
+#define  PORTSCX_PTS_FSLS                     0xC0000000
+
+/* otgsc Register Bit Masks */
+#define  OTGSC_CTRL_OTG_TERM                  0x00000008
+
+/* USB MODE Register Bit Masks */
+#define  USB_MODE_CTRL_MODE_IDLE              0x00000000
+#define  USB_MODE_CTRL_MODE_DEVICE            0x00000002
+#define  USB_MODE_CTRL_MODE_HOST              0x00000003
+#define  USB_MODE_SETUP_LOCK_OFF              0x00000008
+
+/* Endpoint Setup Status bit masks */
+#define  EP_SETUP_STATUS_MASK                 0x0000003F
+#define  EP_SETUP_STATUS_EP0		      0x00000001
+
+/* ENDPOINTCTRLx  Register Bit Masks */
+#define  EPCTRL_TX_ENABLE                     0x00800000
+#define  EPCTRL_TX_DATA_TOGGLE_RST            0x00400000	/* Not EP0 */
+#define  EPCTRL_TX_EP_STALL                   0x00010000
+#define  EPCTRL_RX_ENABLE                     0x00000080
+#define  EPCTRL_RX_DATA_TOGGLE_RST            0x00000040	/* Not EP0 */
+#define  EPCTRL_RX_EP_STALL                   0x00000001
+
+/* bit 19-18 and 3-2 are endpoint type */
+#define  EPCTRL_TX_EP_TYPE_SHIFT              18
+#define  EPCTRL_RX_EP_TYPE_SHIFT              2
+
+
+/* Endpoint Queue Head data struct
+ * Rem: all the variables of qh are LittleEndian Mode
+ * and NEXT_POINTER_MASK should operate on a LittleEndian, Phy Addr
+ */
+struct ep_queue_head {
+	u32 max_pkt_length;	/* Mult(31-30) , Zlt(29) , Max Pkt len
+				   and IOS(15) */
+	u32 curr_dtd_ptr;	/* Current dTD Pointer(31-5) */
+	u32 next_dtd_ptr;	/* Next dTD Pointer(31-5), T(0) */
+	u32 size_ioc_int_sts;	/* Total bytes (30-16), IOC (15),
+				   MultO(11-10), STS (7-0)  */
+	u32 buff_ptr0;		/* Buffer pointer Page 0 (31-12) */
+	u32 buff_ptr1;		/* Buffer pointer Page 1 (31-12) */
+	u32 buff_ptr2;		/* Buffer pointer Page 2 (31-12) */
+	u32 buff_ptr3;		/* Buffer pointer Page 3 (31-12) */
+	u32 buff_ptr4;		/* Buffer pointer Page 4 (31-12) */
+	u32 res1;
+	u8 setup_buffer[8];	/* Setup data 8 bytes */
+	u32 res2[4];
+};
+
+/* Endpoint Queue Head Bit Masks */
+#define  EP_QUEUE_HEAD_MULT_POS               30
+#define  EP_QUEUE_HEAD_ZLT_SEL                0x20000000
+#define  EP_QUEUE_HEAD_MAX_PKT_LEN_POS        16
+#define  EP_QUEUE_HEAD_IOS                    0x00008000
+#define  EP_QUEUE_HEAD_STATUS_HALT	      0x00000040
+#define  EP_QUEUE_HEAD_STATUS_ACTIVE          0x00000080
+#define  EP_QUEUE_HEAD_NEXT_POINTER_MASK      0xFFFFFFE0
+#define  EP_MAX_LENGTH_TRANSFER               0x4000
+
+/* Endpoint Transfer Descriptor data struct */
+/* Rem: all the variables of td are LittleEndian Mode */
+struct ep_td_struct {
+	u32 next_td_ptr;	/* Next TD pointer(31-5), T(0) set
+				   indicate invalid */
+	u32 size_ioc_sts;	/* Total bytes (30-16), IOC (15),
+				   MultO(11-10), STS (7-0)  */
+	u32 buff_ptr0;		/* Buffer pointer Page 0 */
+	u32 buff_ptr1;		/* Buffer pointer Page 1 */
+	u32 buff_ptr2;		/* Buffer pointer Page 2 */
+	u32 buff_ptr3;		/* Buffer pointer Page 3 */
+	u32 buff_ptr4;		/* Buffer pointer Page 4 */
+	u32 res;
+	/* 32 bytes */
+	dma_addr_t td_dma;	/* dma address for this td */
+	/* virtual address of next td specified in next_td_ptr */
+	struct ep_td_struct *next_td_virt;
+};
+
+/* Endpoint Transfer Descriptor bit Masks */
+#define  DTD_NEXT_TERMINATE                   0x00000001
+#define  DTD_IOC                              0x00008000
+#define  DTD_STATUS_ACTIVE                    0x00000080
+#define  DTD_STATUS_HALTED                    0x00000040
+#define  DTD_STATUS_DATA_BUFF_ERR             0x00000020
+#define  DTD_STATUS_TRANSACTION_ERR           0x00000008
+#define  DTD_RESERVED_FIELDS                  0x80007300
+#define  DTD_ADDR_MASK                        0xFFFFFFE0
+#define  DTD_PACKET_SIZE                      0x7FFF0000
+#define  DTD_LENGTH_BIT_POS                   16
+#define  DTD_ERROR_MASK                       (DTD_STATUS_HALTED | \
+					DTD_STATUS_DATA_BUFF_ERR | \
+					DTD_STATUS_TRANSACTION_ERR)
+/* Alignment requirements; must be a power of two */
+#define DTD_ALIGNMENT				0x20
+#define QH_ALIGNMENT				2048
+
+/* Controller dma boundary */
+#define UDC_DMA_BOUNDARY			0x1000
+
+/*-------------------------------------------------------------------------*/
+
+/* ### driver private data
+ */
+struct xusbps_req {
+	struct usb_request req;
+	struct list_head queue;
+	/* ep_queue() func will add
+	   a request->queue into a udc_ep->queue 'd tail */
+	struct xusbps_ep *ep;
+	unsigned mapped:1;
+
+	struct ep_td_struct *head, *tail;	/* For dTD List
+						   cpu endian Virtual addr */
+	unsigned int dtd_count;
+};
+
+#define REQ_UNCOMPLETE			1
+
+struct xusbps_ep {
+	struct usb_ep ep;
+	struct list_head queue;
+	struct xusbps_udc *udc;
+	struct ep_queue_head *qh;
+	struct usb_gadget *gadget;
+
+	char name[14];
+	unsigned stopped:1;
+	unsigned int wedge;
+};
+
+#define EP_DIR_IN	1
+#define EP_DIR_OUT	0
+
+struct xusbps_udc {
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct completion *done;	/* to make sure release() is done */
+	struct xusbps_ep *eps;
+	unsigned int max_ep;
+	unsigned int irq;
+
+	/* xusbps otg transceiver */
+	struct xusbps_otg	*xotg;
+
+	struct usb_ctrlrequest local_setup_buff;
+	spinlock_t lock;
+	struct usb_phy *transceiver;
+	unsigned softconnect:1;
+	unsigned vbus_active:1;
+	unsigned stopped:1;
+	unsigned remote_wakeup:1;
+
+	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
+	struct xusbps_req *status_req;	/* ep0 status request */
+	struct dma_pool *td_pool;	/* dma pool for DTD */
+	enum xusbps_usb2_phy_modes phy_mode;
+
+	size_t ep_qh_size;		/* size after alignment adjustment*/
+	dma_addr_t ep_qh_dma;		/* dma address of QH */
+
+	u32 max_pipes;          /* Device max pipes */
+	u32 resume_state;	/* USB state to resume */
+	u32 usb_state;		/* USB current state */
+	u32 ep0_state;		/* Endpoint zero state */
+	u32 ep0_dir;		/* Endpoint zero direction: can be
+				   USB_DIR_IN or USB_DIR_OUT */
+	u8 device_address;	/* Device USB address */
+};
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+#define DBG(fmt, args...)	pr_debug("[%s]  " fmt "\n", \
+				__func__, ## args)
+#else
+#define DBG(fmt, args...)	do {} while (0)
+#endif
+
+
+#ifdef VERBOSE
+#define VDBG		DBG
+#else
+#define VDBG(stuff...)	do {} while (0)
+#endif
+
+#define ERR(stuff...)		pr_err("udc: " stuff)
+#define WARNING(stuff...)		pr_warn("udc: " stuff)
+#define INFO(stuff...)		pr_info("udc: " stuff)
+
+/*-------------------------------------------------------------------------*/
+
+/* ### Add board specific defines here */
+
+/* pipe direction macro from device view */
+#define USB_RECV	0	/* OUT EP */
+#define USB_SEND	1	/* IN EP */
+
+/* internal used help routines. */
+#define ep_index(EP)		((EP)->ep.desc->bEndpointAddress&0xF)
+#define ep_maxpacket(EP)	((EP)->ep.maxpacket)
+#define ep_is_in(EP)	((ep_index(EP) == 0) ? (EP->udc->ep0_dir == \
+			USB_DIR_IN) : ((EP)->ep.desc->bEndpointAddress \
+			& USB_DIR_IN) == USB_DIR_IN)
+#define get_ep_by_pipe(udc, pipe)	((pipe == 1) ? &udc->eps[0] : \
+					&udc->eps[pipe])
+#define get_pipe_by_windex(windex)	((windex & USB_ENDPOINT_NUMBER_MASK) \
+					* 2 + ((windex & USB_DIR_IN) ? 1 : 0))
+
+
+static int xusbps_udc_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		/* if a rate change is announced we need to check whether we can
+		 * maintain the current frequency by changing the clock
+		 * dividers.
+		 */
+		/* fall through */
+	case POST_RATE_CHANGE:
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static int xusbps_udc_clk_init(struct platform_device *pdev)
+{
+	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+	int rc;
+
+	if (pdata->irq == 53)
+		pdata->clk = clk_get_sys("USB0_APER", NULL);
+	else
+		pdata->clk = clk_get_sys("USB1_APER", NULL);
+	if (IS_ERR(pdata->clk)) {
+		dev_err(&pdev->dev, "APER clock not found.\n");
+		return PTR_ERR(pdata->clk);
+	}
+
+	rc = clk_prepare_enable(pdata->clk);
+	if (rc) {
+		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
+		goto err_out_clk_put;
+	}
+
+	pdata->clk_rate_change_nb.notifier_call = xusbps_udc_clk_notifier_cb;
+	pdata->clk_rate_change_nb.next = NULL;
+	if (clk_notifier_register(pdata->clk, &pdata->clk_rate_change_nb))
+		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
+
+	return 0;
+
+err_out_clk_put:
+	clk_put(pdata->clk);
+
+	return rc;
+}
+
+static void xusbps_udc_clk_release(struct platform_device *pdev)
+{
+	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	clk_disable_unprepare(pdata->clk);
+	clk_put(pdata->clk);
+}
+
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+
+static const char driver_name[] = "xusbps-udc";
+static const char driver_desc[] = DRIVER_DESC;
+
+static struct usb_dr_device *dr_regs;
+
+/* it is initialized in probe()  */
+static struct xusbps_udc *udc_controller;
+
+static const struct usb_endpoint_descriptor
+xusbps_ep0_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	0,
+	.bmAttributes =		USB_ENDPOINT_XFER_CONTROL,
+	.wMaxPacketSize =	USB_MAX_CTRL_PAYLOAD,
+};
+
+static void xusbps_ep_fifo_flush(struct usb_ep *_ep);
+
+#define xusbps_readl(addr)		readl(addr)
+#define xusbps_writel(val32, addr) writel(val32, addr)
+
+/********************************************************************
+ *	Internal Used Function
+********************************************************************/
+/*-----------------------------------------------------------------
+ * done() - retire a request; caller blocked irqs
+ * @status : request status to be set, only works when
+ *	request is still in progress.
+ *--------------------------------------------------------------*/
+static void done(struct xusbps_ep *ep, struct xusbps_req *req, int status)
+{
+	struct xusbps_udc *udc = NULL;
+	unsigned char stopped = ep->stopped;
+	struct ep_td_struct *curr_td, *next_td;
+	int j;
+
+	udc = (struct xusbps_udc *)ep->udc;
+	/* Removed the req from xusbps_ep->queue */
+	list_del_init(&req->queue);
+
+	/* req.status should be set as -EINPROGRESS in ep_queue() */
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	/* Free dtd for the request */
+	next_td = req->head;
+	for (j = 0; j < req->dtd_count; j++) {
+		curr_td = next_td;
+		if (j != req->dtd_count - 1)
+			next_td = curr_td->next_td_virt;
+		dma_pool_free(udc->td_pool, curr_td, curr_td->td_dma);
+	}
+
+	if (req->mapped) {
+		dma_unmap_single(ep->udc->gadget.dev.parent,
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	} else
+		dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+			req->req.dma, req->req.length,
+			ep_is_in(ep)
+				? DMA_TO_DEVICE
+				: DMA_FROM_DEVICE);
+
+	if (status && (status != -ESHUTDOWN))
+		VDBG("complete %s req %p stat %d len %u/%u",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length);
+
+	ep->stopped = 1;
+
+	spin_unlock(&ep->udc->lock);
+	/* complete() is from gadget layer,
+	 * eg fsg->bulk_in_complete() */
+	if (req->req.complete)
+		req->req.complete(&ep->ep, &req->req);
+
+	spin_lock(&ep->udc->lock);
+	ep->stopped = stopped;
+}
+
+/*-----------------------------------------------------------------
+ * nuke(): delete all requests related to this ep
+ * called with spinlock held
+ *--------------------------------------------------------------*/
+static void nuke(struct xusbps_ep *ep, int status)
+{
+	ep->stopped = 1;
+
+	/* Flush fifo */
+	xusbps_ep_fifo_flush(&ep->ep);
+
+	/* Whether this eq has request linked */
+	while (!list_empty(&ep->queue)) {
+		struct xusbps_req *req = NULL;
+
+		req = list_entry(ep->queue.next, struct xusbps_req, queue);
+		done(ep, req, status);
+	}
+}
+
+/*------------------------------------------------------------------
+	Internal Hardware related function
+ ------------------------------------------------------------------*/
+
+static int dr_controller_setup(struct xusbps_udc *udc)
+{
+	unsigned int tmp, portctrl;
+	unsigned long timeout;
+#define XUSBPS_UDC_RESET_TIMEOUT 1000
+
+	/* Config PHY interface */
+	portctrl = xusbps_readl(&dr_regs->portsc1);
+	portctrl &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PORT_WIDTH);
+	switch (udc->phy_mode) {
+	case XUSBPS_USB2_PHY_ULPI:
+		portctrl |= PORTSCX_PTS_ULPI;
+		break;
+	case XUSBPS_USB2_PHY_UTMI_WIDE:
+		portctrl |= PORTSCX_PTW_16BIT;
+		/* fall through */
+	case XUSBPS_USB2_PHY_UTMI:
+		portctrl |= PORTSCX_PTS_UTMI;
+		break;
+	case XUSBPS_USB2_PHY_SERIAL:
+		portctrl |= PORTSCX_PTS_FSLS;
+		break;
+	default:
+		return -EINVAL;
+	}
+	xusbps_writel(portctrl, &dr_regs->portsc1);
+
+	/* Stop and reset the usb controller */
+	tmp = xusbps_readl(&dr_regs->usbcmd);
+	tmp &= ~USB_CMD_RUN_STOP;
+	xusbps_writel(tmp, &dr_regs->usbcmd);
+
+	tmp = xusbps_readl(&dr_regs->usbcmd);
+	tmp |= USB_CMD_CTRL_RESET;
+	xusbps_writel(tmp, &dr_regs->usbcmd);
+
+	/* Wait for reset to complete */
+	timeout = jiffies + XUSBPS_UDC_RESET_TIMEOUT;
+	while (xusbps_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {
+		if (time_after(jiffies, timeout)) {
+			ERR("udc reset timeout!\n");
+			return -ETIMEDOUT;
+		}
+		cpu_relax();
+	}
+
+	/* Set the controller as device mode */
+	tmp = xusbps_readl(&dr_regs->usbmode);
+	tmp |= USB_MODE_CTRL_MODE_DEVICE;
+	/* Disable Setup Lockout */
+	tmp |= USB_MODE_SETUP_LOCK_OFF;
+	xusbps_writel(tmp, &dr_regs->usbmode);
+
+	/* Set OTG Terminate bit */
+	tmp = xusbps_readl(&dr_regs->otgsc);
+	tmp |= OTGSC_CTRL_OTG_TERM;
+	xusbps_writel(tmp, &dr_regs->otgsc);
+
+	/* Clear the setup status */
+	xusbps_writel(0, &dr_regs->usbsts);
+
+	tmp = udc->ep_qh_dma;
+	tmp &= USB_EP_LIST_ADDRESS_MASK;
+	xusbps_writel(tmp, &dr_regs->endpointlistaddr);
+
+	VDBG("vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x",
+		udc->ep_qh, (int)tmp,
+		xusbps_readl(&dr_regs->endpointlistaddr));
+
+	return 0;
+}
+
+/* Enable DR irq and set controller to run state */
+static void dr_controller_run(struct xusbps_udc *udc)
+{
+	u32 temp;
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (gadget_is_otg(&udc->gadget)) {
+		/* Enable DR irq reg except suspend interrupt */
+		temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+			| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+			| USB_INTR_SYS_ERR_EN;
+	} else {
+		/* Enable DR irq reg */
+		temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+			| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+			| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
+	}
+#else
+	/* Enable DR irq reg */
+	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+		| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+		| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
+#endif
+
+	xusbps_writel(temp, &dr_regs->usbintr);
+
+	/*
+	 * Enable disconnect notification using B session end interrupt.
+	 * This is a SW workaround for USB disconnect detection as mentioned
+	 * in AR# 47538
+	 */
+	if (!gadget_is_otg(&udc->gadget)) {
+		temp = xusbps_readl(&dr_regs->otgsc);
+		temp |= OTGSC_BSEIE;
+		xusbps_writel(temp, &dr_regs->otgsc);
+	}
+
+	/* Clear stopped bit */
+	udc->stopped = 0;
+
+	/* Set the controller as device mode */
+	temp = xusbps_readl(&dr_regs->usbmode);
+	temp |= USB_MODE_CTRL_MODE_DEVICE;
+	temp |= USB_MODE_SETUP_LOCK_OFF;
+	xusbps_writel(temp, &dr_regs->usbmode);
+
+	/* Set OTG Terminate bit */
+	temp = xusbps_readl(&dr_regs->otgsc);
+	temp |= OTGSC_CTRL_OTG_TERM;
+	xusbps_writel(temp, &dr_regs->otgsc);
+
+	/* Set controller to Run */
+	temp = xusbps_readl(&dr_regs->usbcmd);
+	temp |= USB_CMD_RUN_STOP;
+	xusbps_writel(temp, &dr_regs->usbcmd);
+}
+
+static void dr_controller_stop(struct xusbps_udc *udc)
+{
+	unsigned int tmp;
+
+	/* disable all INTR */
+	xusbps_writel(0, &dr_regs->usbintr);
+
+	/* Set stopped bit for isr */
+	udc->stopped = 1;
+
+	/* disable IO output */
+/*	usb_sys_regs->control = 0; */
+
+	/* set controller to Stop */
+	tmp = xusbps_readl(&dr_regs->usbcmd);
+	tmp &= ~USB_CMD_RUN_STOP;
+	xusbps_writel(tmp, &dr_regs->usbcmd);
+}
+
+static void dr_ep_setup(unsigned char ep_num, unsigned char dir,
+			unsigned char ep_type)
+{
+	unsigned int tmp_epctrl = 0;
+
+	tmp_epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	if (dir) {
+		if (ep_num)
+			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
+		tmp_epctrl |= EPCTRL_TX_ENABLE;
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_TX_EP_TYPE_SHIFT);
+	} else {
+		if (ep_num)
+			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
+		tmp_epctrl |= EPCTRL_RX_ENABLE;
+		tmp_epctrl |= ((unsigned int)(ep_type)
+				<< EPCTRL_RX_EP_TYPE_SHIFT);
+	}
+
+	xusbps_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+}
+
+static void
+dr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)
+{
+	u32 tmp_epctrl = 0;
+
+	tmp_epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+
+	if (value) {
+		/* set the stall bit */
+		if (dir)
+			tmp_epctrl |= EPCTRL_TX_EP_STALL;
+		else
+			tmp_epctrl |= EPCTRL_RX_EP_STALL;
+	} else {
+		/* clear the stall bit and reset data toggle */
+		if (dir) {
+			tmp_epctrl &= ~EPCTRL_TX_EP_STALL;
+			tmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
+		} else {
+			tmp_epctrl &= ~EPCTRL_RX_EP_STALL;
+			tmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
+		}
+	}
+	xusbps_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);
+}
+
+/* Get stall status of a specific ep
+   Return: 0: not stalled; 1:stalled */
+static int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)
+{
+	u32 epctrl;
+
+	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	if (dir)
+		return (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;
+	else
+		return (epctrl & EPCTRL_RX_EP_STALL) ? 1 : 0;
+}
+
+/********************************************************************
+	Internal Structure Build up functions
+********************************************************************/
+
+/*------------------------------------------------------------------
+* struct_ep_qh_setup(): set the Endpoint Capabilites field of QH
+ * @zlt: Zero Length Termination Select (1: disable; 0: enable)
+ * @mult: Mult field
+ ------------------------------------------------------------------*/
+static void struct_ep_qh_setup(struct xusbps_udc *udc, unsigned char ep_num,
+		unsigned char dir, unsigned char ep_type,
+		unsigned int max_pkt_len,
+		unsigned int zlt, unsigned char mult)
+{
+	struct ep_queue_head *p_QH = &udc->ep_qh[2 * ep_num + dir];
+	unsigned int tmp = 0;
+
+	/* set the Endpoint Capabilites in QH */
+	switch (ep_type) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		/* Interrupt On Setup (IOS). for control ep  */
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| EP_QUEUE_HEAD_IOS;
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		tmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
+			| (mult << EP_QUEUE_HEAD_MULT_POS);
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+		tmp = max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS;
+		break;
+	default:
+		VDBG("error ep type is %d", ep_type);
+		return;
+	}
+	if (zlt)
+		tmp |= EP_QUEUE_HEAD_ZLT_SEL;
+
+	p_QH->max_pkt_length = cpu_to_le32(tmp);
+	p_QH->next_dtd_ptr = 1;
+	p_QH->size_ioc_int_sts = 0;
+}
+
+/* Setup qh structure and ep register for ep0. */
+static void ep0_setup(struct xusbps_udc *udc)
+{
+	/* the intialization of an ep includes: fields in QH, Regs,
+	 * xusbps_ep struct */
+	/*
+	 * For control OUT endpoint, don't need to wait for zlp from host
+	 * (see usb 2.0 spec, section 5.5.3)
+	 */
+	struct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 1, 0);
+	struct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,
+			USB_MAX_CTRL_PAYLOAD, 0, 0);
+	dr_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);
+	dr_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);
+
+	return;
+
+}
+
+/***********************************************************************
+		Endpoint Management Functions
+***********************************************************************/
+
+/*-------------------------------------------------------------------------
+ * when configurations are set, or when interface settings change
+ * for example the do_set_interface() in gadget layer,
+ * the driver will enable or disable the relevant endpoints
+ * ep0 doesn't use this routine. It is always enabled.
+-------------------------------------------------------------------------*/
+static int xusbps_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct xusbps_udc *udc = NULL;
+	struct xusbps_ep *ep = NULL;
+	unsigned short max = 0;
+	unsigned char mult = 0, zlt;
+	int retval = -EINVAL;
+	unsigned long flags = 0;
+
+	ep = container_of(_ep, struct xusbps_ep, ep);
+
+	/* catch various bogus parameters */
+	if (!_ep || !desc
+			|| (desc->bDescriptorType != USB_DT_ENDPOINT))
+		return -EINVAL;
+
+	udc = ep->udc;
+
+	if (!udc->driver || (udc->gadget.speed == USB_SPEED_UNKNOWN))
+		return -ESHUTDOWN;
+
+	max = usb_endpoint_maxp(desc);
+
+	/* Disable automatic zlp generation.  Driver is reponsible to indicate
+	 * explicitly through req->req.zero.  This is needed to enable multi-td
+	 * request. */
+	zlt = 1;
+
+	/* Assume the max packet size from gadget is always correct */
+	switch (desc->bmAttributes & 0x03) {
+	case USB_ENDPOINT_XFER_CONTROL:
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+		/* mult = 0.  Execute N Transactions as demonstrated by
+		 * the USB variable length packet protocol where N is
+		 * computed using the Maximum Packet Length (dQH) and
+		 * the Total Bytes field (dTD) */
+		mult = 0;
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		/* Calculate transactions needed for high bandwidth iso */
+		mult = (unsigned char)(1 + ((max >> 11) & 0x03));
+		max = max & 0x7ff;	/* bit 0~10 */
+		/* 3 transactions at most */
+		if (mult > 3)
+			goto en_done;
+		break;
+	default:
+		goto en_done;
+	}
+
+	spin_lock_irqsave(&udc->lock, flags);
+	ep->ep.maxpacket = max;
+	ep->ep.desc = desc;
+	ep->stopped = 0;
+	ep->wedge = 0;
+
+	/* Controller related setup */
+	/* Init EPx Queue Head (Ep Capabilites field in QH
+	 * according to max, zlt, mult) */
+	struct_ep_qh_setup(udc, (unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					?  USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK),
+			max, zlt, mult);
+
+	/* Init endpoint ctrl register */
+	dr_ep_setup((unsigned char) ep_index(ep),
+			(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)
+					? USB_SEND : USB_RECV),
+			(unsigned char) (desc->bmAttributes
+					& USB_ENDPOINT_XFERTYPE_MASK));
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	retval = 0;
+
+	VDBG("enabled %s (ep%d%s) maxpacket %d", ep->ep.name,
+			ep->ep.desc->bEndpointAddress & 0x0f,
+			(desc->bEndpointAddress & USB_DIR_IN)
+				? "in" : "out", max);
+en_done:
+	return retval;
+}
+
+/*---------------------------------------------------------------------
+ * @ep : the ep being unconfigured. May not be ep0
+ * Any pending and uncomplete req will complete with status (-ESHUTDOWN)
+*---------------------------------------------------------------------*/
+static int xusbps_ep_disable(struct usb_ep *_ep)
+{
+	struct xusbps_udc *udc = NULL;
+	struct xusbps_ep *ep = NULL;
+	unsigned long flags = 0;
+	u32 epctrl;
+	int ep_num;
+
+	ep = container_of(_ep, struct xusbps_ep, ep);
+	if (!_ep || !ep->ep.desc) {
+		VDBG("%s not enabled", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	/* disable ep on controller */
+	ep_num = ep_index(ep);
+	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	xusbps_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+
+	udc = (struct xusbps_udc *)ep->udc;
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* nuke all pending requests (does flush) */
+	nuke(ep, -ESHUTDOWN);
+
+	ep->ep.desc = NULL;
+	ep->stopped = 1;
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	VDBG("disabled %s OK", _ep->name);
+	return 0;
+}
+
+/*---------------------------------------------------------------------
+ * allocate a request object used by this endpoint
+ * the main operation is to insert the req->queue to the eq->queue
+ * Returns the request, or null if one could not be allocated
+*---------------------------------------------------------------------*/
+static struct usb_request *
+xusbps_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct xusbps_req *req = NULL;
+
+	req = kzalloc(sizeof *req, gfp_flags);
+	if (!req)
+		return NULL;
+
+	req->req.dma = DMA_ADDR_INVALID;
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void xusbps_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct xusbps_req *req = NULL;
+
+	req = container_of(_req, struct xusbps_req, req);
+
+	if (_req)
+		kfree(req);
+}
+
+/*-------------------------------------------------------------------------*/
+static void xusbps_queue_td(struct xusbps_ep *ep, struct xusbps_req *req)
+{
+	int i = ep_index(ep) * 2 + ep_is_in(ep);
+	u32 temp, bitmask, tmp_stat;
+	struct ep_queue_head *dQH = &ep->udc->ep_qh[i];
+
+	/* VDBG("QH addr Register 0x%8x", dr_regs->endpointlistaddr);
+	VDBG("ep_qh[%d] addr is 0x%8x", i, (u32)&(ep->udc->ep_qh[i])); */
+
+	bitmask = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
+
+	/* check if the pipe is empty */
+	if (!(list_empty(&ep->queue))) {
+		/* Add td to the end */
+		struct xusbps_req *lastreq;
+		lastreq = list_entry(ep->queue.prev, struct xusbps_req, queue);
+		lastreq->tail->next_td_ptr =
+			cpu_to_le32(req->head->td_dma & DTD_ADDR_MASK);
+		wmb();
+		/* Read prime bit, if 1 goto done */
+		if (xusbps_readl(&dr_regs->endpointprime) & bitmask)
+			goto out;
+
+		do {
+			/* Set ATDTW bit in USBCMD */
+			temp = xusbps_readl(&dr_regs->usbcmd);
+			xusbps_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);
+
+			/* Read correct status bit */
+			tmp_stat = xusbps_readl(&dr_regs->endptstatus) &
+				bitmask;
+
+#ifdef CONFIG_XUSBPS_ERRATA_DT654401
+			/* Workaround for USB errata DT# 654401 */
+			temp = xusbps_readl(&dr_regs->usbcmd);
+			if (temp & USB_CMD_ATDTW) {
+				udelay(5);
+				if (xusbps_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW)
+					break;
+			}
+		} while (1);
+#else
+		} while (!(xusbps_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));
+#endif
+
+		/* Write ATDTW bit to 0 */
+		temp = xusbps_readl(&dr_regs->usbcmd);
+		xusbps_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);
+
+		if (tmp_stat)
+			goto out;
+	}
+
+	/* Write dQH next pointer and terminate bit to 0 */
+	temp = req->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;
+	dQH->next_dtd_ptr = cpu_to_le32(temp);
+
+	/* Clear active and halt bit */
+	temp = cpu_to_le32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
+			| EP_QUEUE_HEAD_STATUS_HALT));
+	dQH->size_ioc_int_sts &= temp;
+
+	/* Ensure that updates to the QH will occure before priming. */
+	wmb();
+
+	/* Prime endpoint by writing 1 to ENDPTPRIME */
+	temp = ep_is_in(ep)
+		? (1 << (ep_index(ep) + 16))
+		: (1 << (ep_index(ep)));
+	xusbps_writel(temp, &dr_regs->endpointprime);
+out:
+	return;
+}
+
+/* Fill in the dTD structure
+ * @req: request that the transfer belongs to
+ * @length: return actually data length of the dTD
+ * @dma: return dma address of the dTD
+ * @is_last: return flag if it is the last dTD of the request
+ * return: pointer to the built dTD */
+static struct ep_td_struct *xusbps_build_dtd(struct xusbps_req *req, unsigned
+		*length, dma_addr_t *dma, int *is_last)
+{
+	u32 swap_temp;
+	struct ep_td_struct *dtd;
+
+	/* how big will this transfer be? */
+	*length = min(req->req.length - req->req.actual,
+			(unsigned)EP_MAX_LENGTH_TRANSFER);
+
+	dtd = dma_pool_alloc(udc_controller->td_pool, GFP_ATOMIC, dma);
+	if (dtd == NULL)
+		return dtd;
+
+	dtd->td_dma = *dma;
+	/* Clear reserved field */
+	swap_temp = cpu_to_le32(dtd->size_ioc_sts);
+	swap_temp &= ~DTD_RESERVED_FIELDS;
+	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+
+	/* Init all of buffer page pointers */
+	swap_temp = (u32) (req->req.dma + req->req.actual);
+	dtd->buff_ptr0 = cpu_to_le32(swap_temp);
+	dtd->buff_ptr1 = cpu_to_le32(swap_temp + 0x1000);
+	dtd->buff_ptr2 = cpu_to_le32(swap_temp + 0x2000);
+	dtd->buff_ptr3 = cpu_to_le32(swap_temp + 0x3000);
+	dtd->buff_ptr4 = cpu_to_le32(swap_temp + 0x4000);
+
+	req->req.actual += *length;
+
+	/* zlp is needed if req->req.zero is set */
+	if (req->req.zero) {
+		/*
+		 * There is no need for a separate zlp dtd for control IN
+		 * endpoint. The ZLT bit in dQH takes care.
+		 */
+		if ((ep_index(req->ep) == 0) &&
+				(req->req.length == req->req.actual) &&
+				!(req->req.length % req->ep->ep.maxpacket))
+			*is_last = 1;
+		else if (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)
+			*is_last = 1;
+		else
+			*is_last = 0;
+	} else if (req->req.length == req->req.actual)
+		*is_last = 1;
+	else
+		*is_last = 0;
+
+	if ((*is_last) == 0)
+		VDBG("multi-dtd request!");
+	/* Fill in the transfer size; set active bit */
+	swap_temp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);
+
+	/* Enable interrupt for the last dtd of a request */
+	if (*is_last && !req->req.no_interrupt)
+		swap_temp |= DTD_IOC;
+
+	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+
+	mb();
+
+	VDBG("length = %d address= 0x%x", *length, (int)*dma);
+
+	return dtd;
+}
+
+/* Generate dtd chain for a request */
+static int xusbps_req_to_dtd(struct xusbps_req *req)
+{
+	unsigned	count;
+	int		is_last;
+	int		is_first = 1;
+	struct ep_td_struct	*last_dtd = NULL, *dtd;
+	dma_addr_t dma;
+
+	do {
+		dtd = xusbps_build_dtd(req, &count, &dma, &is_last);
+		if (dtd == NULL)
+			return -ENOMEM;
+
+		if (is_first) {
+			is_first = 0;
+			req->head = dtd;
+		} else {
+			last_dtd->next_td_ptr = cpu_to_le32(dma);
+			last_dtd->next_td_virt = dtd;
+		}
+		last_dtd = dtd;
+
+		req->dtd_count++;
+	} while (!is_last);
+
+	dtd->next_td_ptr = cpu_to_le32(DTD_NEXT_TERMINATE);
+
+	mb();
+	req->tail = dtd;
+
+	return 0;
+}
+
+/* queues (submits) an I/O request to an endpoint */
+static int
+xusbps_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct xusbps_ep *ep = container_of(_ep, struct xusbps_ep, ep);
+	struct xusbps_req *req = container_of(_req, struct xusbps_req, req);
+	struct xusbps_udc *udc;
+	unsigned long flags;
+
+	/* catch various bogus parameters */
+	if (!_req || !req->req.complete || !req->req.buf
+			|| !list_empty(&req->queue)) {
+		VDBG("%s, bad params", __func__);
+		return -EINVAL;
+	}
+	if (unlikely(!_ep || !ep->ep.desc)) {
+		VDBG("%s, bad ep", __func__);
+		return -EINVAL;
+	}
+	if (usb_endpoint_xfer_isoc(ep->ep.desc)) {
+		if (req->req.length > ep->ep.maxpacket)
+			return -EMSGSIZE;
+	}
+
+	udc = ep->udc;
+	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	req->ep = ep;
+
+	/* map virtual address to hardware */
+	if (req->req.dma == DMA_ADDR_INVALID) {
+		req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
+					req->req.buf,
+					req->req.length, ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
+		req->mapped = 1;
+	} else {
+		dma_sync_single_for_device(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length,
+					ep_is_in(ep)
+						? DMA_TO_DEVICE
+						: DMA_FROM_DEVICE);
+		req->mapped = 0;
+	}
+
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->dtd_count = 0;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* build dtds and push them to device queue */
+	if (!xusbps_req_to_dtd(req)) {
+		xusbps_queue_td(ep, req);
+	} else {
+		spin_unlock_irqrestore(&udc->lock, flags);
+		return -ENOMEM;
+	}
+
+	/* Update ep0 state */
+	if ((ep_index(ep) == 0))
+		udc->ep0_state = DATA_STATE_XMIT;
+
+	/* irq handler advances the queue */
+	if (req != NULL)
+		list_add_tail(&req->queue, &ep->queue);
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+/* dequeues (cancels, unlinks) an I/O request from an endpoint */
+static int xusbps_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct xusbps_ep *ep = container_of(_ep, struct xusbps_ep, ep);
+	struct xusbps_req *req;
+	unsigned long flags;
+	int ep_num, stopped, ret = 0;
+	u32 epctrl;
+
+	if (!_ep || !_req)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	stopped = ep->stopped;
+
+	/* Stop the ep before we deal with the queue */
+	ep->stopped = 1;
+	ep_num = ep_index(ep);
+	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+	xusbps_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* The request is in progress, or completed but not dequeued */
+	if (ep->queue.next == &req->queue) {
+		_req->status = -ECONNRESET;
+		xusbps_ep_fifo_flush(_ep);	/* flush current transfer */
+
+		/* The request isn't the last request in this ep queue */
+		if (req->queue.next != &ep->queue) {
+			struct ep_queue_head *qh;
+			struct xusbps_req *next_req;
+
+			qh = ep->qh;
+			next_req = list_entry(req->queue.next, struct
+					xusbps_req, queue);
+
+			/* Point the QH to the first TD of next request */
+			xusbps_writel((u32) next_req->head, &qh->curr_dtd_ptr);
+		}
+
+		/* The request hasn't been processed, patch up the TD chain */
+	} else {
+		struct xusbps_req *prev_req;
+
+		prev_req = list_entry(req->queue.prev, struct xusbps_req,
+				queue);
+		xusbps_writel(xusbps_readl(&req->tail->next_td_ptr),
+				&prev_req->tail->next_td_ptr);
+
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	/* Enable EP */
+out:	epctrl = xusbps_readl(&dr_regs->endptctrl[ep_num]);
+	if (ep_is_in(ep))
+		epctrl |= EPCTRL_TX_ENABLE;
+	else
+		epctrl |= EPCTRL_RX_ENABLE;
+	xusbps_writel(epctrl, &dr_regs->endptctrl[ep_num]);
+	ep->stopped = stopped;
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------
+ * modify the endpoint halt feature
+ * @ep: the non-isochronous endpoint being stalled
+ * @value: 1--set halt  0--clear halt
+ * Returns zero, or a negative error code.
+*----------------------------------------------------------------*/
+static int xusbps_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct xusbps_ep *ep = NULL;
+	unsigned long flags = 0;
+	int status = -EOPNOTSUPP;	/* operation not supported */
+	unsigned char ep_dir = 0, ep_num = 0;
+	struct xusbps_udc *udc = NULL;
+
+	ep = container_of(_ep, struct xusbps_ep, ep);
+	udc = ep->udc;
+	if (!_ep || !ep->ep.desc) {
+		status = -EINVAL;
+		goto out;
+	}
+
+	if (usb_endpoint_xfer_isoc(ep->ep.desc)) {
+		status = -EOPNOTSUPP;
+		goto out;
+	}
+
+	/* Attempt to halt IN ep will fail if any transfer requests
+	 * are still queue */
+	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
+		status = -EAGAIN;
+		goto out;
+	}
+
+	status = 0;
+	ep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;
+	ep_num = (unsigned char)(ep_index(ep));
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	if (!value)
+		ep->wedge = 0;
+	dr_ep_change_stall(ep_num, ep_dir, value);
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	if (ep_index(ep) == 0) {
+		udc->ep0_state = WAIT_FOR_SETUP;
+		udc->ep0_dir = 0;
+	}
+out:
+	VDBG(" %s %s halt stat %d", ep->ep.name,
+			value ?  "set" : "clear", status);
+
+	return status;
+}
+
+static int xusbps_ep_set_wedge(struct usb_ep *_ep)
+{
+	struct xusbps_ep *ep = NULL;
+	unsigned long flags = 0;
+
+	ep = container_of(_ep, struct xusbps_ep, ep);
+
+	if (!ep || !ep->ep.desc)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+	ep->wedge = 1;
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	return usb_ep_set_halt(_ep);
+}
+
+static void xusbps_ep_fifo_flush(struct usb_ep *_ep)
+{
+	struct xusbps_ep *ep;
+	int ep_num, ep_dir;
+	u32 bits;
+	unsigned long timeout;
+#define XUSBPS_UDC_FLUSH_TIMEOUT 1000
+
+	if (!_ep) {
+		return;
+	} else {
+		ep = container_of(_ep, struct xusbps_ep, ep);
+		if (!ep->ep.desc)
+			return;
+	}
+	ep_num = ep_index(ep);
+	ep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;
+
+	if (ep_num == 0)
+		bits = (1 << 16) | 1;
+	else if (ep_dir == USB_SEND)
+		bits = 1 << (16 + ep_num);
+	else
+		bits = 1 << ep_num;
+
+	timeout = jiffies + XUSBPS_UDC_FLUSH_TIMEOUT;
+	do {
+		xusbps_writel(bits, &dr_regs->endptflush);
+
+		/* Wait until flush complete */
+		while (xusbps_readl(&dr_regs->endptflush)) {
+			if (time_after(jiffies, timeout)) {
+				ERR("ep flush timeout\n");
+				return;
+			}
+			cpu_relax();
+		}
+		/* See if we need to flush again */
+	} while (xusbps_readl(&dr_regs->endptstatus) & bits);
+}
+
+static struct usb_ep_ops xusbps_ep_ops = {
+	.enable = xusbps_ep_enable,
+	.disable = xusbps_ep_disable,
+
+	.alloc_request = xusbps_alloc_request,
+	.free_request = xusbps_free_request,
+
+	.queue = xusbps_ep_queue,
+	.dequeue = xusbps_ep_dequeue,
+
+	.set_halt = xusbps_ep_set_halt,
+	.set_wedge = xusbps_ep_set_wedge,
+	.fifo_flush = xusbps_ep_fifo_flush,	/* flush fifo */
+};
+
+/*-------------------------------------------------------------------------
+		Gadget Driver Layer Operations
+-------------------------------------------------------------------------*/
+
+/*----------------------------------------------------------------------
+ * Get the current frame number (from DR frame_index Reg )
+ *----------------------------------------------------------------------*/
+static int xusbps_get_frame(struct usb_gadget *gadget)
+{
+	return (int)(xusbps_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);
+}
+
+/*-----------------------------------------------------------------------
+ * Tries to wake up the host connected to this gadget
+ -----------------------------------------------------------------------*/
+static int xusbps_wakeup(struct usb_gadget *gadget)
+{
+	struct xusbps_udc *udc = container_of(gadget, struct xusbps_udc,
+			gadget);
+	u32 portsc;
+
+	/* Remote wakeup feature not enabled by host */
+	if (!udc->remote_wakeup)
+		return -ENOTSUPP;
+
+	portsc = xusbps_readl(&dr_regs->portsc1);
+	/* not suspended? */
+	if (!(portsc & PORTSCX_PORT_SUSPEND))
+		return 0;
+	/* trigger force resume */
+	portsc |= PORTSCX_PORT_FORCE_RESUME;
+	xusbps_writel(portsc, &dr_regs->portsc1);
+	return 0;
+}
+
+static int can_pullup(struct xusbps_udc *udc)
+{
+	return udc->driver && udc->softconnect && udc->vbus_active;
+}
+
+/* Notify controller that VBUS is powered, Called by whatever
+   detects VBUS sessions */
+static int xusbps_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	struct xusbps_udc	*udc;
+	unsigned long	flags;
+
+	udc = container_of(gadget, struct xusbps_udc, gadget);
+	spin_lock_irqsave(&udc->lock, flags);
+	VDBG("VBUS %s", is_active ? "on" : "off");
+	udc->vbus_active = (is_active != 0);
+	if (can_pullup(udc))
+		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) |
+					USB_CMD_RUN_STOP), &dr_regs->usbcmd);
+	else
+		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) &
+					~USB_CMD_RUN_STOP), &dr_regs->usbcmd);
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return 0;
+}
+
+/* constrain controller's VBUS power usage
+ * This call is used by gadget drivers during SET_CONFIGURATION calls,
+ * reporting how much power the device may consume.  For example, this
+ * could affect how quickly batteries are recharged.
+ *
+ * Returns zero on success, else negative errno.
+ */
+static int xusbps_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+{
+	struct xusbps_udc *udc;
+
+	udc = container_of(gadget, struct xusbps_udc, gadget);
+	if (udc->transceiver)
+		return usb_phy_set_power(udc->transceiver, mA);
+	return -ENOTSUPP;
+}
+
+/* Change Data+ pullup status
+ * this func is used by usb_gadget_connect/disconnet
+ */
+static int xusbps_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct xusbps_udc *udc;
+
+	udc = container_of(gadget, struct xusbps_udc, gadget);
+	udc->softconnect = (is_on != 0);
+	if (can_pullup(udc))
+		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) |
+					USB_CMD_RUN_STOP), &dr_regs->usbcmd);
+	else
+		xusbps_writel((xusbps_readl(&dr_regs->usbcmd) &
+					~USB_CMD_RUN_STOP), &dr_regs->usbcmd);
+
+	return 0;
+}
+
+static void udc_reset_ep_queue(struct xusbps_udc *udc, u8 pipe)
+{
+	struct xusbps_ep *ep = get_ep_by_pipe(udc, pipe);
+
+	if (ep->name)
+		nuke(ep, -ESHUTDOWN);
+}
+
+/* Clear up all ep queues */
+static int reset_queues(struct xusbps_udc *udc)
+{
+	u8 pipe;
+
+	for (pipe = 0; pipe < udc->max_pipes; pipe++)
+		udc_reset_ep_queue(udc, pipe);
+
+	/* report disconnect; the driver is already quiesced */
+	spin_unlock(&udc->lock);
+	udc->driver->disconnect(&udc->gadget);
+	spin_lock(&udc->lock);
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+/*----------------------------------------------------------------
+ * OTG Related changes
+ *--------------------------------------------------------------*/
+static int xusbps_udc_start_peripheral(struct usb_phy  *otg)
+{
+	struct usb_gadget	*gadget = otg->otg->gadget;
+	struct xusbps_udc *udc = container_of(gadget, struct xusbps_udc,
+						gadget);
+	unsigned long flags = 0;
+	unsigned int tmp;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (!otg->otg->default_a) {
+		dr_controller_setup(udc);
+		reset_queues(udc);
+	} else {
+		/* A-device HABA resets the controller */
+		tmp = udc->ep_qh_dma;
+		tmp &= USB_EP_LIST_ADDRESS_MASK;
+		xusbps_writel(tmp, &dr_regs->endpointlistaddr);
+	}
+	ep0_setup(udc);
+	dr_controller_run(udc);
+
+	udc->usb_state = USB_STATE_ATTACHED;
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->ep0_dir = 0;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int xusbps_udc_stop_peripheral(struct usb_phy *otg)
+{
+	struct usb_gadget	*gadget = otg->otg->gadget;
+	struct xusbps_udc *udc = container_of(gadget, struct xusbps_udc,
+						gadget);
+
+	dr_controller_stop(udc);
+
+	/* refer to USB OTG 6.6.2.3 b_hnp_en is cleared */
+	if (!udc->xotg->otg.otg->default_a)
+		udc->xotg->hsm.b_hnp_enable = 0;
+
+	return 0;
+}
+#endif
+
+/*----------------------------------------------------------------*
+ * Hook to gadget drivers
+ * Called by initialization code of gadget drivers
+*----------------------------------------------------------------*/
+static int xusbps_start(struct usb_gadget_driver *driver,
+		int (*bind)(struct usb_gadget *, struct usb_gadget_driver *))
+{
+	int retval = -ENODEV;
+	unsigned long flags = 0;
+
+	if (!udc_controller)
+		return -ENODEV;
+
+	if (!driver || (driver->max_speed < USB_SPEED_FULL)
+			|| !bind || !driver->disconnect || !driver->setup)
+		return -EINVAL;
+
+	if (udc_controller->driver)
+		return -EBUSY;
+
+	/* lock is needed but whether should use this lock or another */
+	spin_lock_irqsave(&udc_controller->lock, flags);
+
+	driver->driver.bus = NULL;
+	/* hook up the driver */
+	udc_controller->driver = driver;
+	udc_controller->gadget.dev.driver = &driver->driver;
+	udc_controller->gadget.speed = driver->max_speed;
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
+
+	/* bind udc driver to gadget driver */
+	retval = bind(&udc_controller->gadget, driver);
+	if (retval) {
+		VDBG("bind to %s --> %d", driver->driver.name, retval);
+		udc_controller->gadget.dev.driver = NULL;
+		udc_controller->driver = NULL;
+		goto out;
+	}
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (gadget_is_otg(&udc_controller->gadget)) {
+		retval = otg_set_peripheral(udc_controller->transceiver->otg,
+				&udc_controller->gadget);
+		if (retval < 0) {
+			VDBG("can't bind to otg transceiver\n");
+			driver->unbind(&udc_controller->gadget);
+			udc_controller->gadget.dev.driver = NULL;
+			udc_controller->driver = NULL;
+			goto out;
+		}
+		/* Exporting start and stop routines */
+		udc_controller->xotg->start_peripheral =
+					xusbps_udc_start_peripheral;
+		udc_controller->xotg->stop_peripheral =
+					xusbps_udc_stop_peripheral;
+
+		if (!udc_controller->transceiver->otg->default_a &&
+					udc_controller->stopped &&
+				udc_controller->xotg->hsm.b_sess_vld) {
+			dr_controller_setup(udc_controller);
+			ep0_setup(udc_controller);
+			/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+			dr_controller_run(udc_controller);
+			udc_controller->usb_state = USB_STATE_ATTACHED;
+			udc_controller->ep0_state = WAIT_FOR_SETUP;
+			udc_controller->ep0_dir = 0;
+			xusbps_update_transceiver();
+		}
+	} else {
+		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+		dr_controller_run(udc_controller);
+		udc_controller->usb_state = USB_STATE_ATTACHED;
+		udc_controller->ep0_state = WAIT_FOR_SETUP;
+		udc_controller->ep0_dir = 0;
+	}
+#else
+	/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+	dr_controller_run(udc_controller);
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+#endif
+
+	pr_info("%s: bind to driver %s\n",
+			udc_controller->gadget.name, driver->driver.name);
+
+out:
+	if (retval)
+		pr_warn("gadget driver register failed %d\n", retval);
+	return retval;
+}
+
+/* Disconnect from gadget driver */
+static int xusbps_stop(struct usb_gadget_driver *driver)
+{
+	struct xusbps_ep *loop_ep;
+	unsigned long flags;
+
+	if (!udc_controller)
+		return -ENODEV;
+
+	if (!driver || driver != udc_controller->driver || !driver->unbind)
+		return -EINVAL;
+
+	if (udc_controller->transceiver)
+		otg_set_peripheral(udc_controller->transceiver->otg, NULL);
+
+	/* stop DR, disable intr */
+	dr_controller_stop(udc_controller);
+
+	/* in fact, no needed */
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+
+	/* stand operation */
+	spin_lock_irqsave(&udc_controller->lock, flags);
+	udc_controller->gadget.speed = USB_SPEED_UNKNOWN;
+	nuke(&udc_controller->eps[0], -ESHUTDOWN);
+	list_for_each_entry(loop_ep, &udc_controller->gadget.ep_list,
+			ep.ep_list)
+		nuke(loop_ep, -ESHUTDOWN);
+	spin_unlock_irqrestore(&udc_controller->lock, flags);
+
+	/* report disconnect; the controller is already quiesced */
+	driver->disconnect(&udc_controller->gadget);
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (gadget_is_otg(&udc_controller->gadget)) {
+		udc_controller->xotg->start_peripheral = NULL;
+		udc_controller->xotg->stop_peripheral = NULL;
+	}
+#endif
+	/* unbind gadget and unhook driver. */
+	driver->unbind(&udc_controller->gadget);
+	udc_controller->gadget.dev.driver = NULL;
+	udc_controller->driver = NULL;
+
+	pr_warn("unregistered gadget driver '%s'\n", driver->driver.name);
+	return 0;
+}
+
+/* defined in gadget.h */
+static struct usb_gadget_ops xusbps_gadget_ops = {
+	.get_frame = xusbps_get_frame,
+	.wakeup = xusbps_wakeup,
+/*	.set_selfpowered = xusbps_set_selfpowered, */ /* Always selfpowered */
+	.vbus_session = xusbps_vbus_session,
+	.vbus_draw = xusbps_vbus_draw,
+	.pullup = xusbps_pullup,
+	.start = xusbps_start,
+	.stop = xusbps_stop,
+};
+
+/* Set protocol stall on ep0, protocol stall will automatically be cleared
+   on new transaction */
+static void ep0stall(struct xusbps_udc *udc)
+{
+	u32 tmp;
+
+	/* must set tx and rx to stall at the same time */
+	tmp = xusbps_readl(&dr_regs->endptctrl[0]);
+	tmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;
+	xusbps_writel(tmp, &dr_regs->endptctrl[0]);
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->ep0_dir = 0;
+}
+
+/* Prime a status phase for ep0 */
+static int ep0_prime_status(struct xusbps_udc *udc, int direction)
+{
+	struct xusbps_req *req = udc->status_req;
+	struct xusbps_ep *ep;
+
+	if (direction == EP_DIR_IN)
+		udc->ep0_dir = USB_DIR_IN;
+	else
+		udc->ep0_dir = USB_DIR_OUT;
+
+	ep = &udc->eps[0];
+	udc->ep0_state = WAIT_FOR_OUT_STATUS;
+
+	req->ep = ep;
+	req->req.length = 0;
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
+	req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
+				req->req.buf, req->req.length,
+				ep_is_in(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	req->mapped = 1;
+
+	if (xusbps_req_to_dtd(req) == 0)
+		xusbps_queue_td(ep, req);
+	else
+		return -ENOMEM;
+
+	list_add_tail(&req->queue, &ep->queue);
+
+	return 0;
+}
+
+/*
+ * ch9 Set address
+ */
+static void ch9setaddress(struct xusbps_udc *udc, u16 value, u16 index, u16
+		length)
+{
+	/* Save the new address to device struct */
+	udc->device_address = (u8) value;
+	/* Update usb state */
+	udc->usb_state = USB_STATE_ADDRESS;
+	/* Status phase */
+	if (ep0_prime_status(udc, EP_DIR_IN))
+		ep0stall(udc);
+}
+
+/*
+ * ch9 Get status
+ */
+static void ch9getstatus(struct xusbps_udc *udc, u8 request_type, u16 value,
+		u16 index, u16 length)
+{
+	u16 tmp = 0;		/* Status, cpu endian */
+	struct xusbps_req *req;
+	struct xusbps_ep *ep;
+
+	ep = &udc->eps[0];
+
+	if ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+		/* Get device status */
+		tmp = 1 << USB_DEVICE_SELF_POWERED;
+		tmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {
+		/* Get interface status */
+		/* We don't have interface information in udc driver */
+		tmp = 0;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		/* Get endpoint status */
+		struct xusbps_ep *target_ep;
+
+		target_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));
+
+		/* stall if endpoint doesn't exist */
+		if (!target_ep->ep.desc)
+			goto stall;
+		tmp = dr_ep_get_stall(ep_index(target_ep), ep_is_in(target_ep))
+				<< USB_ENDPOINT_HALT;
+	}
+
+	udc->ep0_dir = USB_DIR_IN;
+	/* Borrow the per device status_req */
+	req = udc->status_req;
+	/* Fill in the reqest structure */
+	*((u16 *) req->req.buf) = cpu_to_le16(tmp);
+	req->ep = ep;
+	req->req.length = 2;
+	req->req.status = -EINPROGRESS;
+	req->req.actual = 0;
+	req->req.complete = NULL;
+	req->dtd_count = 0;
+	req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
+				req->req.buf, req->req.length,
+				ep_is_in(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	req->mapped = 1;
+
+	/* prime the data phase */
+	if ((xusbps_req_to_dtd(req) == 0))
+		xusbps_queue_td(ep, req);
+	else			/* no mem */
+		goto stall;
+
+	list_add_tail(&req->queue, &ep->queue);
+	udc->ep0_state = DATA_STATE_XMIT;
+	return;
+stall:
+	ep0stall(udc);
+}
+
+static void setup_received_irq(struct xusbps_udc *udc,
+		struct usb_ctrlrequest *setup)
+{
+	u16 wValue = le16_to_cpu(setup->wValue);
+	u16 wIndex = le16_to_cpu(setup->wIndex);
+	u16 wLength = le16_to_cpu(setup->wLength);
+	u16 testsel = 0;
+
+	udc_reset_ep_queue(udc, 0);
+
+	/* We process some stardard setup requests here */
+	switch (setup->bRequest) {
+	case USB_REQ_GET_STATUS:
+		/* Data+Status phase from udc */
+		if ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
+					!= (USB_DIR_IN | USB_TYPE_STANDARD))
+			break;
+		ch9getstatus(udc, setup->bRequestType, wValue, wIndex, wLength);
+		return;
+
+	case USB_REQ_SET_ADDRESS:
+		/* Status phase from udc */
+		if (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD
+						| USB_RECIP_DEVICE))
+			break;
+		ch9setaddress(udc, wValue, wIndex, wLength);
+		return;
+
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+		/* Status phase from udc */
+	{
+		int rc = -EOPNOTSUPP;
+
+		if ((setup->bRequestType & (USB_RECIP_MASK | USB_TYPE_MASK))
+				== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {
+			int pipe = get_pipe_by_windex(wIndex);
+			struct xusbps_ep *ep;
+
+			if (wValue != 0 || wLength != 0 || pipe > udc->max_ep)
+				break;
+			ep = get_ep_by_pipe(udc, pipe);
+
+			spin_unlock(&udc->lock);
+			if (setup->bRequest == USB_REQ_SET_FEATURE) {
+				 rc = xusbps_ep_set_halt(&ep->ep, 1);
+			} else {
+				if (!ep->wedge)
+					rc = xusbps_ep_set_halt(&ep->ep, 0);
+				else
+					rc = 0;
+			}
+			spin_lock(&udc->lock);
+
+		} else if ((setup->bRequestType & (USB_RECIP_MASK
+				| USB_TYPE_MASK)) == (USB_RECIP_DEVICE
+				| USB_TYPE_STANDARD)) {
+			/* TEST MODE feature */
+			if (wValue == USB_DEVICE_TEST_MODE) {
+				testsel = (wIndex >> 8) & 0xff;
+				rc = 0;
+				goto status_phase;
+			}
+
+			/* Note: The driver has not include OTG support yet.
+			 * This will be set when OTG support is added */
+			if (!gadget_is_otg(&udc->gadget))
+				break;
+			else if (setup->bRequest == USB_DEVICE_B_HNP_ENABLE) {
+				udc->gadget.b_hnp_enable = 1;
+#ifdef	CONFIG_USB_XUSBPS_OTG
+				if (!udc->xotg->otg.otg->default_a)
+					udc->xotg->hsm.b_hnp_enable = 1;
+#endif
+			} else if (setup->bRequest == USB_DEVICE_A_HNP_SUPPORT)
+				udc->gadget.a_hnp_support = 1;
+			else if (setup->bRequest ==
+					USB_DEVICE_A_ALT_HNP_SUPPORT)
+				udc->gadget.a_alt_hnp_support = 1;
+			else
+				break;
+			rc = 0;
+		} else
+			break;
+
+status_phase:
+		if (rc == 0) {
+			if (ep0_prime_status(udc, EP_DIR_IN)) {
+				ep0stall(udc);
+			} else {
+				if (testsel) {
+					u32 tmp;
+					/* Wait for status phase to complete */
+					mdelay(1);
+					tmp = xusbps_readl(&dr_regs->portsc1);
+					tmp |= (testsel << 16);
+					xusbps_writel(tmp, &dr_regs->portsc1);
+				}
+			}
+		}
+		return;
+	}
+
+	default:
+		break;
+	}
+
+	/* Requests handled by gadget */
+	if (wLength) {
+		/* Data phase from gadget, status phase from udc */
+		udc->ep0_dir = (setup->bRequestType & USB_DIR_IN)
+				?  USB_DIR_IN : USB_DIR_OUT;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = (setup->bRequestType & USB_DIR_IN)
+				?  DATA_STATE_XMIT : DATA_STATE_RECV;
+	} else {
+		/* No data phase, IN status from gadget */
+		udc->ep0_dir = USB_DIR_IN;
+		spin_unlock(&udc->lock);
+		if (udc->driver->setup(&udc->gadget,
+				&udc->local_setup_buff) < 0)
+			ep0stall(udc);
+		spin_lock(&udc->lock);
+		udc->ep0_state = WAIT_FOR_OUT_STATUS;
+	}
+}
+
+/* Process request for Data or Status phase of ep0
+ * prime status phase if needed */
+static void ep0_req_complete(struct xusbps_udc *udc, struct xusbps_ep *ep0,
+		struct xusbps_req *req)
+{
+	if (udc->usb_state == USB_STATE_ADDRESS) {
+		/* Set the new address */
+		u32 new_address = (u32) udc->device_address;
+		xusbps_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,
+				&dr_regs->deviceaddr);
+	}
+
+	done(ep0, req, 0);
+
+	switch (udc->ep0_state) {
+	case DATA_STATE_XMIT:
+		/* receive status phase */
+		if (ep0_prime_status(udc, EP_DIR_OUT))
+			ep0stall(udc);
+		break;
+	case DATA_STATE_RECV:
+		/* send status phase */
+		if (ep0_prime_status(udc, EP_DIR_IN))
+			ep0stall(udc);
+		break;
+	case WAIT_FOR_OUT_STATUS:
+		udc->ep0_state = WAIT_FOR_SETUP;
+		break;
+	case WAIT_FOR_SETUP:
+		ERR("Unexpect ep0 packets\n");
+		break;
+	default:
+		ep0stall(udc);
+		break;
+	}
+}
+
+/* Tripwire mechanism to ensure a setup packet payload is extracted without
+ * being corrupted by another incoming setup packet */
+static void tripwire_handler(struct xusbps_udc *udc, u8 ep_num, u8 *buffer_ptr)
+{
+	u32 temp;
+	struct ep_queue_head *qh;
+
+	qh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];
+
+	/* Clear bit in ENDPTSETUPSTAT */
+	temp = xusbps_readl(&dr_regs->endptsetupstat);
+	xusbps_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);
+
+	/* while a hazard exists when setup package arrives */
+	do {
+		/* Set Setup Tripwire */
+		temp = xusbps_readl(&dr_regs->usbcmd);
+		xusbps_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
+
+		/* Copy the setup packet to local buffer */
+		memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
+	} while (!(xusbps_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
+
+	/* Clear Setup Tripwire */
+	temp = xusbps_readl(&dr_regs->usbcmd);
+	xusbps_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);
+}
+
+/* process-ep_req(): free the completed Tds for this req */
+static int process_ep_req(struct xusbps_udc *udc, int pipe,
+		struct xusbps_req *curr_req)
+{
+	struct ep_td_struct *curr_td;
+	int	td_complete, actual, remaining_length, j, tmp;
+	int	status = 0;
+	int	errors = 0;
+	struct  ep_queue_head *curr_qh = &udc->ep_qh[pipe];
+	int direction = pipe % 2;
+
+	curr_td = curr_req->head;
+	td_complete = 0;
+	actual = curr_req->req.length;
+
+	for (j = 0; j < curr_req->dtd_count; j++) {
+		remaining_length = (le32_to_cpu(curr_td->size_ioc_sts)
+					& DTD_PACKET_SIZE)
+				>> DTD_LENGTH_BIT_POS;
+		actual -= remaining_length;
+		errors = le32_to_cpu(curr_td->size_ioc_sts) &
+						DTD_ERROR_MASK;
+		if (errors) {
+			if (errors & DTD_STATUS_HALTED) {
+				ERR("dTD error %08x QH=%d\n", errors, pipe);
+				/* Clear the errors and Halt condition */
+				tmp = le32_to_cpu(curr_qh->size_ioc_int_sts);
+				tmp &= ~errors;
+				curr_qh->size_ioc_int_sts = cpu_to_le32(tmp);
+				status = -EPIPE;
+				/* FIXME: continue with next queued TD? */
+
+				break;
+			}
+			if (errors & DTD_STATUS_DATA_BUFF_ERR) {
+				VDBG("Transfer overflow");
+				status = -EPROTO;
+				break;
+			} else if (errors & DTD_STATUS_TRANSACTION_ERR) {
+				VDBG("ISO error");
+				status = -EILSEQ;
+				break;
+			} else
+				ERR("Unknown error has occured (0x%x)!\n",
+					errors);
+
+		} else if (le32_to_cpu(curr_td->size_ioc_sts)
+				& DTD_STATUS_ACTIVE) {
+			VDBG("Request not complete");
+			status = REQ_UNCOMPLETE;
+			return status;
+		} else if (remaining_length) {
+			if (direction) {
+				VDBG("Transmit dTD remaining length not zero");
+				status = -EPROTO;
+				break;
+			} else {
+				td_complete++;
+				break;
+			}
+		} else {
+			td_complete++;
+			VDBG("dTD transmitted successful");
+		}
+
+		if (j != curr_req->dtd_count - 1)
+			curr_td = (struct ep_td_struct *)curr_td->next_td_virt;
+	}
+
+	if (status)
+		return status;
+
+	curr_req->req.actual = actual;
+
+	return 0;
+}
+
+/* Process a DTD completion interrupt */
+static void dtd_complete_irq(struct xusbps_udc *udc)
+{
+	u32 bit_pos;
+	int i, ep_num, direction, bit_mask, status;
+	struct xusbps_ep *curr_ep;
+	struct xusbps_req *curr_req, *temp_req;
+
+	/* Clear the bits in the register */
+	bit_pos = xusbps_readl(&dr_regs->endptcomplete);
+	xusbps_writel(bit_pos, &dr_regs->endptcomplete);
+
+	if (!bit_pos)
+		return;
+
+	for (i = 0; i < udc->max_ep; i++) {
+		ep_num = i >> 1;
+		direction = i % 2;
+
+		bit_mask = 1 << (ep_num + 16 * direction);
+
+		if (!(bit_pos & bit_mask))
+			continue;
+
+		curr_ep = get_ep_by_pipe(udc, i);
+
+		/* If the ep is configured */
+		if (curr_ep->name == NULL) {
+			WARNING("Invalid EP?");
+			continue;
+		}
+
+		/* process the req queue until an uncomplete request */
+		list_for_each_entry_safe(curr_req, temp_req, &curr_ep->queue,
+				queue) {
+			status = process_ep_req(udc, i, curr_req);
+
+			VDBG("status of process_ep_req= %d, ep = %d",
+					status, ep_num);
+			if (status == REQ_UNCOMPLETE)
+				break;
+			/* write back status to req */
+			curr_req->req.status = status;
+
+			if (ep_num == 0) {
+				ep0_req_complete(udc, curr_ep, curr_req);
+				break;
+			} else
+				done(curr_ep, curr_req, status);
+		}
+	}
+}
+
+/* Process a port change interrupt */
+static void port_change_irq(struct xusbps_udc *udc)
+{
+	u32 speed;
+
+	/* Bus resetting is finished */
+	if (!(xusbps_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET)) {
+		/* Get the speed */
+		speed = (xusbps_readl(&dr_regs->portsc1)
+				& PORTSCX_PORT_SPEED_MASK);
+		switch (speed) {
+		case PORTSCX_PORT_SPEED_HIGH:
+			udc->gadget.speed = USB_SPEED_HIGH;
+			break;
+		case PORTSCX_PORT_SPEED_FULL:
+			udc->gadget.speed = USB_SPEED_FULL;
+			break;
+		case PORTSCX_PORT_SPEED_LOW:
+			udc->gadget.speed = USB_SPEED_LOW;
+			break;
+		default:
+			udc->gadget.speed = USB_SPEED_UNKNOWN;
+			break;
+		}
+	}
+
+	/* Update USB state */
+	if (!udc->resume_state)
+		udc->usb_state = USB_STATE_DEFAULT;
+}
+
+/* Process suspend interrupt */
+static void suspend_irq(struct xusbps_udc *udc)
+{
+	udc->resume_state = udc->usb_state;
+	udc->usb_state = USB_STATE_SUSPENDED;
+
+#ifdef	CONFIG_USB_XUSBPS_OTG
+	if (gadget_is_otg(&udc->gadget)) {
+		if (udc->xotg->otg.otg->default_a) {
+			udc->xotg->hsm.b_bus_suspend = 1;
+			/* notify transceiver the state changes */
+			if (spin_trylock(&udc->xotg->wq_lock)) {
+				xusbps_update_transceiver();
+				spin_unlock(&udc->xotg->wq_lock);
+			}
+		} else {
+			if (!udc->xotg->hsm.a_bus_suspend) {
+				udc->xotg->hsm.a_bus_suspend = 1;
+				udc->xotg->hsm.b_bus_req = 1;
+				/* notify transceiver the state changes */
+				if (spin_trylock(&udc->xotg->wq_lock)) {
+					xusbps_update_transceiver();
+					spin_unlock(&udc->xotg->wq_lock);
+				}
+			}
+		}
+	}
+#endif
+	/* report suspend to the driver, serial.c does not support this */
+	if (udc->driver->suspend)
+		udc->driver->suspend(&udc->gadget);
+}
+
+static void bus_resume(struct xusbps_udc *udc)
+{
+	udc->usb_state = udc->resume_state;
+	udc->resume_state = 0;
+
+	/* report resume to the driver, serial.c does not support this */
+	if (udc->driver->resume)
+		udc->driver->resume(&udc->gadget);
+}
+
+/* Process reset interrupt */
+static void reset_irq(struct xusbps_udc *udc)
+{
+	u32 temp;
+	unsigned long timeout;
+
+	/* Clear the device address */
+	temp = xusbps_readl(&dr_regs->deviceaddr);
+	xusbps_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);
+
+	udc->device_address = 0;
+
+	/* Clear usb state */
+	udc->resume_state = 0;
+	udc->ep0_dir = 0;
+	udc->ep0_state = WAIT_FOR_SETUP;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
+	udc->gadget.b_hnp_enable = 0;
+	udc->gadget.a_hnp_support = 0;
+	udc->gadget.a_alt_hnp_support = 0;
+
+	/* Clear all the setup token semaphores */
+	temp = xusbps_readl(&dr_regs->endptsetupstat);
+	xusbps_writel(temp, &dr_regs->endptsetupstat);
+
+	/* Clear all the endpoint complete status bits */
+	temp = xusbps_readl(&dr_regs->endptcomplete);
+	xusbps_writel(temp, &dr_regs->endptcomplete);
+
+	timeout = jiffies + 100;
+	while (xusbps_readl(&dr_regs->endpointprime)) {
+		/* Wait until all endptprime bits cleared */
+		if (time_after(jiffies, timeout)) {
+			ERR("Timeout for reset\n");
+			break;
+		}
+		cpu_relax();
+	}
+
+	/* Write 1s to the flush register */
+	xusbps_writel(0xffffffff, &dr_regs->endptflush);
+
+	VDBG("Bus reset");
+	/* Reset all the queues, include XD, dTD, EP queue
+	 * head and TR Queue */
+	reset_queues(udc);
+	udc->usb_state = USB_STATE_DEFAULT;
+}
+
+/*
+ * USB device controller interrupt handler
+ */
+static irqreturn_t xusbps_udc_irq(int irq, void *_udc)
+{
+	struct xusbps_udc *udc = _udc;
+	u32 irq_src, otg_sts;
+	irqreturn_t status = IRQ_NONE;
+	unsigned long flags;
+#ifdef CONFIG_USB_XUSBPS_OTG
+	unsigned long temp;
+#endif
+
+	/* Disable ISR for OTG host mode */
+	if (udc->stopped)
+		return IRQ_NONE;
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (gadget_is_otg(&udc->gadget)) {
+		/* A-device */
+		if (udc->transceiver->otg->default_a &&
+			(udc->transceiver->state != OTG_STATE_A_PERIPHERAL))
+			return IRQ_NONE;
+		/* B-device */
+		if ((udc->transceiver->state == OTG_STATE_B_WAIT_ACON) ||
+			(udc->transceiver->state == OTG_STATE_B_HOST))
+			return IRQ_NONE;
+	}
+#endif
+	spin_lock_irqsave(&udc->lock, flags);
+	irq_src = xusbps_readl(&dr_regs->usbsts) &
+		xusbps_readl(&dr_regs->usbintr);
+
+	/* Clear notification bits */
+	xusbps_writel(irq_src, &dr_regs->usbsts);
+
+	/*
+	 * Check disconnect event from B session end interrupt.
+	 * This is a SW workaround for USB disconnect detection as mentioned
+	 * in AR# 47538
+	 */
+	if (!gadget_is_otg(&udc->gadget)) {
+		otg_sts = xusbps_readl(&dr_regs->otgsc);
+		if (otg_sts & OTGSC_BSEIS) {
+			xusbps_writel(otg_sts, &dr_regs->otgsc);
+			reset_queues(udc);
+			status = IRQ_HANDLED;
+		}
+	}
+
+	/* VDBG("irq_src [0x%8x]", irq_src); */
+
+	/* Need to resume? */
+	if (udc->usb_state == USB_STATE_SUSPENDED)
+		if ((xusbps_readl(&dr_regs->portsc1) &
+					PORTSCX_PORT_SUSPEND) == 0)
+			bus_resume(udc);
+
+	/* USB Interrupt */
+	if (irq_src & USB_STS_INT) {
+		VDBG("Packet int");
+		/* Setup package, we only support ep0 as control ep */
+		if (xusbps_readl(&dr_regs->endptsetupstat) &
+						EP_SETUP_STATUS_EP0) {
+			tripwire_handler(udc, 0,
+					(u8 *) (&udc->local_setup_buff));
+			setup_received_irq(udc, &udc->local_setup_buff);
+			status = IRQ_HANDLED;
+		}
+
+		/* completion of dtd */
+		if (xusbps_readl(&dr_regs->endptcomplete)) {
+			dtd_complete_irq(udc);
+			status = IRQ_HANDLED;
+		}
+	}
+
+	/* SOF (for ISO transfer) */
+	if (irq_src & USB_STS_SOF)
+		status = IRQ_HANDLED;
+
+	/* Port Change */
+	if (irq_src & USB_STS_PORT_CHANGE) {
+		port_change_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	/* Reset Received */
+	if (irq_src & USB_STS_RESET) {
+		reset_irq(udc);
+#ifdef CONFIG_USB_XUSBPS_OTG
+		if (gadget_is_otg(&udc->gadget)) {
+			/* Clear any previous suspend status bit */
+			temp = xusbps_readl(&dr_regs->usbsts);
+			if (temp & USB_INTR_DEVICE_SUSPEND) {
+				udc->usb_state = USB_STATE_SUSPENDED;
+				temp |= USB_INTR_DEVICE_SUSPEND;
+				xusbps_writel(temp, &dr_regs->usbsts);
+			}
+			/* Enable suspend interrupt */
+			temp = xusbps_readl(&dr_regs->usbintr);
+			temp |= USB_INTR_DEVICE_SUSPEND;
+			xusbps_writel(temp, &dr_regs->usbintr);
+		}
+#endif
+		status = IRQ_HANDLED;
+	}
+
+	/* Sleep Enable (Suspend) */
+	if (irq_src & USB_STS_SUSPEND) {
+		suspend_irq(udc);
+		status = IRQ_HANDLED;
+	}
+
+	if (irq_src & (USB_STS_ERR | USB_STS_SYS_ERR))
+		VDBG("Error IRQ %x", irq_src);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return status;
+}
+
+/*-------------------------------------------------------------------------
+		PROC File System Support
+-------------------------------------------------------------------------*/
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+#include <linux/seq_file.h>
+
+static const char proc_filename[] = "driver/xusbps_udc";
+
+static int xusbps_proc_read(char *page, char **start, off_t off, int count,
+		int *eof, void *_dev)
+{
+	char *buf = page;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t, i;
+	u32 tmp_reg;
+	struct xusbps_ep *ep = NULL;
+	struct xusbps_req *req;
+
+	struct xusbps_udc *udc = udc_controller;
+	if (off != 0)
+		return 0;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* ------basic driver information ---- */
+	t = scnprintf(next, size,
+			DRIVER_DESC "\n"
+			"%s version: %s\n"
+			"Gadget driver: %s\n\n",
+			driver_name, DRIVER_VERSION,
+			udc->driver ? udc->driver->driver.name : "(none)");
+	size -= t;
+	next += t;
+
+	/* ------ DR Registers ----- */
+	tmp_reg = xusbps_readl(&dr_regs->usbcmd);
+	t = scnprintf(next, size,
+			"USBCMD reg:\n"
+			"SetupTW: %d\n"
+			"Run/Stop: %s\n\n",
+			(tmp_reg & USB_CMD_SUTW) ? 1 : 0,
+			(tmp_reg & USB_CMD_RUN_STOP) ? "Run" : "Stop");
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->usbsts);
+	t = scnprintf(next, size,
+			"USB Status Reg:\n"
+			"Dr Suspend: %d Reset Received: %d System Error: %s "
+			"USB Error Interrupt: %s\n\n",
+			(tmp_reg & USB_STS_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_STS_RESET) ? 1 : 0,
+			(tmp_reg & USB_STS_SYS_ERR) ? "Err" : "Normal",
+			(tmp_reg & USB_STS_ERR) ? "Err detected" : "No err");
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->usbintr);
+	t = scnprintf(next, size,
+			"USB Intrrupt Enable Reg:\n"
+			"Sleep Enable: %d SOF Received Enable: %d "
+			"Reset Enable: %d\n"
+			"System Error Enable: %d "
+			"Port Change Dectected Enable: %d\n"
+			"USB Error Intr Enable: %d USB Intr Enable: %d\n\n",
+			(tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,
+			(tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_SYS_ERR_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_PTC_DETECT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,
+			(tmp_reg & USB_INTR_INT_EN) ? 1 : 0);
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->frindex);
+	t = scnprintf(next, size,
+			"USB Frame Index Reg: Frame Number is 0x%x\n\n",
+			(tmp_reg & USB_FRINDEX_MASKS));
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->deviceaddr);
+	t = scnprintf(next, size,
+			"USB Device Address Reg: Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_DEVICE_ADDRESS_MASK));
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->endpointlistaddr);
+	t = scnprintf(next, size,
+			"USB Endpoint List Address Reg: "
+			"Device Addr is 0x%x\n\n",
+			(tmp_reg & USB_EP_LIST_ADDRESS_MASK));
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->portsc1);
+	t = scnprintf(next, size,
+		"USB Port Status&Control Reg:\n"
+		"Port Transceiver Type : %s Port Speed: %s\n"
+		"PHY Low Power Suspend: %s Port Reset: %s "
+		"Port Suspend Mode: %s\n"
+		"Over-current Change: %s "
+		"Port Enable/Disable Change: %s\n"
+		"Port Enabled/Disabled: %s "
+		"Current Connect Status: %s\n\n", ({
+			char *s;
+			switch (tmp_reg & PORTSCX_PTS_FSLS) {
+			case PORTSCX_PTS_UTMI:
+				s = "UTMI"; break;
+			case PORTSCX_PTS_ULPI:
+				s = "ULPI "; break;
+			case PORTSCX_PTS_FSLS:
+				s = "FS/LS Serial"; break;
+			default:
+				s = "None"; break;
+			}
+			s; }), ({
+			char *s;
+			switch (tmp_reg & PORTSCX_PORT_SPEED_UNDEF) {
+			case PORTSCX_PORT_SPEED_FULL:
+				s = "Full Speed"; break;
+			case PORTSCX_PORT_SPEED_LOW:
+				s = "Low Speed"; break;
+			case PORTSCX_PORT_SPEED_HIGH:
+				s = "High Speed"; break;
+			default:
+				s = "Undefined"; break;
+			}
+			s;
+		}),
+		(tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?
+		"Normal PHY mode" : "Low power mode",
+		(tmp_reg & PORTSCX_PORT_RESET) ? "In Reset" :
+		"Not in Reset",
+		(tmp_reg & PORTSCX_PORT_SUSPEND) ? "In " : "Not in",
+		(tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? "Dected" :
+		"No",
+		(tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? "Disable" :
+		"Not change",
+		(tmp_reg & PORTSCX_PORT_ENABLE) ? "Enable" :
+		"Not correct",
+		(tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?
+		"Attached" : "Not-Att");
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->usbmode);
+	t = scnprintf(next, size,
+			"USB Mode Reg: Controller Mode is: %s\n\n", ({
+				char *s;
+				switch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {
+				case USB_MODE_CTRL_MODE_IDLE:
+					s = "Idle"; break;
+				case USB_MODE_CTRL_MODE_DEVICE:
+					s = "Device Controller"; break;
+				case USB_MODE_CTRL_MODE_HOST:
+					s = "Host Controller"; break;
+				default:
+					s = "None"; break;
+				}
+				s;
+			}));
+	size -= t;
+	next += t;
+
+	tmp_reg = xusbps_readl(&dr_regs->endptsetupstat);
+	t = scnprintf(next, size,
+			"Endpoint Setup Status Reg: SETUP on ep 0x%x\n\n",
+			(tmp_reg & EP_SETUP_STATUS_MASK));
+	size -= t;
+	next += t;
+
+	for (i = 0; i < udc->max_ep / 2; i++) {
+		tmp_reg = xusbps_readl(&dr_regs->endptctrl[i]);
+		t = scnprintf(next, size, "EP Ctrl Reg [0x%x]: = [0x%x]\n",
+				i, tmp_reg);
+		size -= t;
+		next += t;
+	}
+	tmp_reg = xusbps_readl(&dr_regs->endpointprime);
+	t = scnprintf(next, size, "EP Prime Reg = [0x%x]\n\n", tmp_reg);
+	size -= t;
+	next += t;
+
+	/* ------xusbps_udc, xusbps_ep, xusbps_request structure information
+	 * ----- */
+	ep = &udc->eps[0];
+	t = scnprintf(next, size, "For %s Maxpkt is 0x%x index is 0x%x\n",
+			ep->ep.name, ep_maxpacket(ep), ep_index(ep));
+	size -= t;
+	next += t;
+
+	if (list_empty(&ep->queue)) {
+		t = scnprintf(next, size, "its req queue is empty\n\n");
+		size -= t;
+		next += t;
+	} else {
+		list_for_each_entry(req, &ep->queue, queue) {
+			t = scnprintf(next, size,
+				"req %p actual 0x%x length 0x%x buf %p\n",
+				&req->req, req->req.actual,
+				req->req.length, req->req.buf);
+			size -= t;
+			next += t;
+		}
+	}
+	/* other gadget->eplist ep */
+	list_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {
+		if (ep->ep.desc) {
+			t = scnprintf(next, size,
+					"\nFor %s Maxpkt is 0x%x "
+					"index is 0x%x\n",
+					ep->ep.name, ep_maxpacket(ep),
+					ep_index(ep));
+			size -= t;
+			next += t;
+
+			if (list_empty(&ep->queue)) {
+				t = scnprintf(next, size,
+						"its req queue is empty\n\n");
+				size -= t;
+				next += t;
+			} else {
+				list_for_each_entry(req, &ep->queue, queue) {
+					t = scnprintf(next, size,
+						"req %p actual 0x%x length "
+						"0x%x  buf %p\n",
+						&req->req, req->req.actual,
+						req->req.length, req->req.buf);
+					size -= t;
+					next += t;
+					} /* end for each_entry of ep req */
+				}	/* end for else */
+			}	/* end for if(ep->queue) */
+		}		/* end (ep->desc) */
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_file()	create_proc_read_entry(proc_filename, \
+				0, NULL, xusbps_proc_read, NULL)
+
+#define remove_proc_file()	remove_proc_entry(proc_filename, NULL)
+
+#else				/* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_file()	do {} while (0)
+#define remove_proc_file()	do {} while (0)
+
+#endif				/* CONFIG_USB_GADGET_DEBUG_FILES */
+
+/*-------------------------------------------------------------------------*/
+
+/* Release udc structures */
+static void xusbps_udc_release(struct device *dev)
+{
+	complete(udc_controller->done);
+	dma_free_coherent(dev->parent, udc_controller->ep_qh_size,
+			udc_controller->ep_qh, udc_controller->ep_qh_dma);
+	kfree(udc_controller);
+}
+
+/******************************************************************
+	Internal structure setup functions
+*******************************************************************/
+/*------------------------------------------------------------------
+ * init resource for globle controller
+ * Return the udc handle on success or NULL on failure
+ ------------------------------------------------------------------*/
+static int struct_udc_setup(struct xusbps_udc *udc,
+		struct platform_device *pdev)
+{
+	struct xusbps_usb2_platform_data *pdata;
+	size_t size;
+
+	pdata = pdev->dev.platform_data;
+	udc->phy_mode = pdata->phy_mode;
+
+	udc->eps = kzalloc(sizeof(*udc->eps) * udc->max_ep, GFP_KERNEL);
+	if (!udc->eps) {
+		dev_err(&pdev->dev, "malloc xusbps_ep failed\n");
+		return -1;
+	}
+
+	/* initialized QHs, take care of alignment */
+	size = udc->max_ep * sizeof(struct ep_queue_head);
+	if (size < QH_ALIGNMENT)
+		size = QH_ALIGNMENT;
+	else if ((size % QH_ALIGNMENT) != 0) {
+		size += QH_ALIGNMENT + 1;
+		size &= ~(QH_ALIGNMENT - 1);
+	}
+	udc->ep_qh = dma_alloc_coherent(&pdev->dev, size,
+					&udc->ep_qh_dma, GFP_KERNEL);
+	if (!udc->ep_qh) {
+		dev_err(&pdev->dev, "malloc QHs for udc failed\n");
+		kfree(udc->eps);
+		return -1;
+	}
+
+	udc->ep_qh_size = size;
+
+	/* Initialize ep0 status request structure */
+	/* FIXME: xusbps_alloc_request() ignores ep argument */
+	udc->status_req = container_of(xusbps_alloc_request(NULL, GFP_KERNEL),
+			struct xusbps_req, req);
+	/* allocate a small amount of memory to get valid address */
+	udc->status_req->req.buf = kmalloc(8, GFP_KERNEL);
+
+	udc->resume_state = USB_STATE_NOTATTACHED;
+	udc->usb_state = USB_STATE_POWERED;
+	udc->ep0_dir = 0;
+	udc->remote_wakeup = 0;	/* default to 0 on reset */
+
+	return 0;
+}
+
+/*----------------------------------------------------------------
+ * Setup the xusbps_ep struct for eps
+ * Link xusbps_ep->ep to gadget->ep_list
+ * ep0out is not used so do nothing here
+ * ep0in should be taken care
+ *--------------------------------------------------------------*/
+static int struct_ep_setup(struct xusbps_udc *udc,
+				unsigned char index, char *name, int link)
+{
+	struct xusbps_ep *ep = &udc->eps[index];
+
+	ep->udc = udc;
+	strcpy(ep->name, name);
+	ep->ep.name = ep->name;
+
+	ep->ep.ops = &xusbps_ep_ops;
+	ep->stopped = 0;
+
+	/* for ep0: maxP defined in desc
+	 * for other eps, maxP is set by epautoconfig() called by gadget layer
+	 */
+	ep->ep.maxpacket = (unsigned short) ~0;
+
+	/* the queue lists any req for this ep */
+	INIT_LIST_HEAD(&ep->queue);
+
+	/* gagdet.ep_list used for ep_autoconfig so no ep0 */
+	if (link)
+		list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+	ep->gadget = &udc->gadget;
+	ep->qh = &udc->ep_qh[index];
+
+	return 0;
+}
+
+/* Driver probe function
+ * all intialization operations implemented here except enabling usb_intr reg
+ * board setup should have been done in the platform code
+ */
+static int xusbps_udc_probe(struct platform_device *pdev)
+{
+	int ret = -ENODEV;
+	unsigned int i;
+	u32 dccparams;
+	struct xusbps_usb2_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		VDBG("Wrong device");
+		return -ENODEV;
+	}
+
+	if (strcmp(pdev->name, driver_name)) {
+		VDBG("Wrong device");
+		return -ENODEV;
+	}
+
+	udc_controller = kzalloc(sizeof(*udc_controller), GFP_KERNEL);
+	if (udc_controller == NULL) {
+		dev_err(&pdev->dev, "malloc udc failed\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&udc_controller->lock);
+	udc_controller->stopped = 1;
+
+	dr_regs = (struct usb_dr_device *)pdata->regs;
+	if (!dr_regs) {
+		ret = -ENOMEM;
+		goto err_kfree;
+	}
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (pdata->otg) {
+		udc_controller->transceiver = pdata->otg;
+		udc_controller->xotg =
+			xceiv_to_xotg(udc_controller->transceiver);
+	}
+#endif
+	/* Initialize USB clocks */
+	ret = xusbps_udc_clk_init(pdev);
+	if (ret < 0)
+		goto err_kfree;
+
+	/* Read Device Controller Capability Parameters register */
+	dccparams = xusbps_readl(&dr_regs->dccparams);
+	if (!(dccparams & DCCPARAMS_DC)) {
+		dev_err(&pdev->dev, "This SOC doesn't support device role\n");
+		ret = -ENODEV;
+		goto err_iounmap;
+	}
+	/* Get max device endpoints */
+	/* DEN is bidirectional ep number, max_ep doubles the number */
+	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
+
+	udc_controller->irq = pdata->irq;
+	if (!udc_controller->irq) {
+		ret = -ENODEV;
+		goto err_iounmap;
+	}
+
+	ret = request_irq(udc_controller->irq, xusbps_udc_irq, IRQF_SHARED,
+			driver_name, udc_controller);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "cannot request irq %d err %d\n",
+				udc_controller->irq, ret);
+		goto err_iounmap;
+	}
+
+	/* Initialize the udc structure including QH member and other member */
+	if (struct_udc_setup(udc_controller, pdev)) {
+		dev_err(&pdev->dev, "Can't initialize udc data structure\n");
+		ret = -ENOMEM;
+		goto err_free_irq;
+	}
+
+	/* initialize usb hw reg except for regs for EP,
+	 * leave usbintr reg untouched */
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (!pdata->otg)
+		dr_controller_setup(udc_controller);
+#else
+	dr_controller_setup(udc_controller);
+#endif
+
+	/* Setup gadget structure */
+	udc_controller->gadget.ops = &xusbps_gadget_ops;
+	udc_controller->gadget.max_speed = USB_SPEED_HIGH;
+	udc_controller->gadget.ep0 = &udc_controller->eps[0].ep;
+	INIT_LIST_HEAD(&udc_controller->gadget.ep_list);
+	udc_controller->gadget.name = driver_name;
+#ifdef CONFIG_USB_XUSBPS_OTG
+	udc_controller->gadget.is_otg = (pdata->otg != 0);
+#endif
+
+	/* Setup gadget.dev and register with kernel */
+	dev_set_name(&udc_controller->gadget.dev, "gadget");
+	udc_controller->gadget.dev.release = xusbps_udc_release;
+	udc_controller->gadget.dev.parent = &pdev->dev;
+	ret = device_register(&udc_controller->gadget.dev);
+	if (ret < 0)
+		goto err_free_irq;
+
+	/* setup QH and epctrl for ep0 */
+	ep0_setup(udc_controller);
+
+	/* setup udc->eps[] for ep0 */
+	struct_ep_setup(udc_controller, 0, "ep0", 0);
+	/* for ep0: the desc defined here;
+	 * for other eps, gadget layer called ep_enable with defined desc
+	 */
+	udc_controller->eps[0].ep.desc = &xusbps_ep0_desc;
+	udc_controller->eps[0].ep.maxpacket = USB_MAX_CTRL_PAYLOAD;
+
+	/* setup the udc->eps[] for non-control endpoints and link
+	 * to gadget.ep_list */
+	for (i = 1; i < (int)(udc_controller->max_ep / 2); i++) {
+		char name[14];
+
+		sprintf(name, "ep%dout", i);
+		struct_ep_setup(udc_controller, i * 2, name, 1);
+		sprintf(name, "ep%din", i);
+		struct_ep_setup(udc_controller, i * 2 + 1, name, 1);
+	}
+
+	/* use dma_pool for TD management */
+	udc_controller->td_pool = dma_pool_create("udc_td", &pdev->dev,
+			sizeof(struct ep_td_struct),
+			DTD_ALIGNMENT, UDC_DMA_BOUNDARY);
+	if (udc_controller->td_pool == NULL) {
+		ret = -ENOMEM;
+		goto err_unregister;
+	}
+
+	ret = usb_add_gadget_udc(&pdev->dev, &udc_controller->gadget);
+	if (ret)
+		goto err_del_udc;
+
+	create_proc_file();
+	return 0;
+
+err_del_udc:
+	dma_pool_destroy(udc_controller->td_pool);
+err_unregister:
+	device_unregister(&udc_controller->gadget.dev);
+err_free_irq:
+	free_irq(udc_controller->irq, udc_controller);
+err_iounmap:
+	xusbps_udc_clk_release(pdev);
+err_kfree:
+	kfree(udc_controller);
+	udc_controller = NULL;
+	return ret;
+}
+
+/* Driver removal function
+ * Free resources and finish pending transactions
+ */
+static int __exit xusbps_udc_remove(struct platform_device *pdev)
+{
+	DECLARE_COMPLETION(done);
+
+	if (!udc_controller)
+		return -ENODEV;
+
+	usb_del_gadget_udc(&udc_controller->gadget);
+	udc_controller->done = &done;
+
+	xusbps_udc_clk_release(pdev);
+
+	/* DR has been stopped in usb_gadget_unregister_driver() */
+	remove_proc_file();
+
+	/* Free allocated memory */
+	kfree(udc_controller->status_req->req.buf);
+	kfree(udc_controller->status_req);
+	kfree(udc_controller->eps);
+
+	dma_pool_destroy(udc_controller->td_pool);
+	free_irq(udc_controller->irq, udc_controller);
+	device_unregister(&udc_controller->gadget.dev);
+	/* free udc --wait for the release() finished */
+	wait_for_completion(&done);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+/*-----------------------------------------------------------------
+ * Modify Power management attributes
+ * Used by OTG statemachine to disable gadget temporarily
+ -----------------------------------------------------------------*/
+static int xusbps_udc_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	dr_controller_stop(udc_controller);
+
+	clk_disable(pdata->clk);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------
+ * Invoked on USB resume. May be called in_interrupt.
+ * Here we start the DR controller and enable the irq
+ *-----------------------------------------------------------------*/
+static int xusbps_udc_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+	int ret;
+
+	ret = clk_enable(pdata->clk);
+	if (ret) {
+		dev_err(dev, "Cannot enable APER clock.\n");
+		return ret;
+	}
+
+	/* Enable DR irq reg and set controller Run */
+	if (udc_controller->stopped) {
+		dr_controller_setup(udc_controller);
+		dr_controller_run(udc_controller);
+	}
+	udc_controller->usb_state = USB_STATE_ATTACHED;
+	udc_controller->ep0_state = WAIT_FOR_SETUP;
+	udc_controller->ep0_dir = 0;
+	return 0;
+}
+
+static const struct dev_pm_ops xusbps_udc_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xusbps_udc_suspend, xusbps_udc_resume)
+};
+#define XUSBPS_UDC_PM	(&xusbps_udc_dev_pm_ops)
+
+#else /* ! CONFIG_PM_SLEEP */
+#define XUSBPS_UDC_PM	NULL
+#endif /* ! CONFIG_PM_SLEEP */
+
+/*-------------------------------------------------------------------------
+	Register entry point for the peripheral controller driver
+--------------------------------------------------------------------------*/
+
+static struct platform_driver udc_driver = {
+	.probe   = xusbps_udc_probe,
+	.remove  = xusbps_udc_remove,
+	/* these suspend and resume are not usb suspend and resume */
+	.driver  = {
+		.name = (char *)driver_name,
+		.owner = THIS_MODULE,
+		.pm = XUSBPS_UDC_PM,
+	},
+};
+
+module_platform_driver(udc_driver);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:xusbps-udc");
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 3a21c5d..fb9b28d 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -136,6 +136,20 @@ config XPS_USB_HCD_XILINX
 		support both high speed and full speed devices, or high speed
 		devices only.
 
+config USB_XUSBPS_DR_OF
+	tristate
+	select USB_ULPI
+	select USB_ULPI_VIEWPORT
+
+config USB_EHCI_XUSBPS
+	bool "Support for Xilinx PS EHCI USB controller"
+	depends on USB_EHCI_HCD && ARCH_ZYNQ
+	select USB_EHCI_ROOT_HUB_TT
+	select USB_XUSBPS_DR_OF
+	---help---
+		Xilinx PS USB host controller core is EHCI compilant and has
+		transaction translator built-in.
+
 config USB_FSL_MPH_DR_OF
 	tristate
 
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 001fbff..c8d2406 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
 obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
 obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
+obj-$(CONFIG_USB_XUSBPS_DR_OF)	+= xusbps-dr-of.o
 obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
 obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b416a3f..e3e5480 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -334,11 +334,21 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
  */
 static void ehci_silence_controller(struct ehci_hcd *ehci)
 {
+#ifdef CONFIG_USB_XUSBPS_OTG
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+#endif
+
 	ehci_halt(ehci);
 
 	spin_lock_irq(&ehci->lock);
 	ehci->rh_state = EHCI_RH_HALTED;
+#ifdef CONFIG_USB_XUSBPS_OTG
+	/* turn off for non-otg port */
+	if(!hcd->phy)
+		ehci_turn_off_all_ports(ehci);
+#else
 	ehci_turn_off_all_ports(ehci);
+#endif
 
 	/* make BIOS/etc use companion controller during reboot */
 	ehci_writel(ehci, 0, &ehci->regs->configured_flag);
@@ -421,7 +431,12 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	ehci_quiesce(ehci);
 	ehci_silence_controller(ehci);
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if(!hcd->phy)
+		ehci_reset (ehci);
+#else
 	ehci_reset (ehci);
+#endif
 
 	hrtimer_cancel(&ehci->hrtimer);
 	remove_sysfs_files(ehci);
@@ -565,6 +580,9 @@ static int ehci_run (struct usb_hcd *hcd)
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
 	u32			hcc_params;
+#if defined(CONFIG_ARCH_ZYNQ)
+	void __iomem *non_ehci = hcd->regs;
+#endif
 
 	hcd->uses_new_polling = 1;
 
@@ -634,7 +652,11 @@ static int ehci_run (struct usb_hcd *hcd)
 
 	ehci_writel(ehci, INTR_MASK,
 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
-
+#if defined(CONFIG_ARCH_ZYNQ)
+	/* Modifying FIFO Burst Threshold value from 2 to 8 */
+	temp = readl(non_ehci + 0x164);
+	ehci_writel(ehci, 0x00080000, non_ehci + 0x164);
+#endif
 	/* GRR this is run-once init(), being done every time the HC starts.
 	 * So long as they're part of class devices, we can't do it init()
 	 * since the class device isn't created that early.
@@ -685,11 +707,35 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			status, masked_status, pcd_status = 0, cmd;
 	int			bh;
+	u32			intr_en;
 
 	spin_lock (&ehci->lock);
 
 	status = ehci_readl(ehci, &ehci->regs->status);
-
+	intr_en = ehci_readl(ehci, &ehci->regs->intr_enable);
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if(hcd->phy) {
+		/* A device */
+		if (hcd->phy->otg->default_a &&
+			(hcd->phy->state == OTG_STATE_A_PERIPHERAL)) {
+			spin_unlock(&ehci->lock);
+			return IRQ_NONE;
+		}
+		/* B device */
+		if (!hcd->phy->otg->default_a &&
+			((hcd->phy->state != OTG_STATE_B_WAIT_ACON) &&
+			(hcd->phy->state != OTG_STATE_B_HOST))) {
+			spin_unlock(&ehci->lock);
+			return IRQ_NONE;
+		}
+		/* If HABA is set and B-disconnect occurs, don't process that interrupt */
+		if (ehci_is_TDI(ehci) && tdi_in_host_mode(ehci) == 0) {
+			spin_unlock(&ehci->lock);
+			return IRQ_NONE;
+		}
+	}
+#endif
 	/* e.g. cardbus physical eject */
 	if (status == ~(u32) 0) {
 		ehci_dbg (ehci, "device removed\n");
@@ -1272,6 +1318,11 @@ MODULE_LICENSE ("GPL");
 #define XILINX_OF_PLATFORM_DRIVER	ehci_hcd_xilinx_of_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_XUSBPS
+#include "ehci-xilinx-usbps.c"
+#define	PLATFORM_DRIVER		ehci_xusbps_driver
+#endif
+
 #ifdef CONFIG_PLAT_ORION
 #include "ehci-orion.c"
 #define	PLATFORM_DRIVER		ehci_orion_driver
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4d3b294..0cf0860 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -1016,9 +1016,20 @@ static int ehci_hub_control (
 			 * Set appropriate bit thus could put phy into low power
 			 * mode if we have hostpc feature
 			 */
+#ifdef CONFIG_USB_XUSBPS_OTG
+			if (hcd->phy && (hcd->self.otg_port == (wIndex + 1))
+				&& (hcd->self.b_hnp_enable || hcd->self.is_b_host))
+				ehci->start_hnp(ehci);
+			else {
+				temp &= ~PORT_WKCONN_E;
+				temp |= PORT_WKDISC_E | PORT_WKOC_E;
+				ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
+			}
+#else
 			temp &= ~PORT_WKCONN_E;
 			temp |= PORT_WKDISC_E | PORT_WKOC_E;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
+#endif
 			if (ehci->has_hostpc) {
 				spin_unlock_irqrestore(&ehci->lock, flags);
 				msleep(5);/* 5ms for HCD enter low pwr mode */
@@ -1034,9 +1045,18 @@ static int ehci_hub_control (
 			set_bit(wIndex, &ehci->suspended_ports);
 			break;
 		case USB_PORT_FEAT_POWER:
+#ifdef CONFIG_USB_XUSBPS_OTG
+			/* Check if otg is enabled */
+			if(!hcd->phy) {
+				if (HCS_PPC (ehci->hcs_params))
+					ehci_writel(ehci, temp | PORT_POWER,
+							status_reg);
+			}
+#else
 			if (HCS_PPC (ehci->hcs_params))
 				ehci_writel(ehci, temp | PORT_POWER,
 						status_reg);
+#endif
 			break;
 		case USB_PORT_FEAT_RESET:
 			if (temp & PORT_RESUME)
diff --git a/drivers/usb/host/ehci-xilinx-usbps.c b/drivers/usb/host/ehci-xilinx-usbps.c
new file mode 100644
index 0000000..d3efaad
--- /dev/null
+++ b/drivers/usb/host/ehci-xilinx-usbps.c
@@ -0,0 +1,542 @@
+/*
+ * Xilinx PS USB Host Controller Driver.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on ehci-fsl.c file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/xilinx_usbps_otg.h>
+
+#include "ehci-xilinx-usbps.h"
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+/********************************************************************
+ * OTG related functions
+ ********************************************************************/
+static int ehci_xusbps_reinit(struct ehci_hcd *ehci);
+
+/* This connection event is useful when a OTG test device is connected.
+   In that case, the device connect notify event will not be generated
+   since the device will be suspended before complete enumeration.
+*/
+static int ehci_xusbps_update_device(struct usb_hcd *hcd, struct usb_device
+		*udev)
+{
+	struct xusbps_otg *xotg = xceiv_to_xotg(hcd->phy);
+
+	if (udev->portnum == hcd->self.otg_port) {
+		/* HNP test device */
+		if ((le16_to_cpu(udev->descriptor.idVendor) == 0x1a0a &&
+			le16_to_cpu(udev->descriptor.idProduct) == 0xbadd)) {
+			if (xotg->otg.otg->default_a == 1)
+				xotg->hsm.b_conn = 1;
+			else
+				xotg->hsm.a_conn = 1;
+			xusbps_update_transceiver();
+		}
+	}
+	return 0;
+}
+
+static void ehci_xusbps_start_hnp(struct ehci_hcd *ehci)
+{
+	const unsigned	port = ehci_to_hcd(ehci)->self.otg_port - 1;
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	unsigned long	flags;
+	u32 portsc;
+
+	local_irq_save(flags);
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[port]);
+	portsc |= PORT_SUSPEND;
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[port]);
+	local_irq_restore(flags);
+
+	otg_start_hnp(hcd->phy->otg);
+}
+
+static int ehci_xusbps_otg_start_host(struct usb_phy *otg)
+{
+	struct usb_hcd		*hcd = bus_to_hcd(otg->otg->host);
+	struct xusbps_otg *xotg =
+			xceiv_to_xotg(hcd->phy);
+
+	usb_add_hcd(hcd, xotg->irq, IRQF_SHARED | IRQF_DISABLED);
+	return 0;
+}
+
+static int ehci_xusbps_otg_stop_host(struct usb_phy *otg)
+{
+	struct usb_hcd		*hcd = bus_to_hcd(otg->otg->host);
+
+	usb_remove_hcd(hcd);
+	return 0;
+}
+#endif
+
+static int xusbps_ehci_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		/* if a rate change is announced we need to check whether we can
+		 * maintain the current frequency by changing the clock
+		 * dividers.
+		 */
+		/* fall through */
+	case POST_RATE_CHANGE:
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_hcd_xusbps_probe - initialize XUSBPS-based HCDs
+ * @driver: Driver to be used for this HCD
+ * @pdev: USB Host Controller being probed
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller.
+ *
+ */
+static int usb_hcd_xusbps_probe(const struct hc_driver *driver,
+			     struct platform_device *pdev)
+{
+	struct xusbps_usb2_platform_data *pdata;
+	struct usb_hcd *hcd;
+	int irq;
+	int retval;
+
+	pr_debug("initializing XUSBPS-SOC USB Controller\n");
+
+	/* Need platform data for setup */
+	pdata = (struct xusbps_usb2_platform_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	/*
+	 * This is a host mode driver, verify that we're supposed to be
+	 * in host mode.
+	 */
+	if (!((pdata->operating_mode == XUSBPS_USB2_DR_HOST) ||
+	      (pdata->operating_mode == XUSBPS_USB2_MPH_HOST) ||
+	      (pdata->operating_mode == XUSBPS_USB2_DR_OTG))) {
+		dev_err(&pdev->dev, "Non Host Mode configured for %s. Wrong \
+				driver linked.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	irq = pdata->irq;
+	hcd->regs = pdata->regs;
+
+	if (hcd->regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto err2;
+	}
+
+	if (pdata->irq == 53)
+		pdata->clk = clk_get_sys("USB0_APER", NULL);
+	else
+		pdata->clk = clk_get_sys("USB1_APER", NULL);
+	if (IS_ERR(pdata->clk)) {
+		dev_err(&pdev->dev, "APER clock not found.\n");
+		retval = PTR_ERR(pdata->clk);
+		goto err2;
+	}
+
+	retval = clk_prepare_enable(pdata->clk);
+	if (retval) {
+		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
+		goto err_out_clk_put;
+	}
+
+	pdata->clk_rate_change_nb.notifier_call = xusbps_ehci_clk_notifier_cb;
+	pdata->clk_rate_change_nb.next = NULL;
+	if (clk_notifier_register(pdata->clk, &pdata->clk_rate_change_nb))
+		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
+
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->init && pdata->init(pdev)) {
+		retval = -ENODEV;
+		goto err_out_clk_unreg_notif;
+	}
+
+#ifdef CONFIG_USB_XUSBPS_OTG
+	if (pdata->otg) {
+		struct xusbps_otg *xotg;
+		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+		hcd->self.otg_port = 1;
+		hcd->phy = pdata->otg;
+		retval = otg_set_host(hcd->phy->otg,
+				&ehci_to_hcd(ehci)->self);
+		if (retval)
+			goto err_out_clk_unreg_notif;
+		xotg = xceiv_to_xotg(hcd->phy);
+		ehci->start_hnp = ehci_xusbps_start_hnp;
+		xotg->start_host = ehci_xusbps_otg_start_host;
+		xotg->stop_host = ehci_xusbps_otg_stop_host;
+		/* inform otg driver about host driver */
+		xusbps_update_transceiver();
+	} else {
+		retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+		if (retval)
+			goto err_out_clk_unreg_notif;
+
+		/*
+		 * Enable vbus on ULPI - zedboard requirement
+		 * to get host mode to work
+		 */
+		if (pdata->ulpi)
+			otg_set_vbus(pdata->ulpi->otg, 1);
+	}
+#else
+	/* Don't need to set host mode here. It will be done by tdi_reset() */
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (retval)
+		goto err_out_clk_unreg_notif;
+#endif
+	return retval;
+
+err_out_clk_unreg_notif:
+	clk_notifier_unregister(pdata->clk, &pdata->clk_rate_change_nb);
+	clk_disable_unprepare(pdata->clk);
+err_out_clk_put:
+	clk_put(pdata->clk);
+err2:
+	usb_put_hcd(hcd);
+err1:
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
+	if (pdata->exit)
+		pdata->exit(pdev);
+
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_xusbps_remove - shutdown processing for XUSBPS-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_xusbps_probe().
+ *
+ */
+static void usb_hcd_xusbps_remove(struct usb_hcd *hcd,
+			       struct platform_device *pdev)
+{
+	struct xusbps_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	usb_remove_hcd(hcd);
+
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, disable clock, etc.
+	 */
+	if (pdata->exit)
+		pdata->exit(pdev);
+	usb_put_hcd(hcd);
+	clk_notifier_unregister(pdata->clk, &pdata->clk_rate_change_nb);
+	clk_disable_unprepare(pdata->clk);
+	clk_put(pdata->clk);
+}
+
+static void ehci_xusbps_setup_phy(struct ehci_hcd *ehci,
+			       enum xusbps_usb2_phy_modes phy_mode,
+			       unsigned int port_offset)
+{
+	u32 portsc;
+
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[port_offset]);
+	portsc &= ~(PORT_PTS_MSK | PORT_PTS_PTW);
+
+	switch (phy_mode) {
+	case XUSBPS_USB2_PHY_ULPI:
+		portsc |= PORT_PTS_ULPI;
+		break;
+	case XUSBPS_USB2_PHY_SERIAL:
+		portsc |= PORT_PTS_SERIAL;
+		break;
+	case XUSBPS_USB2_PHY_UTMI_WIDE:
+		portsc |= PORT_PTS_PTW;
+		/* fall through */
+	case XUSBPS_USB2_PHY_UTMI:
+		portsc |= PORT_PTS_UTMI;
+		break;
+	case XUSBPS_USB2_PHY_NONE:
+		break;
+	}
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);
+}
+
+static void ehci_xusbps_usb_setup(struct ehci_hcd *ehci)
+{
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	struct xusbps_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if ((pdata->operating_mode == XUSBPS_USB2_DR_HOST) ||
+			(pdata->operating_mode == XUSBPS_USB2_DR_OTG))
+		ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 0);
+
+	if (pdata->operating_mode == XUSBPS_USB2_MPH_HOST) {
+		if (pdata->port_enables & XUSBPS_USB2_PORT0_ENABLED)
+			ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 0);
+		if (pdata->port_enables & XUSBPS_USB2_PORT1_ENABLED)
+			ehci_xusbps_setup_phy(ehci, pdata->phy_mode, 1);
+	}
+}
+
+/*
+ * FIXME USB: EHCI: remove ehci_port_power() routine
+ *(sha1: c73cee717e7d5da0698acb720ad1219646fe4f46)
+ */
+static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
+{
+	unsigned port;
+
+	if (!HCS_PPC (ehci->hcs_params))
+		return;
+
+	ehci_dbg (ehci, "...power%s ports...\n", is_on ? "up" : "down");
+	for (port = HCS_N_PORTS (ehci->hcs_params); port > 0; )
+		(void) ehci_hub_control(ehci_to_hcd(ehci),
+				is_on ? SetPortFeature : ClearPortFeature,
+				USB_PORT_FEAT_POWER,
+				port--, NULL, 0);
+	/* Flush those writes */
+	ehci_readl(ehci, &ehci->regs->command);
+	msleep(20);
+}
+
+/* called after powerup, by probe or system-pm "wakeup" */
+static int ehci_xusbps_reinit(struct ehci_hcd *ehci)
+{
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+
+	ehci_xusbps_usb_setup(ehci);
+#ifdef CONFIG_USB_XUSBPS_OTG
+	/* Don't turn off port power in OTG mode */
+	if (!hcd->phy)
+#endif
+		ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+struct ehci_xusbps {
+	struct ehci_hcd	ehci;
+
+#ifdef CONFIG_PM
+	/* Saved USB PHY settings, need to restore after deep sleep. */
+	u32 usb_ctrl;
+#endif
+};
+
+/* called during probe() after chip reset completes */
+static int ehci_xusbps_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+	    HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	retval = ehci_xusbps_reinit(ehci);
+	return retval;
+}
+
+static void ehci_xusbps_shutdown(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	if (ehci->regs)
+		ehci_shutdown(hcd);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int ehci_xusbps_drv_suspend(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct xusbps_usb2_platform_data *pdata = dev->platform_data;
+
+	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),
+			device_may_wakeup(dev));
+
+	clk_disable(pdata->clk);
+
+	return 0;
+}
+
+static int ehci_xusbps_drv_resume(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct xusbps_usb2_platform_data *pdata = dev->platform_data;
+	int ret;
+
+	ret = clk_enable(pdata->clk);
+	if (ret) {
+		dev_err(dev, "cannot enable clock. resume failed\n");
+		return ret;
+	}
+
+	ehci_prepare_ports_for_controller_resume(ehci);
+
+	usb_root_hub_lost_power(hcd->self.root_hub);
+
+	ehci_reset(ehci);
+	ehci_xusbps_reinit(ehci);
+
+	return 0;
+}
+
+static const struct dev_pm_ops ehci_xusbps_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ehci_xusbps_drv_suspend, ehci_xusbps_drv_resume)
+};
+#define EHCI_XUSBPS_PM_OPS	(&ehci_xusbps_pm_ops)
+
+#else /* ! CONFIG_PM_SLEEP */
+#define EHCI_XUSBPS_PM_OPS	NULL
+#endif /* ! CONFIG_PM_SLEEP */
+
+
+static const struct hc_driver ehci_xusbps_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Xilinx PS USB EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_xusbps),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_xusbps_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_xusbps_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+#ifdef CONFIG_USB_XUSBPS_OTG
+	.update_device = ehci_xusbps_update_device,
+#endif
+};
+
+static int ehci_xusbps_drv_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	/* FIXME we only want one one probe() not two */
+	return usb_hcd_xusbps_probe(&ehci_xusbps_hc_driver, pdev);
+}
+
+static int ehci_xusbps_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	/* FIXME we only want one one remove() not two */
+	usb_hcd_xusbps_remove(hcd, pdev);
+	return 0;
+}
+
+MODULE_ALIAS("platform:xusbps-ehci");
+
+static struct platform_driver ehci_xusbps_driver = {
+	.probe = ehci_xusbps_drv_probe,
+	.remove = ehci_xusbps_drv_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		.name = "xusbps-ehci",
+		.pm = EHCI_XUSBPS_PM_OPS,
+	},
+};
diff --git a/drivers/usb/host/ehci-xilinx-usbps.h b/drivers/usb/host/ehci-xilinx-usbps.h
new file mode 100644
index 0000000..bb0f2d4
--- /dev/null
+++ b/drivers/usb/host/ehci-xilinx-usbps.h
@@ -0,0 +1,33 @@
+/*
+ * Xilinx PS USB Host Controller Driver Header file.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on ehci-fsl.h file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _EHCI_XILINX_XUSBPS_H
+#define _EHCI_XILINX_XUSBPS_H
+
+#include <linux/usb/xilinx_usbps_otg.h>
+
+/* offsets for the non-ehci registers in the XUSBPS SOC USB controller */
+#define XUSBPS_SOC_USB_ULPIVP	0x170
+#define XUSBPS_SOC_USB_PORTSC1	0x184
+#define PORT_PTS_MSK		(3<<30)
+#define PORT_PTS_UTMI		(0<<30)
+#define PORT_PTS_ULPI		(2<<30)
+#define	PORT_PTS_SERIAL		(3<<30)
+#define PORT_PTS_PTW		(1<<28)
+#define XUSBPS_SOC_USB_PORTSC2	0x188
+
+#endif				/* _EHCI_XILINX_XUSBPS_H */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 36c3a82..d96280f 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -177,6 +177,14 @@ struct ehci_hcd {			/* one per controller */
 	unsigned long		resuming_ports;		/* which ports have
 			started to resume */
 
+#ifdef CONFIG_USB_XUSBPS_OTG
+	/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent
+	 */
+	void (*start_hnp)(struct ehci_hcd *ehci);
+#endif
+
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */
 	struct dma_pool		*qtd_pool;	/* one or more per qh */
diff --git a/drivers/usb/host/xusbps-dr-of.c b/drivers/usb/host/xusbps-dr-of.c
new file mode 100644
index 0000000..c75e23e
--- /dev/null
+++ b/drivers/usb/host/xusbps-dr-of.c
@@ -0,0 +1,336 @@
+/*
+ * Xilinx PS USB Driver for device tree support.
+ *
+ * Copyright (C) 2011 Xilinx, Inc.
+ *
+ * This file is based on fsl-mph-dr-of.c file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * Setup platform devices needed by the dual-role USB controller modules
+ * based on the description in flat device tree.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/xilinx_devices.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/usb/ulpi.h>
+
+#include "ehci-xilinx-usbps.h"
+
+static u64 dma_mask = 0xFFFFFFF0;
+
+struct xusbps_dev_data {
+	char *dr_mode;		/* controller mode */
+	char *drivers[3];	/* drivers to instantiate for this mode */
+	enum xusbps_usb2_operating_modes op_mode;	/* operating mode */
+};
+
+struct xusbps_host_data {
+	struct clk *clk;
+};
+
+static struct xusbps_dev_data dr_mode_data[] = {
+	{
+		.dr_mode = "host",
+		.drivers = { "xusbps-ehci", NULL, NULL, },
+		.op_mode = XUSBPS_USB2_DR_HOST,
+	},
+	{
+		.dr_mode = "otg",
+		.drivers = { "xusbps-otg", "xusbps-ehci", "xusbps-udc", },
+		.op_mode = XUSBPS_USB2_DR_OTG,
+	},
+	{
+		.dr_mode = "peripheral",
+		.drivers = { "xusbps-udc", NULL, NULL, },
+		.op_mode = XUSBPS_USB2_DR_DEVICE,
+	},
+};
+
+static struct xusbps_dev_data * get_dr_mode_data(
+		struct device_node *np)
+{
+	const unsigned char *prop;
+	int i;
+
+	prop = of_get_property(np, "dr_mode", NULL);
+	if (prop) {
+		for (i = 0; i < ARRAY_SIZE(dr_mode_data); i++) {
+			if (!strcmp(prop, dr_mode_data[i].dr_mode))
+				return &dr_mode_data[i];
+		}
+	}
+	pr_warn("%s: Invalid 'dr_mode' property, fallback to host mode\n",
+		np->full_name);
+	return &dr_mode_data[0]; /* mode not specified, use host */
+}
+
+static enum xusbps_usb2_phy_modes determine_usb_phy(const char *phy_type)
+{
+	if (!phy_type)
+		return XUSBPS_USB2_PHY_NONE;
+	if (!strcasecmp(phy_type, "ulpi"))
+		return XUSBPS_USB2_PHY_ULPI;
+	if (!strcasecmp(phy_type, "utmi"))
+		return XUSBPS_USB2_PHY_UTMI;
+	if (!strcasecmp(phy_type, "utmi_wide"))
+		return XUSBPS_USB2_PHY_UTMI_WIDE;
+	if (!strcasecmp(phy_type, "serial"))
+		return XUSBPS_USB2_PHY_SERIAL;
+
+	return XUSBPS_USB2_PHY_NONE;
+}
+
+static struct platform_device * xusbps_device_register(
+					struct platform_device *ofdev,
+					struct xusbps_usb2_platform_data *pdata,
+					const char *name, int id)
+{
+	struct platform_device *pdev;
+	const struct resource *res = ofdev->resource;
+	unsigned int num = ofdev->num_resources;
+	struct xusbps_usb2_platform_data *pdata1;
+	int retval;
+
+	pdev = platform_device_alloc(name, id);
+	if (!pdev) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	pdev->dev.parent = &ofdev->dev;
+
+	pdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;
+	pdev->dev.dma_mask = &dma_mask;
+	pdev->dev.of_node = ofdev->dev.of_node;
+
+	retval = platform_device_add_data(pdev, pdata, sizeof(*pdata));
+	if (retval)
+		goto error;
+
+	if (num) {
+		retval = platform_device_add_resources(pdev, res, num);
+		if (retval)
+			goto error;
+	}
+
+	retval = platform_device_add(pdev);
+	if (retval)
+		goto error;
+
+	pdata1 = pdev->dev.platform_data;
+	/* Copy the otg transceiver pointer into host/device platform data */
+	if (pdata1->otg)
+		pdata->otg = pdata1->otg;
+
+	return pdev;
+
+error:
+	platform_device_put(pdev);
+	return ERR_PTR(retval);
+}
+
+static int xusbps_dr_of_probe(struct platform_device *ofdev)
+{
+	struct device_node *np = ofdev->dev.of_node;
+	struct platform_device *usb_dev;
+	struct xusbps_usb2_platform_data data, *pdata;
+	struct xusbps_dev_data *dev_data;
+	struct xusbps_host_data *hdata;
+	const unsigned char *prop;
+	static unsigned int idx;
+	struct resource *res;
+	int i, phy_init;
+	int ret;
+
+	pdata = &data;
+	memset(pdata, 0, sizeof(data));
+
+	res = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&ofdev->dev,
+			"IRQ not found\n");
+		return -ENODEV;
+	}
+	pdata->irq = res->start;
+
+	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&ofdev->dev,
+			"Register base not found");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+						ofdev->name)) {
+		dev_err(&ofdev->dev, "Controller already in use\n");
+		return -EBUSY;
+	}
+
+	pdata->regs = ioremap(res->start, res->end - res->start + 1);
+	if (!pdata->regs) {
+		dev_err(&ofdev->dev, "unable to iomap registers\n");
+		release_mem_region(res->start, resource_size(res));
+		return -EFAULT;
+	}
+
+	dev_data = get_dr_mode_data(np);
+	pdata->operating_mode = dev_data->op_mode;
+
+	prop = of_get_property(np, "phy_type", NULL);
+	pdata->phy_mode = determine_usb_phy(prop);
+
+	hdata = kmalloc(sizeof(*hdata), GFP_KERNEL);
+	if (!hdata) {
+		dev_err(&ofdev->dev, "cannot allocate memory\n");
+		return -ENOMEM;
+	}
+	platform_set_drvdata(ofdev, hdata);
+
+	if (pdata->irq == 53)
+		hdata->clk = clk_get_sys("USB0_APER", NULL);
+	else
+		hdata->clk = clk_get_sys("USB1_APER", NULL);
+	if (IS_ERR(hdata->clk)) {
+		dev_err(&ofdev->dev, "APER clock not found.\n");
+		ret = PTR_ERR(hdata->clk);
+		goto err_free;
+	}
+
+	ret = clk_prepare_enable(hdata->clk);
+	if (ret) {
+		dev_err(&ofdev->dev, "Unable to enable APER clock.\n");
+		goto err_out_clk_put;
+	}
+
+	/* If ULPI phy type, set it up */
+	if (pdata->phy_mode == XUSBPS_USB2_PHY_ULPI) {
+		pdata->ulpi = otg_ulpi_create(&ulpi_viewport_access_ops,
+			ULPI_OTG_DRVVBUS | ULPI_OTG_DRVVBUS_EXT);
+		if (pdata->ulpi) {
+			pdata->ulpi->io_priv = pdata->regs +
+							XUSBPS_SOC_USB_ULPIVP;
+
+			phy_init = usb_phy_init(pdata->ulpi);
+			if (phy_init) {
+				dev_err(&ofdev->dev,
+					"Unable to init USB phy, missing?\n");
+				ret = -ENODEV;
+				goto err_out_clk_disable;
+			}
+		} else {
+			dev_err(&ofdev->dev,
+				"Unable to create ULPI transceiver\n");
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(dev_data->drivers); i++) {
+		if (!dev_data->drivers[i])
+			continue;
+		usb_dev = xusbps_device_register(ofdev, pdata,
+					dev_data->drivers[i], idx);
+		if (IS_ERR(usb_dev)) {
+			dev_err(&ofdev->dev, "Can't register usb device\n");
+			ret = PTR_ERR(usb_dev);
+			goto err_out_clk_disable;
+		}
+	}
+	idx++;
+	return 0;
+
+err_out_clk_disable:
+	clk_disable_unprepare(hdata->clk);
+err_out_clk_put:
+	clk_put(hdata->clk);
+err_free:
+	kfree(hdata);
+
+	return ret;
+}
+
+static int __unregister_subdev(struct device *dev, void *d)
+{
+	platform_device_unregister(to_platform_device(dev));
+	return 0;
+}
+
+static int xusbps_dr_of_remove(struct platform_device *ofdev)
+{
+	struct resource *res;
+	struct xusbps_host_data *hdata = platform_get_drvdata(ofdev);
+
+	res = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	device_for_each_child(&ofdev->dev, NULL, __unregister_subdev);
+	clk_disable_unprepare(hdata->clk);
+	clk_put(hdata->clk);
+	kfree(hdata);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int xusbps_dr_of_suspend(struct device *dev)
+{
+	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
+
+	clk_disable(hdata->clk);
+
+	return 0;
+}
+
+static int xusbps_dr_of_resume(struct device *dev)
+{
+	struct xusbps_host_data *hdata = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_enable(hdata->clk);
+	if (ret) {
+		dev_err(dev, "cannot enable clock. resume failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(xusbps_pm_ops, xusbps_dr_of_suspend,
+		xusbps_dr_of_resume);
+
+static const struct of_device_id xusbps_dr_of_match[] = {
+	{ .compatible = "xlnx,ps7-usb-1.00.a" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, xusbps_dr_of_match);
+
+static struct platform_driver xusbps_dr_driver = {
+	.driver = {
+		.name = "xusbps-dr",
+		.owner = THIS_MODULE,
+		.of_match_table = xusbps_dr_of_match,
+		.pm = &xusbps_pm_ops,
+	},
+	.probe	= xusbps_dr_of_probe,
+	.remove	= xusbps_dr_of_remove,
+};
+
+module_platform_driver(xusbps_dr_driver);
+
+MODULE_DESCRIPTION("XUSBPS DR OF devices driver");
+MODULE_AUTHOR("Xilinx");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/otg/Kconfig b/drivers/usb/otg/Kconfig
index 37962c9..ce4f747 100644
--- a/drivers/usb/otg/Kconfig
+++ b/drivers/usb/otg/Kconfig
@@ -138,4 +138,16 @@ config USB_MV_OTG
 
 	  To compile this driver as a module, choose M here.
 
+config USB_XUSBPS_OTG
+	tristate "Xilinx USB PS OTG dual-role support"
+	depends on USB && ARCH_ZYNQ && USB_EHCI_XUSBPS && USB_GADGET_XUSBPS && USB_OTG
+	select USB_OTG_UTILS
+	help
+	  Say Y here if you want to build Xilinx USB PS OTG
+	  driver in kernel. This driver implements role
+	  switch between EHCI host driver and USB gadget driver.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called xilinx_usbps_otg.
+
 endif # USB || OTG
diff --git a/drivers/usb/otg/Makefile b/drivers/usb/otg/Makefile
index a844b8d..e44d33e 100644
--- a/drivers/usb/otg/Makefile
+++ b/drivers/usb/otg/Makefile
@@ -22,3 +22,4 @@ fsl_usb2_otg-objs		:= fsl_otg.o otg_fsm.o
 obj-$(CONFIG_FSL_USB2_OTG)	+= fsl_usb2_otg.o
 obj-$(CONFIG_USB_MXS_PHY)	+= mxs-phy.o
 obj-$(CONFIG_USB_MV_OTG)	+= mv_otg.o
+obj-$(CONFIG_USB_XUSBPS_OTG)	+= xilinx_usbps_otg.o
diff --git a/drivers/usb/otg/ulpi.c b/drivers/usb/otg/ulpi.c
index 217339d..17ea3f2 100644
--- a/drivers/usb/otg/ulpi.c
+++ b/drivers/usb/otg/ulpi.c
@@ -47,6 +47,8 @@ struct ulpi_info {
 static struct ulpi_info ulpi_ids[] = {
 	ULPI_INFO(ULPI_ID(0x04cc, 0x1504), "NXP ISP1504"),
 	ULPI_INFO(ULPI_ID(0x0424, 0x0006), "SMSC USB331x"),
+	ULPI_INFO(ULPI_ID(0x0424, 0x0007), "SMSC USB3320"),
+	ULPI_INFO(ULPI_ID(0x0451, 0x1507), "TI TUSB1210"),
 };
 
 static int ulpi_set_otg_flags(struct usb_phy *phy)
diff --git a/drivers/usb/otg/xilinx_usbps_otg.c b/drivers/usb/otg/xilinx_usbps_otg.c
new file mode 100644
index 0000000..14c297e
--- /dev/null
+++ b/drivers/usb/otg/xilinx_usbps_otg.c
@@ -0,0 +1,2316 @@
+/*
+ * Xilinx PS USB otg driver.
+ *
+ * Copyright 2011 Xilinx, Inc.
+ *
+ * This file is based on langwell_otg.c file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* This driver helps to switch Xilinx OTG controller function between host
+ * and peripheral. It works with EHCI driver and Xilinx client controller
+ * driver together.
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/moduleparam.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/hcd.h>
+#include <linux/notifier.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/io.h>
+
+#include "../core/usb.h"
+
+#include <linux/xilinx_devices.h>
+#include <linux/usb/xilinx_usbps_otg.h>
+
+#define	DRIVER_NAME	"xusbps-otg"
+
+static const char driver_name[] = DRIVER_NAME;
+
+/* HSM timers */
+static inline struct xusbps_otg_timer *otg_timer_initializer
+(void (*function)(unsigned long), unsigned long expires, unsigned long data)
+{
+	struct xusbps_otg_timer *timer;
+	timer = kmalloc(sizeof(struct xusbps_otg_timer), GFP_KERNEL);
+	if (timer == NULL)
+		return timer;
+
+	timer->function = function;
+	timer->expires = expires;
+	timer->data = data;
+	return timer;
+}
+
+static struct xusbps_otg_timer *a_wait_vrise_tmr, *a_aidl_bdis_tmr,
+	*b_se0_srp_tmr, *b_srp_init_tmr;
+
+static struct list_head active_timers;
+
+static struct xusbps_otg *the_transceiver;
+
+/* host/client notify transceiver when event affects HNP state */
+void xusbps_update_transceiver(void)
+{
+	struct xusbps_otg *xotg = the_transceiver;
+
+	dev_dbg(xotg->dev, "transceiver is updated\n");
+
+	if (!xotg->qwork)
+		return ;
+
+	queue_work(xotg->qwork, &xotg->work);
+}
+EXPORT_SYMBOL(xusbps_update_transceiver);
+
+static int xusbps_otg_set_host(struct usb_otg *otg,
+					struct usb_bus *host)
+{
+	otg->host = host;
+
+	if (host) {
+		if (otg->default_a)
+			host->is_b_host = 0;
+		else
+			host->is_b_host = 1;
+	}
+
+	return 0;
+}
+
+static int xusbps_otg_set_peripheral(struct usb_otg *otg,
+					struct usb_gadget *gadget)
+{
+	otg->gadget = gadget;
+
+	if (gadget) {
+		if (otg->default_a)
+			gadget->is_a_peripheral = 1;
+		else
+			gadget->is_a_peripheral = 0;
+	}
+
+	return 0;
+}
+
+static int xusbps_otg_set_power(struct usb_phy *otg,
+				unsigned mA)
+{
+	return 0;
+}
+
+/* A-device drives vbus, controlled through PMIC CHRGCNTL register*/
+static int xusbps_otg_set_vbus(struct usb_otg *otg, bool enabled)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	u32 val;
+
+	dev_dbg(xotg->dev, "%s <--- %s\n", __func__, enabled ? "on" : "off");
+
+	/* Enable ulpi VBUS if required */
+	if (xotg->ulpi)
+		otg_set_vbus(xotg->ulpi->otg, enabled);
+
+	val = readl(xotg->base + CI_PORTSC1);
+
+	if (enabled)
+		writel((val | PORTSC_PP), xotg->base + CI_PORTSC1);
+	else
+		writel((val & ~PORTSC_PP), xotg->base + CI_PORTSC1);
+
+	dev_dbg(xotg->dev, "%s --->\n", __func__);
+
+	return 0;
+}
+
+/* Charge vbus for VBUS pulsing in SRP */
+static void xusbps_otg_chrg_vbus(int on)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	u32	val;
+
+	val = readl(xotg->base + CI_OTGSC) & ~OTGSC_INTSTS_MASK;
+
+	if (on)
+		/* stop discharging, start charging */
+		val = (val & ~OTGSC_VD) | OTGSC_VC;
+	else
+		/* stop charging */
+		val &= ~OTGSC_VC;
+
+	writel(val, xotg->base + CI_OTGSC);
+}
+
+#if 0
+
+/* Discharge vbus through a resistor to ground */
+static void xusbps_otg_dischrg_vbus(int on)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	u32	val;
+
+	val = readl(xotg->base + CI_OTGSC) & ~OTGSC_INTSTS_MASK;
+
+	if (on)
+		/* stop charging, start discharging */
+		val = (val & ~OTGSC_VC) | OTGSC_VD;
+	else
+		val &= ~OTGSC_VD;
+
+	writel(val, xotg->base + CI_OTGSC);
+}
+
+#endif
+
+/* Start SRP */
+static int xusbps_otg_start_srp(struct usb_otg *otg)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	u32				val;
+
+	dev_warn(xotg->dev, "Starting SRP...\n");
+	dev_dbg(xotg->dev, "%s --->\n", __func__);
+
+	val = readl(xotg->base + CI_OTGSC);
+
+	writel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HADP,
+				xotg->base + CI_OTGSC);
+
+	/* Check if the data plus is finished or not */
+	msleep(8);
+	val = readl(xotg->base + CI_OTGSC);
+	if (val & (OTGSC_HADP | OTGSC_DP))
+		dev_dbg(xotg->dev, "DataLine SRP Error\n");
+
+	/* If Vbus is valid, then update the hsm */
+	if (val & OTGSC_BSV) {
+		dev_dbg(xotg->dev, "no b_sess_vld interrupt\n");
+
+		xotg->hsm.b_sess_vld = 1;
+		xusbps_update_transceiver();
+		return 0;
+	}
+
+	dev_warn(xotg->dev, "Starting VBUS Pulsing...\n");
+
+	/* Disable interrupt - b_sess_vld */
+	val = readl(xotg->base + CI_OTGSC);
+	val &= (~(OTGSC_BSVIE | OTGSC_BSEIE));
+	writel(val, xotg->base + CI_OTGSC);
+
+	/* Start VBus SRP, drive vbus to generate VBus pulse */
+	xusbps_otg_chrg_vbus(1);
+	msleep(15);
+	xusbps_otg_chrg_vbus(0);
+
+	/* Enable interrupt - b_sess_vld*/
+	val = readl(xotg->base + CI_OTGSC);
+	dev_dbg(xotg->dev, "after VBUS pulse otgsc = %x\n", val);
+
+	val |= (OTGSC_BSVIE | OTGSC_BSEIE);
+	writel(val, xotg->base + CI_OTGSC);
+
+	/* If Vbus is valid, then update the hsm */
+	if (val & OTGSC_BSV) {
+		dev_dbg(xotg->dev, "no b_sess_vld interrupt\n");
+
+		xotg->hsm.b_sess_vld = 1;
+		xusbps_update_transceiver();
+	}
+
+	dev_dbg(xotg->dev, "%s <---\n", __func__);
+	return 0;
+}
+
+/* Start HNP */
+static int xusbps_otg_start_hnp(struct usb_otg *otg)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	unsigned long flag = 0;
+
+	dev_warn(xotg->dev, "Starting HNP...\n");
+	dev_dbg(xotg->dev, "%s --->\n", __func__);
+
+	if (xotg->otg.otg->default_a && xotg->otg.otg->host &&
+			xotg->otg.otg->host->b_hnp_enable) {
+		xotg->hsm.a_suspend_req = 1;
+		flag = 1;
+	}
+
+	if (!xotg->otg.otg->default_a && xotg->otg.otg->host &&
+			xotg->hsm.b_bus_req) {
+		xotg->hsm.b_bus_req = 0;
+		flag = 1;
+	}
+
+	if (flag) {
+		if (spin_trylock(&xotg->wq_lock)) {
+			xusbps_update_transceiver();
+			spin_unlock(&xotg->wq_lock);
+		}
+	} else
+		dev_warn(xotg->dev, "HNP not supported\n");
+
+	dev_dbg(xotg->dev, "%s <---\n", __func__);
+	return 0;
+}
+
+/* stop SOF via bus_suspend */
+static void xusbps_otg_loc_sof(int on)
+{
+	/* Not used */
+}
+
+static void xusbps_otg_phy_low_power(int on)
+{
+	/* Not used */
+}
+
+/* After drv vbus, add 2 ms delay to set PHCD */
+static void xusbps_otg_phy_low_power_wait(int on)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+
+	dev_dbg(xotg->dev, "add 2ms delay before programing PHCD\n");
+
+	mdelay(2);
+	xusbps_otg_phy_low_power(on);
+}
+
+#ifdef CONFIG_PM_SLEEP
+/* Enable/Disable OTG interrupt */
+static void xusbps_otg_intr(int on)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	u32				val;
+
+	dev_dbg(xotg->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	val = readl(xotg->base + CI_OTGSC);
+
+	/* OTGSC_INT_MASK doesn't contains 1msInt */
+	if (on) {
+		val = val | (OTGSC_INT_MASK);
+		writel(val, xotg->base + CI_OTGSC);
+	} else {
+		val = val & ~(OTGSC_INT_MASK);
+		writel(val, xotg->base + CI_OTGSC);
+	}
+
+	dev_dbg(xotg->dev, "%s <---\n", __func__);
+}
+#endif
+
+/* set HAAR: Hardware Assist Auto-Reset */
+static void xusbps_otg_HAAR(int on)
+{
+	/* Not used */
+}
+
+/* set HABA: Hardware Assist B-Disconnect to A-Connect */
+static void xusbps_otg_HABA(int on)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	u32				val;
+
+	dev_dbg(xotg->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	val = readl(xotg->base + CI_OTGSC);
+	if (on)
+		writel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HABA,
+					xotg->base + CI_OTGSC);
+	else
+		writel((val & ~OTGSC_INTSTS_MASK) & ~OTGSC_HABA,
+					xotg->base + CI_OTGSC);
+
+	dev_dbg(xotg->dev, "%s <---\n", __func__);
+}
+
+static int xusbps_otg_check_se0_srp(int on)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	int			delay_time = TB_SE0_SRP * 10;
+	u32			val;
+
+	dev_dbg(xotg->dev, "%s --->\n", __func__);
+
+	do {
+		udelay(100);
+		if (!delay_time--)
+			break;
+		val = readl(xotg->base + CI_PORTSC1);
+		val &= PORTSC_LS;
+	} while (!val);
+
+	dev_dbg(xotg->dev, "%s <---\n", __func__);
+	return val;
+}
+
+/* The timeout callback function to set time out bit */
+static void set_tmout(unsigned long indicator)
+{
+	*(int *)indicator = 1;
+}
+
+static void xusbps_otg_msg(unsigned long indicator)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+
+	switch (indicator) {
+	case 2:
+	case 4:
+	case 6:
+	case 7:
+		dev_warn(xotg->dev,
+			"OTG:%lu - deivce not responding\n", indicator);
+		break;
+	case 3:
+		dev_warn(xotg->dev,
+			"OTG:%lu - deivce not supported\n", indicator);
+		break;
+	default:
+		dev_warn(xotg->dev, "Do not have this msg\n");
+		break;
+	}
+}
+
+/* Initialize timers */
+static int xusbps_otg_init_timers(struct otg_hsm *hsm)
+{
+	/* HSM used timers */
+	a_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,
+				(unsigned long)&hsm->a_wait_vrise_tmout);
+	if (a_wait_vrise_tmr == NULL)
+		return -ENOMEM;
+	a_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,
+				(unsigned long)&hsm->a_aidl_bdis_tmout);
+	if (a_aidl_bdis_tmr == NULL)
+		return -ENOMEM;
+	b_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,
+				(unsigned long)&hsm->b_se0_srp);
+	if (b_se0_srp_tmr == NULL)
+		return -ENOMEM;
+	b_srp_init_tmr = otg_timer_initializer(&set_tmout, TB_SRP_INIT,
+				(unsigned long)&hsm->b_srp_init_tmout);
+	if (b_srp_init_tmr == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/* Free timers */
+static void xusbps_otg_free_timers(void)
+{
+	kfree(a_wait_vrise_tmr);
+	kfree(a_aidl_bdis_tmr);
+	kfree(b_se0_srp_tmr);
+	kfree(b_srp_init_tmr);
+}
+
+/* The timeout callback function to set time out bit */
+static void xusbps_otg_timer_fn(unsigned long indicator)
+{
+	struct xusbps_otg *xotg = the_transceiver;
+
+	*(int *)indicator = 1;
+
+	dev_dbg(xotg->dev, "kernel timer - timeout\n");
+
+	xusbps_update_transceiver();
+}
+
+/* kernel timer used instead of HW based interrupt */
+static void xusbps_otg_add_ktimer(enum xusbps_otg_timer_type timers)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	unsigned long		j = jiffies;
+	unsigned long		data, time;
+
+	switch (timers) {
+	case TA_WAIT_VRISE_TMR:
+		xotg->hsm.a_wait_vrise_tmout = 0;
+		data = (unsigned long)&xotg->hsm.a_wait_vrise_tmout;
+		time = TA_WAIT_VRISE;
+		break;
+	case TA_WAIT_BCON_TMR:
+		xotg->hsm.a_wait_bcon_tmout = 0;
+		data = (unsigned long)&xotg->hsm.a_wait_bcon_tmout;
+		time = TA_WAIT_BCON;
+		break;
+	case TA_AIDL_BDIS_TMR:
+		xotg->hsm.a_aidl_bdis_tmout = 0;
+		data = (unsigned long)&xotg->hsm.a_aidl_bdis_tmout;
+		time = TA_AIDL_BDIS;
+		break;
+	case TB_ASE0_BRST_TMR:
+		xotg->hsm.b_ase0_brst_tmout = 0;
+		data = (unsigned long)&xotg->hsm.b_ase0_brst_tmout;
+		time = TB_ASE0_BRST;
+		break;
+	case TB_SRP_INIT_TMR:
+		xotg->hsm.b_srp_init_tmout = 0;
+		data = (unsigned long)&xotg->hsm.b_srp_init_tmout;
+		time = TB_SRP_INIT;
+		break;
+	case TB_SRP_FAIL_TMR:
+		xotg->hsm.b_srp_fail_tmout = 0;
+		data = (unsigned long)&xotg->hsm.b_srp_fail_tmout;
+		time = TB_SRP_FAIL;
+		break;
+	case TB_BUS_SUSPEND_TMR:
+		xotg->hsm.b_bus_suspend_tmout = 0;
+		data = (unsigned long)&xotg->hsm.b_bus_suspend_tmout;
+		time = TB_BUS_SUSPEND;
+		break;
+	default:
+		dev_dbg(xotg->dev, "unkown timer, cannot enable it\n");
+		return;
+	}
+
+	xotg->hsm_timer.data = data;
+	xotg->hsm_timer.function = xusbps_otg_timer_fn;
+	xotg->hsm_timer.expires = j + time * HZ / 1000; /* milliseconds */
+
+	add_timer(&xotg->hsm_timer);
+
+	dev_dbg(xotg->dev, "add timer successfully\n");
+}
+
+/* Add timer to timer list */
+static void xusbps_otg_add_timer(void *gtimer)
+{
+	struct xusbps_otg *xotg = the_transceiver;
+	struct xusbps_otg_timer *timer = (struct xusbps_otg_timer *)gtimer;
+	struct xusbps_otg_timer *tmp_timer;
+	u32	val32;
+
+	/* Check if the timer is already in the active list,
+	 * if so update timer count
+	 */
+	list_for_each_entry(tmp_timer, &active_timers, list)
+		if (tmp_timer == timer) {
+			timer->count = timer->expires;
+			return;
+		}
+	timer->count = timer->expires;
+
+	if (list_empty(&active_timers)) {
+		val32 = readl(xotg->base + CI_OTGSC);
+		writel(val32 | OTGSC_1MSE, xotg->base + CI_OTGSC);
+	}
+
+	list_add_tail(&timer->list, &active_timers);
+}
+
+/* Remove timer from the timer list; clear timeout status */
+static void xusbps_otg_del_timer(void *gtimer)
+{
+	struct xusbps_otg *xotg = the_transceiver;
+	struct xusbps_otg_timer *timer = (struct xusbps_otg_timer *)gtimer;
+	struct xusbps_otg_timer *tmp_timer, *del_tmp;
+	u32 val32;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)
+		if (tmp_timer == timer)
+			list_del(&timer->list);
+
+	if (list_empty(&active_timers)) {
+		val32 = readl(xotg->base + CI_OTGSC);
+		writel(val32 & ~OTGSC_1MSE, xotg->base + CI_OTGSC);
+	}
+}
+
+/* Reduce timer count by 1, and find timeout conditions.*/
+static int xusbps_otg_tick_timer(u32 *int_sts)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	struct xusbps_otg_timer *tmp_timer, *del_tmp;
+	int expired = 0;
+
+	list_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list) {
+		tmp_timer->count--;
+		/* check if timer expires */
+		if (!tmp_timer->count) {
+			list_del(&tmp_timer->list);
+			tmp_timer->function(tmp_timer->data);
+			expired = 1;
+		}
+	}
+
+	if (list_empty(&active_timers)) {
+		dev_dbg(xotg->dev, "tick timer: disable 1ms int\n");
+		*int_sts = *int_sts & ~OTGSC_1MSE;
+	}
+	return expired;
+}
+
+static void reset_otg(void)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	int			delay_time = 1000;
+	u32			val;
+
+	dev_dbg(xotg->dev, "reseting OTG controller ...\n");
+	val = readl(xotg->base + CI_USBCMD);
+	writel(val | USBCMD_RST, xotg->base + CI_USBCMD);
+	do {
+		udelay(100);
+		if (!delay_time--)
+			dev_dbg(xotg->dev, "reset timeout\n");
+		val = readl(xotg->base + CI_USBCMD);
+		val &= USBCMD_RST;
+	} while (val != 0);
+	dev_dbg(xotg->dev, "reset done.\n");
+}
+
+static void set_host_mode(void)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	u32			val;
+
+	reset_otg();
+	val = readl(xotg->base + CI_USBMODE);
+	val = (val & (~USBMODE_CM)) | USBMODE_HOST;
+	writel(val, xotg->base + CI_USBMODE);
+}
+
+static void set_client_mode(void)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	u32			val;
+
+	reset_otg();
+	val = readl(xotg->base + CI_USBMODE);
+	val = (val & (~USBMODE_CM)) | USBMODE_DEVICE;
+	writel(val, xotg->base + CI_USBMODE);
+}
+
+static void init_hsm(void)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	u32				val32;
+
+	/* read OTGSC after reset */
+	val32 = readl(xotg->base + CI_OTGSC);
+
+	/* set init state */
+	if (val32 & OTGSC_ID) {
+		xotg->hsm.id = 1;
+		xotg->otg.otg->default_a = 0;
+		set_client_mode();
+		xotg->otg.state = OTG_STATE_B_IDLE;
+	} else {
+		xotg->hsm.id = 0;
+		xotg->otg.otg->default_a = 1;
+		set_host_mode();
+		xotg->otg.state = OTG_STATE_A_IDLE;
+	}
+
+	/* set session indicator */
+	if (!xotg->otg.otg->default_a) {
+		if (val32 & OTGSC_BSE)
+			xotg->hsm.b_sess_end = 1;
+		if (val32 & OTGSC_BSV)
+			xotg->hsm.b_sess_vld = 1;
+	} else {
+		if (val32 & OTGSC_ASV)
+			xotg->hsm.a_sess_vld = 1;
+		if (val32 & OTGSC_AVV)
+			xotg->hsm.a_vbus_vld = 1;
+	}
+
+	/* defautly power the bus */
+	xotg->hsm.a_bus_req = 0;
+	xotg->hsm.a_bus_drop = 0;
+	/* defautly don't request bus as B device */
+	xotg->hsm.b_bus_req = 0;
+	/* no system error */
+	xotg->hsm.a_clr_err = 0;
+
+	xusbps_otg_phy_low_power_wait(1);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void update_hsm(void)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	u32				val32;
+
+	/* read OTGSC */
+	val32 = readl(xotg->base + CI_OTGSC);
+
+	xotg->hsm.id = !!(val32 & OTGSC_ID);
+	if (!xotg->otg.otg->default_a) {
+		xotg->hsm.b_sess_end = !!(val32 & OTGSC_BSE);
+		xotg->hsm.b_sess_vld = !!(val32 & OTGSC_BSV);
+	} else {
+		xotg->hsm.a_sess_vld = !!(val32 & OTGSC_ASV);
+		xotg->hsm.a_vbus_vld = !!(val32 & OTGSC_AVV);
+	}
+}
+#endif
+
+static irqreturn_t otg_dummy_irq(int irq, void *_dev)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	void __iomem		*reg_base = _dev;
+	u32			val;
+	u32			int_mask = 0;
+
+	val = readl(reg_base + CI_USBMODE);
+	if ((val & USBMODE_CM) != USBMODE_DEVICE)
+		return IRQ_NONE;
+
+	val = readl(reg_base + CI_USBSTS);
+	int_mask = val & INTR_DUMMY_MASK;
+
+	if (int_mask == 0)
+		return IRQ_NONE;
+
+	/* Clear interrupts */
+	writel(int_mask, reg_base + CI_USBSTS);
+
+	/* clear hsm.b_conn here since host driver can't detect it
+	*  otg_dummy_irq called means B-disconnect happened.
+	*/
+	if (xotg->hsm.b_conn) {
+		xotg->hsm.b_conn = 0;
+		if (spin_trylock(&xotg->wq_lock)) {
+			xusbps_update_transceiver();
+			spin_unlock(&xotg->wq_lock);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t otg_irq(int irq, void *_dev)
+{
+	struct xusbps_otg		*xotg = _dev;
+	u32				int_sts, int_en;
+	u32				int_mask = 0;
+	int				flag = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&xotg->lock, flags);
+	int_sts = readl(xotg->base + CI_OTGSC);
+	int_en = (int_sts & OTGSC_INTEN_MASK) >> 8;
+	int_mask = int_sts & int_en;
+
+	if (int_mask == 0) {
+		spin_unlock_irqrestore(&xotg->lock, flags);
+		return IRQ_NONE;
+	}
+
+	writel((int_sts & ~OTGSC_INTSTS_MASK) | int_mask,
+					xotg->base + CI_OTGSC);
+	if (int_mask & OTGSC_IDIS) {
+		dev_dbg(xotg->dev, "%s: id change int\n", __func__);
+		xotg->hsm.id = (int_sts & OTGSC_ID) ? 1 : 0;
+		dev_dbg(xotg->dev, "id = %d\n", xotg->hsm.id);
+		flag = 1;
+	}
+	if (int_mask & OTGSC_DPIS) {
+		dev_dbg(xotg->dev, "%s: data pulse int\n", __func__);
+		if (xotg->otg.otg->default_a)
+			xotg->hsm.a_srp_det = (int_sts & OTGSC_DPS) ? 1 : 0;
+		dev_dbg(xotg->dev, "data pulse = %d\n", xotg->hsm.a_srp_det);
+		flag = 1;
+	}
+	if (int_mask & OTGSC_BSEIS) {
+		dev_dbg(xotg->dev, "%s: b session end int\n", __func__);
+		if (!xotg->otg.otg->default_a)
+			xotg->hsm.b_sess_end = (int_sts & OTGSC_BSE) ? 1 : 0;
+		dev_dbg(xotg->dev, "b_sess_end = %d\n", xotg->hsm.b_sess_end);
+		flag = 1;
+	}
+	if (int_mask & OTGSC_BSVIS) {
+		dev_dbg(xotg->dev, "%s: b session valid int\n", __func__);
+		if (!xotg->otg.otg->default_a)
+			xotg->hsm.b_sess_vld = (int_sts & OTGSC_BSV) ? 1 : 0;
+		dev_dbg(xotg->dev, "b_sess_vld = %d\n", xotg->hsm.b_sess_vld);
+		flag = 1;
+	}
+	if (int_mask & OTGSC_ASVIS) {
+		dev_dbg(xotg->dev, "%s: a session valid int\n", __func__);
+		if (xotg->otg.otg->default_a)
+			xotg->hsm.a_sess_vld = (int_sts & OTGSC_ASV) ? 1 : 0;
+		dev_dbg(xotg->dev, "a_sess_vld = %d\n", xotg->hsm.a_sess_vld);
+		flag = 1;
+	}
+	if (int_mask & OTGSC_AVVIS) {
+		dev_dbg(xotg->dev, "%s: a vbus valid int\n", __func__);
+		if (xotg->otg.otg->default_a)
+			xotg->hsm.a_vbus_vld = (int_sts & OTGSC_AVV) ? 1 : 0;
+		dev_dbg(xotg->dev, "a_vbus_vld = %d\n", xotg->hsm.a_vbus_vld);
+		flag = 1;
+	}
+
+	if (int_mask & OTGSC_1MSS) {
+		/* need to schedule otg_work if any timer is expired */
+		if (xusbps_otg_tick_timer(&int_sts))
+			flag = 1;
+	}
+
+	if (flag)
+		xusbps_update_transceiver();
+
+	spin_unlock_irqrestore(&xotg->lock, flags);
+	return IRQ_HANDLED;
+}
+
+/**
+ * xotg_usbdev_notify - Notifier function called by usb core.
+ * @self:	Pointer to notifier_block structure
+ * @action:	action which caused the notifier function call.
+ * @dev:	Pointer to the usb device structure.
+ *
+ * This function is a call back function used by usb core to notify
+ * device attach/detach events. This is used by OTG state machine.
+ *
+ * returns:	Always returns NOTIFY_OK.
+ **/
+static int xotg_usbdev_notify(struct notifier_block *self,
+			       unsigned long action, void *dev)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	struct usb_phy *otg = &xotg->otg;
+	unsigned long otg_port;
+	struct usb_device *udev_otg = NULL;
+	struct usb_device *udev;
+	u32 flag;
+
+	udev = (struct usb_device *)dev;
+
+	if (!otg->otg->host)
+		return NOTIFY_OK;
+
+	otg_port = otg->otg->host->otg_port;
+
+	if (otg->otg->host->root_hub)
+		udev_otg = usb_hub_find_child(otg->otg->host->root_hub,
+								otg_port - 1);
+
+	/* Not otg device notification */
+	if (udev != udev_otg)
+		return NOTIFY_OK;
+
+	switch (action) {
+	case USB_DEVICE_ADD:
+		if (xotg->otg.otg->default_a == 1)
+			xotg->hsm.b_conn = 1;
+		else
+			xotg->hsm.a_conn = 1;
+		flag = 1;
+		break;
+	case USB_DEVICE_REMOVE:
+		if (xotg->otg.otg->default_a == 1)
+			xotg->hsm.b_conn = 0;
+		else
+			xotg->hsm.a_conn = 0;
+		flag = 1;
+		break;
+	}
+	if (flag)
+		xusbps_update_transceiver();
+
+	return NOTIFY_OK;
+}
+
+static void xusbps_otg_work(struct work_struct *work)
+{
+	struct xusbps_otg		*xotg;
+	int				retval;
+
+	xotg = container_of(work, struct xusbps_otg, work);
+
+	dev_dbg(xotg->dev, "%s: old state = %s\n", __func__,
+			otg_state_string(xotg->otg.state));
+
+	switch (xotg->otg.state) {
+	case OTG_STATE_UNDEFINED:
+	case OTG_STATE_B_IDLE:
+		if (!xotg->hsm.id) {
+			xusbps_otg_del_timer(b_srp_init_tmr);
+			del_timer_sync(&xotg->hsm_timer);
+
+			xotg->otg.otg->default_a = 1;
+			xotg->hsm.a_srp_det = 0;
+
+			xusbps_otg_chrg_vbus(0);
+			set_host_mode();
+			xusbps_otg_phy_low_power(1);
+
+			xotg->otg.state = OTG_STATE_A_IDLE;
+			xusbps_update_transceiver();
+		} else if (xotg->hsm.b_sess_vld) {
+			xusbps_otg_del_timer(b_srp_init_tmr);
+			del_timer_sync(&xotg->hsm_timer);
+			xotg->hsm.b_bus_req = 0;
+			xotg->hsm.b_sess_end = 0;
+			xotg->hsm.a_bus_suspend = 0;
+			xusbps_otg_chrg_vbus(0);
+
+			if (xotg->start_peripheral) {
+				xotg->start_peripheral(&xotg->otg);
+				xotg->otg.state = OTG_STATE_B_PERIPHERAL;
+			} else
+				dev_dbg(xotg->dev,
+					"client driver not loaded\n");
+		} else if (xotg->hsm.b_srp_init_tmout) {
+			xotg->hsm.b_srp_init_tmout = 0;
+			dev_warn(xotg->dev, "SRP init timeout\n");
+		} else if (xotg->hsm.b_srp_fail_tmout) {
+			xotg->hsm.b_srp_fail_tmout = 0;
+			xotg->hsm.b_bus_req = 0;
+
+			/* No silence failure */
+			xusbps_otg_msg(6);
+			dev_warn(xotg->dev, "SRP failed\n");
+		} else if (xotg->hsm.b_bus_req && xotg->hsm.b_sess_end) {
+			del_timer_sync(&xotg->hsm_timer);
+			/* workaround for b_se0_srp detection */
+			retval = xusbps_otg_check_se0_srp(0);
+			if (retval) {
+				xotg->hsm.b_bus_req = 0;
+				dev_dbg(xotg->dev, "LS isn't SE0, try later\n");
+			} else {
+				/* clear the PHCD before start srp */
+				xusbps_otg_phy_low_power(0);
+
+				/* Start SRP */
+				xusbps_otg_add_timer(b_srp_init_tmr);
+				xotg->otg.otg->start_srp(xotg->otg.otg);
+				xusbps_otg_del_timer(b_srp_init_tmr);
+				xusbps_otg_add_ktimer(TB_SRP_FAIL_TMR);
+
+				/* reset PHY low power mode here */
+				xusbps_otg_phy_low_power_wait(1);
+			}
+		}
+		break;
+	case OTG_STATE_B_SRP_INIT:
+		if (!xotg->hsm.id) {
+			xotg->otg.otg->default_a = 1;
+			xotg->hsm.a_srp_det = 0;
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xusbps_otg_chrg_vbus(0);
+			set_host_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_A_IDLE;
+			xusbps_update_transceiver();
+		} else if (xotg->hsm.b_sess_vld) {
+			xusbps_otg_chrg_vbus(0);
+			if (xotg->start_peripheral) {
+				xotg->start_peripheral(&xotg->otg);
+				xotg->otg.state = OTG_STATE_B_PERIPHERAL;
+			} else
+				dev_dbg(xotg->dev,
+					"client driver not loaded\n");
+		}
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		if (!xotg->hsm.id) {
+			xotg->otg.otg->default_a = 1;
+			xotg->hsm.a_srp_det = 0;
+
+			xusbps_otg_chrg_vbus(0);
+
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			set_host_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_A_IDLE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.b_sess_vld) {
+			xotg->hsm.b_hnp_enable = 0;
+			xotg->hsm.b_bus_req = 0;
+
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			xotg->otg.state = OTG_STATE_B_IDLE;
+		} else if (xotg->hsm.b_bus_req && xotg->otg.otg->gadget &&
+					xotg->otg.otg->gadget->b_hnp_enable &&
+					xotg->hsm.a_bus_suspend) {
+			dev_warn(xotg->dev, "HNP detected\n");
+
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			xusbps_otg_HAAR(1);
+			xotg->hsm.a_conn = 0;
+
+			xotg->otg.state = OTG_STATE_B_WAIT_ACON;
+			if (xotg->start_host) {
+				xotg->start_host(&xotg->otg);
+			} else
+				dev_dbg(xotg->dev,
+						"host driver not loaded.\n");
+
+			xotg->hsm.a_bus_resume = 0;
+			xusbps_otg_add_ktimer(TB_ASE0_BRST_TMR);
+		}
+		break;
+
+	case OTG_STATE_B_WAIT_ACON:
+		if (!xotg->hsm.id) {
+			/* delete hsm timer for b_ase0_brst_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			xotg->otg.otg->default_a = 1;
+			xotg->hsm.a_srp_det = 0;
+
+			xusbps_otg_chrg_vbus(0);
+
+			xusbps_otg_HAAR(0);
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			set_host_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_A_IDLE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.b_sess_vld) {
+			/* delete hsm timer for b_ase0_brst_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			xotg->hsm.b_hnp_enable = 0;
+			xotg->hsm.b_bus_req = 0;
+
+			xusbps_otg_chrg_vbus(0);
+			xusbps_otg_HAAR(0);
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			set_client_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+		} else if (xotg->hsm.a_conn) {
+			/* delete hsm timer for b_ase0_brst_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			xusbps_otg_HAAR(0);
+			xotg->otg.state = OTG_STATE_B_HOST;
+			xusbps_update_transceiver();
+		} else if (xotg->hsm.a_bus_resume ||
+				xotg->hsm.b_ase0_brst_tmout) {
+			dev_warn(xotg->dev, "A device connect failed\n");
+			/* delete hsm timer for b_ase0_brst_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			xusbps_otg_HAAR(0);
+			xusbps_otg_msg(7);
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			xotg->hsm.a_bus_suspend = 0;
+			xotg->hsm.b_bus_req = 0;
+			xotg->otg.state = OTG_STATE_B_PERIPHERAL;
+			if (xotg->start_peripheral)
+				xotg->start_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver not loaded.\n");
+		}
+		break;
+
+	case OTG_STATE_B_HOST:
+		if (!xotg->hsm.id) {
+			xotg->otg.otg->default_a = 1;
+			xotg->hsm.a_srp_det = 0;
+
+			xusbps_otg_chrg_vbus(0);
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			set_host_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_A_IDLE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.b_sess_vld) {
+			xotg->hsm.b_hnp_enable = 0;
+			xotg->hsm.b_bus_req = 0;
+
+			xusbps_otg_chrg_vbus(0);
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			set_client_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+		} else if ((!xotg->hsm.b_bus_req) ||
+				(!xotg->hsm.a_conn)) {
+			xotg->hsm.b_bus_req = 0;
+			xusbps_otg_loc_sof(0);
+
+			/* Fix: The kernel crash in usb_port_suspend
+				during HNP */
+			msleep(20);
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			xotg->hsm.a_bus_suspend = 0;
+			xotg->otg.state = OTG_STATE_B_PERIPHERAL;
+			if (xotg->start_peripheral)
+				xotg->start_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+						"client driver not loaded.\n");
+		}
+		break;
+
+	case OTG_STATE_A_IDLE:
+		xotg->otg.otg->default_a = 1;
+		if (xotg->hsm.id) {
+			xotg->otg.otg->default_a = 0;
+			xotg->hsm.b_bus_req = 0;
+			xotg->hsm.vbus_srp_up = 0;
+
+			xusbps_otg_chrg_vbus(0);
+			set_client_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.a_bus_drop &&
+			(xotg->hsm.a_srp_det || xotg->hsm.a_bus_req)) {
+			dev_warn(xotg->dev,
+			"SRP detected or User has requested for the Bus\n");
+			xusbps_otg_phy_low_power(0);
+
+			/* Turn on VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, true);
+
+			xotg->hsm.vbus_srp_up = 0;
+			xotg->hsm.a_wait_vrise_tmout = 0;
+			xusbps_otg_add_timer(a_wait_vrise_tmr);
+			xotg->otg.state = OTG_STATE_A_WAIT_VRISE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.a_bus_drop && xotg->hsm.a_sess_vld) {
+			xotg->hsm.vbus_srp_up = 1;
+		} else if (!xotg->hsm.a_sess_vld && xotg->hsm.vbus_srp_up) {
+			msleep(10);
+			xusbps_otg_phy_low_power(0);
+
+			/* Turn on VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, true);
+			xotg->hsm.a_srp_det = 1;
+			xotg->hsm.vbus_srp_up = 0;
+			xotg->hsm.a_wait_vrise_tmout = 0;
+			xusbps_otg_add_timer(a_wait_vrise_tmr);
+			xotg->otg.state = OTG_STATE_A_WAIT_VRISE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.a_sess_vld &&
+				!xotg->hsm.vbus_srp_up) {
+			xusbps_otg_phy_low_power(1);
+		}
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		if (xotg->hsm.id) {
+			xusbps_otg_del_timer(a_wait_vrise_tmr);
+			xotg->hsm.b_bus_req = 0;
+			xotg->otg.otg->default_a = 0;
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			set_client_mode();
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+		} else if (xotg->hsm.a_vbus_vld) {
+			xusbps_otg_del_timer(a_wait_vrise_tmr);
+			xotg->hsm.b_conn = 0;
+			if (xotg->start_host)
+				xotg->start_host(&xotg->otg);
+			else {
+				dev_dbg(xotg->dev, "host driver not loaded.\n");
+				break;
+			}
+			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+			xotg->otg.state = OTG_STATE_A_WAIT_BCON;
+		} else if (xotg->hsm.a_wait_vrise_tmout) {
+			xotg->hsm.b_conn = 0;
+			if (xotg->hsm.a_vbus_vld) {
+				if (xotg->start_host)
+					xotg->start_host(&xotg->otg);
+				else {
+					dev_dbg(xotg->dev,
+						"host driver not loaded.\n");
+					break;
+				}
+				xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+				xotg->otg.state = OTG_STATE_A_WAIT_BCON;
+			} else {
+
+				/* Turn off VBus */
+				xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+				xusbps_otg_phy_low_power_wait(1);
+				xotg->otg.state = OTG_STATE_A_VBUS_ERR;
+			}
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		if (xotg->hsm.id) {
+			/* delete hsm timer for a_wait_bcon_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			xotg->otg.otg->default_a = 0;
+			xotg->hsm.b_bus_req = 0;
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			set_client_mode();
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.a_vbus_vld) {
+			/* delete hsm timer for a_wait_bcon_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		} else if (xotg->hsm.a_bus_drop ||
+				(xotg->hsm.a_wait_bcon_tmout &&
+				!xotg->hsm.a_bus_req)) {
+			dev_warn(xotg->dev, "B connect timeout\n");
+			/* delete hsm timer for a_wait_bcon_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (xotg->hsm.b_conn) {
+			/* delete hsm timer for a_wait_bcon_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			xotg->hsm.a_suspend_req = 0;
+			/* Make it zero as it should not be used by driver */
+			xotg->hsm.a_bus_req = 0;
+			xotg->hsm.a_srp_det = 0;
+			xotg->otg.state = OTG_STATE_A_HOST;
+		}
+		break;
+	case OTG_STATE_A_HOST:
+		if (xotg->hsm.id) {
+			xotg->otg.otg->default_a = 0;
+			xotg->hsm.b_bus_req = 0;
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			set_client_mode();
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+			xusbps_update_transceiver();
+		} else if (xotg->hsm.a_bus_drop ||
+				(xotg->otg.otg->host &&
+				!xotg->otg.otg->host->b_hnp_enable &&
+					!xotg->hsm.a_bus_req)) {
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (!xotg->hsm.a_vbus_vld) {
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		} else if (xotg->otg.otg->host &&
+				xotg->otg.otg->host->b_hnp_enable &&
+				(!xotg->hsm.a_bus_req ||
+					xotg->hsm.a_suspend_req)) {
+			/* Set HABA to enable hardware assistance to signal
+			 *  A-connect after receiver B-disconnect. Hardware
+			 *  will then set client mode and enable URE, SLE and
+			 *  PCE after the assistance. otg_dummy_irq is used to
+			 *  clean these ints when client driver is not resumed.
+			 */
+			if (request_irq(xotg->irq, otg_dummy_irq, IRQF_SHARED,
+					driver_name, xotg->base) != 0) {
+				dev_dbg(xotg->dev,
+					"request interrupt %d failed\n",
+						xotg->irq);
+			}
+			/* set HABA */
+			xusbps_otg_HABA(1);
+			xotg->hsm.b_bus_resume = 0;
+			xotg->hsm.a_aidl_bdis_tmout = 0;
+			xusbps_otg_loc_sof(0);
+			/* clear PHCD to enable HW timer */
+			xusbps_otg_phy_low_power(0);
+			xusbps_otg_add_timer(a_aidl_bdis_tmr);
+			xotg->otg.state = OTG_STATE_A_SUSPEND;
+		} else if (!xotg->hsm.b_conn || !xotg->hsm.a_bus_req) {
+			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+			xotg->otg.state = OTG_STATE_A_WAIT_BCON;
+		}
+		break;
+	case OTG_STATE_A_SUSPEND:
+		if (xotg->hsm.id) {
+			xusbps_otg_del_timer(a_aidl_bdis_tmr);
+			xusbps_otg_HABA(0);
+			free_irq(xotg->irq, xotg->base);
+			xotg->otg.otg->default_a = 0;
+			xotg->hsm.b_bus_req = 0;
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			set_client_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+			xusbps_update_transceiver();
+		} else if (xotg->hsm.a_bus_req ||
+				xotg->hsm.b_bus_resume) {
+			xusbps_otg_del_timer(a_aidl_bdis_tmr);
+			xusbps_otg_HABA(0);
+			free_irq(xotg->irq, xotg->base);
+			xotg->hsm.a_suspend_req = 0;
+			xusbps_otg_loc_sof(1);
+			xotg->otg.state = OTG_STATE_A_HOST;
+		} else if (xotg->hsm.a_aidl_bdis_tmout ||
+				xotg->hsm.a_bus_drop) {
+			dev_warn(xotg->dev, "B disconnect timeout\n");
+			xusbps_otg_del_timer(a_aidl_bdis_tmr);
+			xusbps_otg_HABA(0);
+			free_irq(xotg->irq, xotg->base);
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (!xotg->hsm.b_conn && xotg->otg.otg->host &&
+				xotg->otg.otg->host->b_hnp_enable) {
+			xusbps_otg_del_timer(a_aidl_bdis_tmr);
+			xusbps_otg_HABA(0);
+			free_irq(xotg->irq, xotg->base);
+
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			xotg->hsm.b_bus_suspend = 0;
+			xotg->hsm.b_bus_suspend_vld = 0;
+
+			xotg->otg.state = OTG_STATE_A_PERIPHERAL;
+			/* msleep(200); */
+			if (xotg->start_peripheral)
+				xotg->start_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver not loaded.\n");
+			xusbps_otg_add_ktimer(TB_BUS_SUSPEND_TMR);
+			break;
+		} else if (!xotg->hsm.a_vbus_vld) {
+			xusbps_otg_del_timer(a_aidl_bdis_tmr);
+			xusbps_otg_HABA(0);
+			free_irq(xotg->irq, xotg->base);
+			if (xotg->stop_host)
+				xotg->stop_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"host driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		}
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		if (xotg->hsm.id) {
+			/* delete hsm timer for b_bus_suspend_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+			xotg->otg.otg->default_a = 0;
+			xotg->hsm.b_bus_req = 0;
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			set_client_mode();
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+			xusbps_update_transceiver();
+		} else if (!xotg->hsm.a_vbus_vld) {
+			/* delete hsm timer for b_bus_suspend_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xusbps_otg_phy_low_power_wait(1);
+			xotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		} else if (xotg->hsm.a_bus_drop) {
+			/* delete hsm timer for b_bus_suspend_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			/* Turn off VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+			xotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (xotg->hsm.b_bus_suspend) {
+			dev_warn(xotg->dev, "HNP detected\n");
+			/* delete hsm timer for b_bus_suspend_tmr */
+			del_timer_sync(&xotg->hsm_timer);
+
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			xotg->otg.state = OTG_STATE_A_WAIT_BCON;
+			if (xotg->start_host)
+				xotg->start_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+						"host driver not loaded.\n");
+			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+		} else if (xotg->hsm.b_bus_suspend_tmout) {
+			u32	val;
+			val = readl(xotg->base + CI_PORTSC1);
+			if (!(val & PORTSC_SUSP))
+				break;
+
+			if (xotg->stop_peripheral)
+				xotg->stop_peripheral(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+					"client driver has been removed.\n");
+
+			xotg->otg.state = OTG_STATE_A_WAIT_BCON;
+			if (xotg->start_host)
+				xotg->start_host(&xotg->otg);
+			else
+				dev_dbg(xotg->dev,
+						"host driver not loaded.\n");
+			xusbps_otg_add_ktimer(TA_WAIT_BCON_TMR);
+		}
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		if (xotg->hsm.id) {
+			xotg->otg.otg->default_a = 0;
+			xotg->hsm.a_clr_err = 0;
+			xotg->hsm.a_srp_det = 0;
+			set_client_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+			xusbps_update_transceiver();
+		} else if (xotg->hsm.a_clr_err) {
+			xotg->hsm.a_clr_err = 0;
+			xotg->hsm.a_srp_det = 0;
+			reset_otg();
+			init_hsm();
+			if (xotg->otg.state == OTG_STATE_A_IDLE)
+				xusbps_update_transceiver();
+		} else {
+			/* FW will clear PHCD bit when any VBus
+			 * event detected. Reset PHCD to 1 again */
+			xusbps_otg_phy_low_power(1);
+		}
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		if (xotg->hsm.id) {
+			xotg->otg.otg->default_a = 0;
+			set_client_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_B_IDLE;
+			xusbps_update_transceiver();
+		} else if (xotg->hsm.a_bus_req) {
+
+			/* Turn on VBus */
+			xotg->otg.otg->set_vbus(xotg->otg.otg, true);
+			xotg->hsm.a_wait_vrise_tmout = 0;
+			xusbps_otg_add_timer(a_wait_vrise_tmr);
+			xotg->otg.state = OTG_STATE_A_WAIT_VRISE;
+		} else if (!xotg->hsm.a_sess_vld) {
+			xotg->hsm.a_srp_det = 0;
+			set_host_mode();
+			xusbps_otg_phy_low_power(1);
+			xotg->otg.state = OTG_STATE_A_IDLE;
+		}
+		break;
+	default:
+		;
+	}
+
+	dev_dbg(xotg->dev, "%s: new state = %s\n", __func__,
+			otg_state_string(xotg->otg.state));
+}
+
+static ssize_t
+show_registers(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	char			*next;
+	unsigned		size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size,
+		"\n"
+		"USBCMD = 0x%08x\n"
+		"USBSTS = 0x%08x\n"
+		"USBINTR = 0x%08x\n"
+		"ASYNCLISTADDR = 0x%08x\n"
+		"PORTSC1 = 0x%08x\n"
+		"OTGSC = 0x%08x\n"
+		"USBMODE = 0x%08x\n",
+		readl(xotg->base + 0x140),
+		readl(xotg->base + 0x144),
+		readl(xotg->base + 0x148),
+		readl(xotg->base + 0x158),
+		readl(xotg->base + 0x184),
+		readl(xotg->base + 0x1a4),
+		readl(xotg->base + 0x1a8)
+	     );
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
+
+static ssize_t
+show_hsm(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	char				*next;
+	unsigned			size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	if (xotg->otg.otg->host)
+		xotg->hsm.a_set_b_hnp_en = xotg->otg.otg->host->b_hnp_enable;
+
+	if (xotg->otg.otg->gadget)
+		xotg->hsm.b_hnp_enable = xotg->otg.otg->gadget->b_hnp_enable;
+
+	t = scnprintf(next, size,
+		"\n"
+		"current state = %s\n"
+		"a_bus_resume = \t%d\n"
+		"a_bus_suspend = \t%d\n"
+		"a_conn = \t%d\n"
+		"a_sess_vld = \t%d\n"
+		"a_srp_det = \t%d\n"
+		"a_vbus_vld = \t%d\n"
+		"b_bus_resume = \t%d\n"
+		"b_bus_suspend = \t%d\n"
+		"b_conn = \t%d\n"
+		"b_se0_srp = \t%d\n"
+		"b_sess_end = \t%d\n"
+		"b_sess_vld = \t%d\n"
+		"id = \t%d\n"
+		"a_set_b_hnp_en = \t%d\n"
+		"b_srp_done = \t%d\n"
+		"b_hnp_enable = \t%d\n"
+		"a_wait_vrise_tmout = \t%d\n"
+		"a_wait_bcon_tmout = \t%d\n"
+		"a_aidl_bdis_tmout = \t%d\n"
+		"b_ase0_brst_tmout = \t%d\n"
+		"a_bus_drop = \t%d\n"
+		"a_bus_req = \t%d\n"
+		"a_clr_err = \t%d\n"
+		"a_suspend_req = \t%d\n"
+		"b_bus_req = \t%d\n"
+		"b_bus_suspend_tmout = \t%d\n"
+		"b_bus_suspend_vld = \t%d\n",
+		otg_state_string(xotg->otg.state),
+		xotg->hsm.a_bus_resume,
+		xotg->hsm.a_bus_suspend,
+		xotg->hsm.a_conn,
+		xotg->hsm.a_sess_vld,
+		xotg->hsm.a_srp_det,
+		xotg->hsm.a_vbus_vld,
+		xotg->hsm.b_bus_resume,
+		xotg->hsm.b_bus_suspend,
+		xotg->hsm.b_conn,
+		xotg->hsm.b_se0_srp,
+		xotg->hsm.b_sess_end,
+		xotg->hsm.b_sess_vld,
+		xotg->hsm.id,
+		xotg->hsm.a_set_b_hnp_en,
+		xotg->hsm.b_srp_done,
+		xotg->hsm.b_hnp_enable,
+		xotg->hsm.a_wait_vrise_tmout,
+		xotg->hsm.a_wait_bcon_tmout,
+		xotg->hsm.a_aidl_bdis_tmout,
+		xotg->hsm.b_ase0_brst_tmout,
+		xotg->hsm.a_bus_drop,
+		xotg->hsm.a_bus_req,
+		xotg->hsm.a_clr_err,
+		xotg->hsm.a_suspend_req,
+		xotg->hsm.b_bus_req,
+		xotg->hsm.b_bus_suspend_tmout,
+		xotg->hsm.b_bus_suspend_vld
+		);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+static DEVICE_ATTR(hsm, S_IRUGO, show_hsm, NULL);
+
+static ssize_t
+get_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	char			*next;
+	unsigned		size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size, "%d", xotg->hsm.a_bus_req);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+
+static ssize_t
+set_a_bus_req(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+
+	if (!xotg->otg.otg->default_a)
+		return -1;
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '0') {
+		xotg->hsm.a_bus_req = 0;
+		dev_dbg(xotg->dev, "User request: a_bus_req = 0\n");
+	} else if (buf[0] == '1') {
+		/* If a_bus_drop is TRUE, a_bus_req can't be set */
+		if (xotg->hsm.a_bus_drop)
+			return -1;
+		xotg->hsm.a_bus_req = 1;
+		dev_dbg(xotg->dev, "User request: a_bus_req = 1\n");
+	}
+	if (spin_trylock(&xotg->wq_lock)) {
+		xusbps_update_transceiver();
+		spin_unlock(&xotg->wq_lock);
+	}
+	return count;
+}
+static DEVICE_ATTR(a_bus_req, S_IRUGO | S_IWUSR, get_a_bus_req, set_a_bus_req);
+
+static ssize_t
+get_a_bus_drop(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	char			*next;
+	unsigned		size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size, "%d", xotg->hsm.a_bus_drop);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+
+static ssize_t
+set_a_bus_drop(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+
+	if (!xotg->otg.otg->default_a)
+		return -1;
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '0') {
+		xotg->hsm.a_bus_drop = 0;
+		dev_dbg(xotg->dev, "User request: a_bus_drop = 0\n");
+	} else if (buf[0] == '1') {
+		xotg->hsm.a_bus_drop = 1;
+		xotg->hsm.a_bus_req = 0;
+		dev_dbg(xotg->dev, "User request: a_bus_drop = 1\n");
+		dev_dbg(xotg->dev, "User request: and a_bus_req = 0\n");
+	}
+	if (spin_trylock(&xotg->wq_lock)) {
+		xusbps_update_transceiver();
+		spin_unlock(&xotg->wq_lock);
+	}
+	return count;
+}
+static DEVICE_ATTR(a_bus_drop, S_IRUGO | S_IWUSR, get_a_bus_drop,
+		set_a_bus_drop);
+
+static ssize_t
+get_b_bus_req(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct xusbps_otg	*xotg = the_transceiver;
+	char			*next;
+	unsigned		size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size, "%d", xotg->hsm.b_bus_req);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+
+static ssize_t
+set_b_bus_req(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+
+	if (xotg->otg.otg->default_a)
+		return -1;
+
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '0') {
+		xotg->hsm.b_bus_req = 0;
+		dev_dbg(xotg->dev, "User request: b_bus_req = 0\n");
+	} else if (buf[0] == '1') {
+		xotg->hsm.b_bus_req = 1;
+		dev_dbg(xotg->dev, "User request: b_bus_req = 1\n");
+	}
+	if (spin_trylock(&xotg->wq_lock)) {
+		xusbps_update_transceiver();
+		spin_unlock(&xotg->wq_lock);
+	}
+	return count;
+}
+static DEVICE_ATTR(b_bus_req, S_IRUGO | S_IWUSR, get_b_bus_req, set_b_bus_req);
+
+static ssize_t
+set_a_clr_err(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+
+	if (!xotg->otg.otg->default_a)
+		return -1;
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '1') {
+		xotg->hsm.a_clr_err = 1;
+		dev_dbg(xotg->dev, "User request: a_clr_err = 1\n");
+	}
+	if (spin_trylock(&xotg->wq_lock)) {
+		xusbps_update_transceiver();
+		spin_unlock(&xotg->wq_lock);
+	}
+	return count;
+}
+static DEVICE_ATTR(a_clr_err, S_IWUSR, NULL, set_a_clr_err);
+
+/**
+ * suspend_otg_device - suspend the otg device.
+ *
+ * @otg:	Pointer to the otg transceiver structure.
+ *
+ * This function suspends usb devices connected to the otg port
+ * of the host controller.
+ *
+ * returns:	0 on success or error value on failure
+ **/
+static int suspend_otg_device(struct usb_phy *otg)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	unsigned long otg_port = otg->otg->host->otg_port;
+	struct usb_device *udev;
+	int err;
+
+	udev = usb_hub_find_child(otg->otg->host->root_hub, otg_port - 1);
+
+	if (udev) {
+		err = usb_port_suspend(udev, PMSG_SUSPEND);
+		if (err < 0)
+			dev_dbg(xotg->dev, "HNP fail, %d\n", err);
+
+		/* Change the state of the usb device if HNP is successful */
+		usb_set_device_state(udev, USB_STATE_NOTATTACHED);
+	} else {
+		err = -ENODEV;
+		dev_dbg(xotg->dev, "No device connected to roothub\n");
+	}
+	return err;
+}
+
+static ssize_t
+do_hnp(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct xusbps_otg		*xotg = the_transceiver;
+	unsigned long ret;
+
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '1') {
+		if (xotg->otg.otg->default_a && xotg->otg.otg->host &&
+				xotg->otg.otg->host->b_hnp_enable &&
+				(xotg->otg.state == OTG_STATE_A_HOST)) {
+			ret = suspend_otg_device(&xotg->otg);
+			if (ret)
+				return -1;
+		}
+
+		if (!xotg->otg.otg->default_a && xotg->otg.otg->host &&
+				xotg->hsm.b_bus_req) {
+			ret = suspend_otg_device(&xotg->otg);
+			if (ret)
+				return -1;
+		}
+	}
+	return count;
+}
+static DEVICE_ATTR(do_hnp, S_IWUSR, NULL, do_hnp);
+
+static int xusbps_otg_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		/* if a rate change is announced we need to check whether we can
+		 * maintain the current frequency by changing the clock
+		 * dividers.
+		 */
+		/* fall through */
+	case POST_RATE_CHANGE:
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static struct attribute *inputs_attrs[] = {
+	&dev_attr_a_bus_req.attr,
+	&dev_attr_a_bus_drop.attr,
+	&dev_attr_b_bus_req.attr,
+	&dev_attr_a_clr_err.attr,
+	&dev_attr_do_hnp.attr,
+	NULL,
+};
+
+static struct attribute_group debug_dev_attr_group = {
+	.name = "inputs",
+	.attrs = inputs_attrs,
+};
+
+static int xusbps_otg_remove(struct platform_device *pdev)
+{
+	struct xusbps_otg *xotg = the_transceiver;
+
+	if (xotg->qwork) {
+		flush_workqueue(xotg->qwork);
+		destroy_workqueue(xotg->qwork);
+	}
+	xusbps_otg_free_timers();
+
+	/* disable OTGSC interrupt as OTGSC doesn't change in reset */
+	writel(0, xotg->base + CI_OTGSC);
+
+	if (xotg->irq)
+		free_irq(xotg->irq, xotg);
+
+	usb_remove_phy(&xotg->otg);
+	sysfs_remove_group(&pdev->dev.kobj, &debug_dev_attr_group);
+	device_remove_file(&pdev->dev, &dev_attr_hsm);
+	device_remove_file(&pdev->dev, &dev_attr_registers);
+	clk_notifier_unregister(xotg->clk, &xotg->clk_rate_change_nb);
+	clk_disable_unprepare(xotg->clk);
+	clk_put(xotg->clk);
+	kfree(xotg);
+
+	return 0;
+}
+
+static int xusbps_otg_probe(struct platform_device *pdev)
+{
+	int			retval;
+	u32			val32;
+	struct xusbps_otg	*xotg;
+	char			qname[] = "xusbps_otg_queue";
+	struct xusbps_usb2_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata)
+		return -ENODEV;
+
+	dev_dbg(&pdev->dev, "\notg controller is detected.\n");
+
+	xotg = kzalloc(sizeof *xotg, GFP_KERNEL);
+	if (xotg == NULL)
+		return -ENOMEM;
+
+	the_transceiver = xotg;
+
+	/* Setup ulpi phy for OTG */
+	xotg->ulpi = pdata->ulpi;
+
+	xotg->otg.otg = kzalloc(sizeof(struct usb_otg), GFP_KERNEL);
+	if (!xotg->otg.otg) {
+		kfree(xotg);
+		return -ENOMEM;
+	}
+
+	xotg->base = pdata->regs;
+	xotg->irq = pdata->irq;
+	if (!xotg->base || !xotg->irq) {
+		retval = -ENODEV;
+		goto err;
+	}
+
+	xotg->qwork = create_singlethread_workqueue(qname);
+	if (!xotg->qwork) {
+		dev_dbg(&pdev->dev, "cannot create workqueue %s\n", qname);
+		retval = -ENOMEM;
+		goto err;
+	}
+	INIT_WORK(&xotg->work, xusbps_otg_work);
+
+	if (xotg->irq == 53)
+		xotg->clk = clk_get_sys("USB0_APER", NULL);
+	else
+		xotg->clk = clk_get_sys("USB1_APER", NULL);
+	if (IS_ERR(xotg->clk)) {
+		dev_err(&pdev->dev, "APER clock not found.\n");
+		retval = PTR_ERR(xotg->clk);
+		goto err;
+	}
+
+	retval = clk_prepare_enable(xotg->clk);
+	if (retval) {
+		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
+		goto err_out_clk_put;
+	}
+
+	xotg->clk_rate_change_nb.notifier_call = xusbps_otg_clk_notifier_cb;
+	xotg->clk_rate_change_nb.next = NULL;
+	if (clk_notifier_register(xotg->clk, &xotg->clk_rate_change_nb))
+		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
+
+	/* OTG common part */
+	xotg->dev = &pdev->dev;
+	xotg->otg.dev = xotg->dev;
+	xotg->otg.label = driver_name;
+	xotg->otg.otg->set_host = xusbps_otg_set_host;
+	xotg->otg.otg->set_peripheral = xusbps_otg_set_peripheral;
+	xotg->otg.set_power = xusbps_otg_set_power;
+	xotg->otg.otg->set_vbus = xusbps_otg_set_vbus;
+	xotg->otg.otg->start_srp = xusbps_otg_start_srp;
+	xotg->otg.otg->start_hnp = xusbps_otg_start_hnp;
+	xotg->otg.state = OTG_STATE_UNDEFINED;
+
+	if (usb_add_phy(&xotg->otg, USB_PHY_TYPE_USB2)) {
+		dev_dbg(xotg->dev, "can't set transceiver\n");
+		retval = -EBUSY;
+		goto err_out_clk_disable;
+	}
+
+	pdata->otg = &xotg->otg;
+	reset_otg();
+	init_hsm();
+
+	spin_lock_init(&xotg->lock);
+	spin_lock_init(&xotg->wq_lock);
+	INIT_LIST_HEAD(&active_timers);
+	retval = xusbps_otg_init_timers(&xotg->hsm);
+	if (retval) {
+		dev_dbg(&pdev->dev, "Failed to init timers\n");
+		goto err_out_clk_disable;
+	}
+
+	init_timer(&xotg->hsm_timer);
+
+	xotg->xotg_notifier.notifier_call = xotg_usbdev_notify;
+	usb_register_notify((struct notifier_block *)
+					&xotg->xotg_notifier.notifier_call);
+
+	if (request_irq(xotg->irq, otg_irq, IRQF_SHARED,
+				driver_name, xotg) != 0) {
+		dev_dbg(xotg->dev, "request interrupt %d failed\n", xotg->irq);
+		retval = -EBUSY;
+		goto err_out_clk_disable;
+	}
+
+	/* enable OTGSC int */
+	val32 = OTGSC_DPIE | OTGSC_BSEIE | OTGSC_BSVIE |
+		OTGSC_ASVIE | OTGSC_AVVIE | OTGSC_IDIE | OTGSC_IDPU;
+	writel(val32, xotg->base + CI_OTGSC);
+
+	retval = device_create_file(&pdev->dev, &dev_attr_registers);
+	if (retval < 0) {
+		dev_dbg(xotg->dev,
+			"Can't register sysfs attribute: %d\n", retval);
+		goto err_out_clk_disable;
+	}
+
+	retval = device_create_file(&pdev->dev, &dev_attr_hsm);
+	if (retval < 0) {
+		dev_dbg(xotg->dev, "Can't hsm sysfs attribute: %d\n", retval);
+		goto err_out_clk_disable;
+	}
+
+	retval = sysfs_create_group(&pdev->dev.kobj, &debug_dev_attr_group);
+	if (retval < 0) {
+		dev_dbg(xotg->dev,
+			"Can't register sysfs attr group: %d\n", retval);
+		goto err_out_clk_disable;
+	}
+
+	if (xotg->otg.state == OTG_STATE_A_IDLE)
+		xusbps_update_transceiver();
+
+	return 0;
+
+err_out_clk_disable:
+	clk_notifier_unregister(xotg->clk, &xotg->clk_rate_change_nb);
+	clk_disable_unprepare(xotg->clk);
+err_out_clk_put:
+	clk_put(xotg->clk);
+err:
+	xusbps_otg_remove(pdev);
+
+	return retval;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static void transceiver_suspend(struct platform_device *pdev)
+{
+	xusbps_otg_phy_low_power(1);
+}
+
+static int xusbps_otg_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xusbps_otg		*xotg = the_transceiver;
+	int				ret = 0;
+
+	/* Disbale OTG interrupts */
+	xusbps_otg_intr(0);
+
+	if (xotg->irq)
+		free_irq(xotg->irq, xotg);
+
+	/* Prevent more otg_work */
+	flush_workqueue(xotg->qwork);
+	destroy_workqueue(xotg->qwork);
+	xotg->qwork = NULL;
+
+	/* start actions */
+	switch (xotg->otg.state) {
+	case OTG_STATE_A_WAIT_VFALL:
+		xotg->otg.state = OTG_STATE_A_IDLE;
+	case OTG_STATE_A_IDLE:
+	case OTG_STATE_B_IDLE:
+	case OTG_STATE_A_VBUS_ERR:
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		xusbps_otg_del_timer(a_wait_vrise_tmr);
+		xotg->hsm.a_srp_det = 0;
+
+		/* Turn off VBus */
+		xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+		xotg->otg.state = OTG_STATE_A_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		del_timer_sync(&xotg->hsm_timer);
+		if (xotg->stop_host)
+			xotg->stop_host(&xotg->otg);
+		else
+			dev_dbg(&pdev->dev, "host driver has been removed.\n");
+
+		xotg->hsm.a_srp_det = 0;
+
+		/* Turn off VBus */
+		xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+		xotg->otg.state = OTG_STATE_A_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_A_HOST:
+		if (xotg->stop_host)
+			xotg->stop_host(&xotg->otg);
+		else
+			dev_dbg(&pdev->dev, "host driver has been removed.\n");
+
+		xotg->hsm.a_srp_det = 0;
+
+		/* Turn off VBus */
+		xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+
+		xotg->otg.state = OTG_STATE_A_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_A_SUSPEND:
+		xusbps_otg_del_timer(a_aidl_bdis_tmr);
+		xusbps_otg_HABA(0);
+		if (xotg->stop_host)
+			xotg->stop_host(&xotg->otg);
+		else
+			dev_dbg(xotg->dev, "host driver has been removed.\n");
+		xotg->hsm.a_srp_det = 0;
+
+		/* Turn off VBus */
+		xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+		xotg->otg.state = OTG_STATE_A_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		del_timer_sync(&xotg->hsm_timer);
+
+		if (xotg->stop_peripheral)
+			xotg->stop_peripheral(&xotg->otg);
+		else
+			dev_dbg(&pdev->dev,
+				"client driver has been removed.\n");
+		xotg->hsm.a_srp_det = 0;
+
+		/* Turn off VBus */
+		xotg->otg.otg->set_vbus(xotg->otg.otg, false);
+		xotg->otg.state = OTG_STATE_A_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_B_HOST:
+		if (xotg->stop_host)
+			xotg->stop_host(&xotg->otg);
+		else
+			dev_dbg(&pdev->dev, "host driver has been removed.\n");
+		xotg->hsm.b_bus_req = 0;
+		xotg->otg.state = OTG_STATE_B_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		if (xotg->stop_peripheral)
+			xotg->stop_peripheral(&xotg->otg);
+		else
+			dev_dbg(&pdev->dev,
+				"client driver has been removed.\n");
+		xotg->otg.state = OTG_STATE_B_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		/* delete hsm timer for b_ase0_brst_tmr */
+		del_timer_sync(&xotg->hsm_timer);
+
+		xusbps_otg_HAAR(0);
+
+		if (xotg->stop_host)
+			xotg->stop_host(&xotg->otg);
+		else
+			dev_dbg(&pdev->dev, "host driver has been removed.\n");
+		xotg->hsm.b_bus_req = 0;
+		xotg->otg.state = OTG_STATE_B_IDLE;
+		transceiver_suspend(pdev);
+		break;
+	default:
+		dev_dbg(xotg->dev, "error state before suspend\n");
+		break;
+	}
+
+	if (!ret)
+		clk_disable(xotg->clk);
+	return ret;
+}
+
+static void transceiver_resume(struct platform_device *pdev)
+{
+	/* Not used */
+}
+
+static int xusbps_otg_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct xusbps_otg	*xotg = the_transceiver;
+	int			ret = 0;
+
+	ret = clk_enable(xotg->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot enable clock. resume failed.\n");
+		return ret;
+	}
+
+	transceiver_resume(pdev);
+
+	xotg->qwork = create_singlethread_workqueue("xusbps_otg_queue");
+	if (!xotg->qwork) {
+		dev_dbg(&pdev->dev, "cannot create xusbps otg workqueuen");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	if (request_irq(xotg->irq, otg_irq, IRQF_SHARED,
+				driver_name, xotg) != 0) {
+		dev_dbg(&pdev->dev, "request interrupt %d failed\n", xotg->irq);
+		ret = -EBUSY;
+		goto error;
+	}
+
+	/* enable OTG interrupts */
+	xusbps_otg_intr(1);
+
+	update_hsm();
+
+	xusbps_update_transceiver();
+
+	return ret;
+error:
+	xusbps_otg_intr(0);
+	transceiver_suspend(pdev);
+	return ret;
+}
+
+static const struct dev_pm_ops xusbps_otg_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xusbps_otg_suspend, xusbps_otg_resume)
+};
+#define XUSBPS_OTG_PM	(&xusbps_otg_dev_pm_ops)
+
+#else /* ! CONFIG_PM_SLEEP */
+#define XUSBPS_OTG_PM	NULL
+#endif /* ! CONFIG_PM_SLEEP */
+
+static struct platform_driver xusbps_otg_driver = {
+	.probe		= xusbps_otg_probe,
+	.remove		= xusbps_otg_remove,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= DRIVER_NAME,
+		.pm	= XUSBPS_OTG_PM,
+	},
+};
+
+module_platform_driver(xusbps_otg_driver);
+
+MODULE_AUTHOR("Xilinx, Inc.");
+MODULE_DESCRIPTION("Xilinx PS USB OTG driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/include/linux/usb/xilinx_usbps_otg.h b/include/linux/usb/xilinx_usbps_otg.h
new file mode 100644
index 0000000..1fbd162
--- /dev/null
+++ b/include/linux/usb/xilinx_usbps_otg.h
@@ -0,0 +1,216 @@
+/*
+ * Xilinx PS USB OTG Driver Header file.
+ *
+ * Copyright 2011 Xilinx, Inc.
+ *
+ * This file is based on langwell_otg.h file with few minor modifications
+ * to support Xilinx PS USB controller.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __XILINX_XUSBPS_OTG_H
+#define __XILINX_XUSBPS_OTG_H
+
+#define CI_USBCMD		0x140
+#	define USBCMD_RST		BIT(1)
+#	define USBCMD_RS		BIT(0)
+#define CI_USBSTS		0x144
+#	define USBSTS_SLI		BIT(8)
+#	define USBSTS_URI		BIT(6)
+#	define USBSTS_PCI		BIT(2)
+#define CI_PORTSC1		0x184
+#	define PORTSC_PP		BIT(12)
+#	define PORTSC_LS		(BIT(11) | BIT(10))
+#	define PORTSC_SUSP		BIT(7)
+#	define PORTSC_CCS		BIT(0)
+#define CI_OTGSC		0x1a4
+#	define OTGSC_DPIE		BIT(30)
+#	define OTGSC_1MSE		BIT(29)
+#	define OTGSC_BSEIE		BIT(28)
+#	define OTGSC_BSVIE		BIT(27)
+#	define OTGSC_ASVIE		BIT(26)
+#	define OTGSC_AVVIE		BIT(25)
+#	define OTGSC_IDIE		BIT(24)
+#	define OTGSC_DPIS		BIT(22)
+#	define OTGSC_1MSS		BIT(21)
+#	define OTGSC_BSEIS		BIT(20)
+#	define OTGSC_BSVIS		BIT(19)
+#	define OTGSC_ASVIS		BIT(18)
+#	define OTGSC_AVVIS		BIT(17)
+#	define OTGSC_IDIS		BIT(16)
+#	define OTGSC_DPS		BIT(14)
+#	define OTGSC_1MST		BIT(13)
+#	define OTGSC_BSE		BIT(12)
+#	define OTGSC_BSV		BIT(11)
+#	define OTGSC_ASV		BIT(10)
+#	define OTGSC_AVV		BIT(9)
+#	define OTGSC_ID			BIT(8)
+#	define OTGSC_HABA		BIT(7)
+#	define OTGSC_HADP		BIT(6)
+#	define OTGSC_IDPU		BIT(5)
+#	define OTGSC_DP			BIT(4)
+#	define OTGSC_OT			BIT(3)
+#	define OTGSC_HAAR		BIT(2)
+#	define OTGSC_VC			BIT(1)
+#	define OTGSC_VD			BIT(0)
+#	define OTGSC_INTEN_MASK		(0x7f << 24)
+#	define OTGSC_INT_MASK		(0x5f << 24)
+#	define OTGSC_INTSTS_MASK	(0x7f << 16)
+#define CI_USBMODE		0x1a8
+#	define USBMODE_CM		(BIT(1) | BIT(0))
+#	define USBMODE_IDLE		0
+#	define USBMODE_DEVICE		0x2
+#	define USBMODE_HOST		0x3
+
+#define INTR_DUMMY_MASK (USBSTS_SLI | USBSTS_URI | USBSTS_PCI)
+
+enum xusbps_otg_timer_type {
+	TA_WAIT_VRISE_TMR,
+	TA_WAIT_BCON_TMR,
+	TA_AIDL_BDIS_TMR,
+	TB_ASE0_BRST_TMR,
+	TB_SE0_SRP_TMR,
+	TB_SRP_INIT_TMR,
+	TB_SRP_FAIL_TMR,
+	TB_BUS_SUSPEND_TMR
+};
+
+#define TA_WAIT_VRISE	100
+#define TA_WAIT_BCON	30000
+#define TA_AIDL_BDIS	15000
+#define TB_ASE0_BRST	5000
+#define TB_SE0_SRP	2
+#define TB_SRP_INIT	100
+#define TB_SRP_FAIL	5500
+#define TB_BUS_SUSPEND	500
+
+struct xusbps_otg_timer {
+	unsigned long expires;	/* Number of count increase to timeout */
+	unsigned long count;	/* Tick counter */
+	void (*function)(unsigned long);	/* Timeout function */
+	unsigned long data;	/* Data passed to function */
+	struct list_head list;
+};
+
+/* This is a common data structure to
+ * save values of the OTG state machine */
+struct otg_hsm {
+	/* Input */
+	int a_bus_resume;
+	int a_bus_suspend;
+	int a_conn;
+	int a_sess_vld;
+	int a_srp_det;
+	int a_vbus_vld;
+	int b_bus_resume;
+	int b_bus_suspend;
+	int b_conn;
+	int b_se0_srp;
+	int b_ssend_srp;
+	int b_sess_end;
+	int b_sess_vld;
+	int id;
+/* id values */
+#define ID_B		0x05
+#define ID_A		0x04
+#define ID_ACA_C	0x03
+#define ID_ACA_B	0x02
+#define ID_ACA_A	0x01
+	int power_up;
+	int adp_change;
+	int test_device;
+
+	/* Internal variables */
+	int a_set_b_hnp_en;
+	int b_srp_done;
+	int b_hnp_enable;
+	int hnp_poll_enable;
+
+	/* Timeout indicator for timers */
+	int a_wait_vrise_tmout;
+	int a_wait_bcon_tmout;
+	int a_aidl_bdis_tmout;
+	int a_bidl_adis_tmout;
+	int a_bidl_adis_tmr;
+	int a_wait_vfall_tmout;
+	int b_ase0_brst_tmout;
+	int b_bus_suspend_tmout;
+	int b_srp_init_tmout;
+	int b_srp_fail_tmout;
+	int b_srp_fail_tmr;
+	int b_adp_sense_tmout;
+
+	/* Informative variables */
+	int a_bus_drop;
+	int a_bus_req;
+	int a_clr_err;
+	int b_bus_req;
+	int a_suspend_req;
+	int b_bus_suspend_vld;
+
+	/* Output */
+	int drv_vbus;
+	int loc_conn;
+	int loc_sof;
+
+	/* Others */
+	int vbus_srp_up;
+};
+
+struct xusbps_otg {
+	struct usb_phy		otg;
+	struct usb_phy		*ulpi;
+
+	struct otg_hsm		hsm;
+
+	/* base address */
+	void __iomem		*base;
+
+	/* irq */
+	int			irq;
+
+	/* clk */
+	struct clk		*clk;
+	struct notifier_block	clk_rate_change_nb;
+
+	/* atomic notifier for interrupt context */
+	struct atomic_notifier_head	otg_notifier;
+
+	/* start/stop USB Host function */
+	int	(*start_host)(struct usb_phy *otg);
+	int	(*stop_host)(struct usb_phy *otg);
+
+	/* start/stop USB Peripheral function */
+	int	(*start_peripheral)(struct usb_phy *otg);
+	int	(*stop_peripheral)(struct usb_phy *otg);
+
+	struct device			*dev;
+
+	unsigned			region;
+
+	struct work_struct		work;
+	struct workqueue_struct		*qwork;
+	struct timer_list		hsm_timer;
+
+	spinlock_t			lock;
+	spinlock_t			wq_lock;
+
+	struct notifier_block		xotg_notifier;
+};
+
+static inline
+struct xusbps_otg *xceiv_to_xotg(struct usb_phy *otg)
+{
+	return container_of(otg, struct xusbps_otg, otg);
+}
+
+void xusbps_update_transceiver(void);
+
+#endif /* __XILINX_XUSBPS_OTG_H__ */
diff --git a/include/linux/xilinx_devices.h b/include/linux/xilinx_devices.h
new file mode 100644
index 0000000..4db514f
--- /dev/null
+++ b/include/linux/xilinx_devices.h
@@ -0,0 +1,70 @@
+/*
+ * include/linux/xilinx_devices.h
+ *
+ * Definitions for any platform device related flags or structures for
+ * Xilinx EDK IPs
+ *
+ * Author: MontaVista Software, Inc.
+ *         source@mvista.com
+ *
+ * 2002-2005 (c) MontaVista Software, Inc.  This file is licensed under the
+ * terms of the GNU General Public License version 2.  This program is licensed
+ * "as is" without any warranty of any kind, whether express or implied.
+ */
+
+#ifdef __KERNEL__
+#ifndef _XILINX_DEVICE_H_
+#define _XILINX_DEVICE_H_
+
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/platform_device.h>
+
+/*- PS USB Controller IP -*/
+enum xusbps_usb2_operating_modes {
+	XUSBPS_USB2_MPH_HOST,
+	XUSBPS_USB2_DR_HOST,
+	XUSBPS_USB2_DR_DEVICE,
+	XUSBPS_USB2_DR_OTG,
+};
+
+enum xusbps_usb2_phy_modes {
+	XUSBPS_USB2_PHY_NONE,
+	XUSBPS_USB2_PHY_ULPI,
+	XUSBPS_USB2_PHY_UTMI,
+	XUSBPS_USB2_PHY_UTMI_WIDE,
+	XUSBPS_USB2_PHY_SERIAL,
+};
+
+struct clk;
+struct platform_device;
+
+struct xusbps_usb2_platform_data {
+	/* board specific information */
+	enum xusbps_usb2_operating_modes	operating_mode;
+	enum xusbps_usb2_phy_modes	phy_mode;
+	unsigned int			port_enables;
+	unsigned int			workaround;
+
+	int		(*init)(struct platform_device *);
+	void		(*exit)(struct platform_device *);
+	void __iomem	*regs;		/* ioremap'd register base */
+	struct usb_phy	*otg;
+	struct usb_phy	*ulpi;
+	int		irq;
+	struct clk	*clk;
+	struct notifier_block clk_rate_change_nb;
+	unsigned	big_endian_mmio:1;
+	unsigned	big_endian_desc:1;
+	unsigned	es:1;		/* need USBMODE:ES */
+	unsigned	le_setup_buf:1;
+	unsigned	have_sysif_regs:1;
+	unsigned	invert_drvvbus:1;
+	unsigned	invert_pwr_fault:1;
+};
+
+#define XUSBPS_USB2_PORT0_ENABLED	0x00000001
+#define XUSBPS_USB2_PORT1_ENABLED	0x00000002
+
+#endif /* _XILINX_DEVICE_H_ */
+#endif /* __KERNEL__ */
-- 
1.7.5.4

