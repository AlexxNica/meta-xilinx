From 725233b811169e85dc7cf2c01ae61f33f411ffa3 Mon Sep 17 00:00:00 2001
From: Sipke Vriend <sipke.vriend@xilinx.com>
Date: Wed, 15 May 2013 15:21:46 +1000
Subject: [PATCH 05/24] Xilinx modifications to drivers clk, cpufreq, misc

Signed-off-by: Sipke Vriend <sipke.vriend@xilinx.com>
---
 drivers/clk/Makefile              |    2 +-
 drivers/clk/zynq/Makefile         |    3 +
 drivers/clk/zynq/clk.c            |  743 +++++++++++++++++++++++++++++++++++++
 drivers/clk/zynq/clk621.c         |  171 +++++++++
 drivers/clk/zynq/peripheral_clk.c |  515 +++++++++++++++++++++++++
 drivers/cpufreq/Kconfig.arm       |   10 +
 drivers/cpufreq/Makefile          |    1 +
 drivers/cpufreq/zynq-cpufreq.c    |  255 +++++++++++++
 drivers/misc/Kconfig              |   10 +
 drivers/misc/Makefile             |    1 +
 drivers/misc/si570.c              |  576 ++++++++++++++++++++++++++++
 include/linux/clk/zynq.h          |   35 ++-
 include/linux/i2c/si570.h         |   31 ++
 13 files changed, 2342 insertions(+), 11 deletions(-)
 create mode 100644 drivers/clk/zynq/Makefile
 create mode 100644 drivers/clk/zynq/clk.c
 create mode 100644 drivers/clk/zynq/clk621.c
 create mode 100644 drivers/clk/zynq/peripheral_clk.c
 create mode 100644 drivers/cpufreq/zynq-cpufreq.c
 create mode 100644 drivers/misc/si570.c
 create mode 100644 include/linux/i2c/si570.h

diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index ee90e87..9119fc6 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -21,7 +21,7 @@ obj-$(CONFIG_MACH_LOONGSON1)	+= clk-ls1x.o
 obj-$(CONFIG_ARCH_U8500)	+= ux500/
 obj-$(CONFIG_ARCH_VT8500)	+= clk-vt8500.o
 obj-$(CONFIG_ARCH_SUNXI)	+= clk-sunxi.o
-obj-$(CONFIG_ARCH_ZYNQ)		+= clk-zynq.o
+obj-$(CONFIG_ARCH_ZYNQ)		+= zynq/
 
 # Chip specific
 obj-$(CONFIG_COMMON_CLK_WM831X) += clk-wm831x.o
diff --git a/drivers/clk/zynq/Makefile b/drivers/clk/zynq/Makefile
new file mode 100644
index 0000000..1c4763a
--- /dev/null
+++ b/drivers/clk/zynq/Makefile
@@ -0,0 +1,3 @@
+# Zynq clock specific Makefile
+
+obj-$(CONFIG_ARCH_ZYNQ)	+= clk.o clk621.o peripheral_clk.o
diff --git a/drivers/clk/zynq/clk.c b/drivers/clk/zynq/clk.c
new file mode 100644
index 0000000..b97d0e5
--- /dev/null
+++ b/drivers/clk/zynq/clk.c
@@ -0,0 +1,743 @@
+/*
+ * Zynq clock initalization code
+ * Code is based on clock code from the orion/kirkwood architecture.
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/clk/zynq.h>
+
+#define SLCR_ARM_CLK_CTRL		(slcr_base + 0x120)
+#define SLCR_DDR_CLK_CTRL		(slcr_base + 0x124)
+#define SLCR_DCI_CLK_CTRL		(slcr_base + 0x128)
+#define SLCR_APER_CLK_CTRL		(slcr_base + 0x12c)
+#define SLCR_GEM0_CLK_CTRL		(slcr_base + 0x140)
+#define SLCR_GEM1_CLK_CTRL		(slcr_base + 0x144)
+#define SLCR_SMC_CLK_CTRL		(slcr_base + 0x148)
+#define SLCR_LQSPI_CLK_CTRL		(slcr_base + 0x14c)
+#define SLCR_SDIO_CLK_CTRL		(slcr_base + 0x150)
+#define SLCR_UART_CLK_CTRL		(slcr_base + 0x154)
+#define SLCR_SPI_CLK_CTRL		(slcr_base + 0x158)
+#define SLCR_CAN_CLK_CTRL		(slcr_base + 0x15c)
+#define SLCR_DBG_CLK_CTRL		(slcr_base + 0x164)
+#define SLCR_PCAP_CLK_CTRL		(slcr_base + 0x168)
+#define SLCR_FPGA0_CLK_CTRL		(slcr_base + 0x170)
+#define SLCR_FPGA1_CLK_CTRL		(slcr_base + 0x180)
+#define SLCR_FPGA2_CLK_CTRL		(slcr_base + 0x190)
+#define SLCR_FPGA3_CLK_CTRL		(slcr_base + 0x1a0)
+#define SLCR_621_TRUE			(slcr_base + 0x1c4)
+
+static void __iomem *zynq_slcr_base;
+
+
+/* clock implementation for Zynq PLLs */
+
+/**
+ * struct zynq_pll
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @pll_ctrl:	PLL control register
+ * @pll_cfg:	PLL config register
+ * @pll_status:	PLL status register
+ * @lock:	Register lock
+ * @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status
+ *		register.
+ * @bypassed:	Indicates PLL bypass. 1 = bypassed, 0 = PLL output
+ */
+struct zynq_pll {
+	struct clk_hw	hw;
+	void __iomem	*pll_ctrl;
+	void __iomem	*pll_cfg;
+	void __iomem	*pll_status;
+	spinlock_t	lock;
+	u32		lockbit;
+	u8		bypassed;
+};
+#define to_zynq_pll(_hw)	container_of(_hw, struct zynq_pll, hw)
+
+/* Register bitfield defines */
+#define PLLCTRL_FBDIV_MASK	0x7f000
+#define PLLCTRL_FBDIV_SHIFT	12
+#define PLLCTRL_BYPASS_MASK	0x10
+#define PLLCTRL_BYPASS_SHIFT	4
+#define PLLCTRL_BPQUAL_MASK	(1 << 3)
+#define PLLCTRL_PWRDWN_MASK	2
+#define PLLCTRL_PWRDWN_SHIFT	1
+#define PLLCTRL_RESET_MASK	1
+#define PLLCTRL_RESET_SHIFT	0
+#define PLLCFG_PLLRES_MASK	0xf0
+#define PLLCFG_PLLRES_SHIFT	4
+#define PLLCFG_PLLCP_MASK	0xf00
+#define PLLCFG_PLLCP_SHIFT	8
+#define PLLCFG_LOCKCNT_MASK	0x3ff000
+#define PLLCFG_LOCKCNT_SHIFT	12
+
+/**
+ * zynq_pll_get_params() - Get PLL parameters for given feedback divider
+ * @fbdiv: Desired feedback divider
+ * @rpll_cp: PLL_CP value (return value)
+ * @rpll_res: PLL_RES value (return value)
+ * @rlock_cnt: LOCK_CNT value (return value)
+ * Returns 0 on success.
+ */
+static int zynq_pll_get_pll_params(unsigned int fbdiv, u32 *rpll_cp,
+		u32 *rpll_res, u32 *rlock_cnt)
+{
+	unsigned int pll_cp;
+	unsigned int pll_res;
+	unsigned int lock_cnt;
+
+	/* Check that fbdiv is in a valid range */
+	if ((fbdiv < 13) || (fbdiv > 66))
+		return -EINVAL;
+
+	/* Set other PLL parameters according to target fbdiv */
+	if ((fbdiv >= 41) && (fbdiv <= 47))
+		pll_cp = 3;
+	else
+		pll_cp = 2;
+
+	if (fbdiv <= 15)
+		pll_res = 6;
+	else if ((fbdiv >= 16) && (fbdiv <= 19))
+		pll_res = 10;
+	else if ((fbdiv >= 31) && (fbdiv <= 40))
+		pll_res = 2;
+	else if (fbdiv >= 48)
+		pll_res = 4;
+	else
+		pll_res = 12;
+
+	switch (fbdiv) {
+	case 13:
+		lock_cnt = 750;
+		break;
+	case 14:
+		lock_cnt = 700;
+		break;
+	case 15:
+		lock_cnt = 650;
+		break;
+	case 16:
+		lock_cnt = 625;
+		break;
+	case 17:
+		lock_cnt = 575;
+		break;
+	case 18:
+		lock_cnt = 550;
+		break;
+	case 19:
+		lock_cnt = 525;
+		break;
+	case 20:
+		lock_cnt = 500;
+		break;
+	case 21:
+		lock_cnt = 475;
+		break;
+	case 22:
+		lock_cnt = 450;
+		break;
+	case 23:
+		lock_cnt = 425;
+		break;
+	case 24 ... 25:
+		lock_cnt = 400;
+		break;
+	case 26:
+		lock_cnt = 375;
+		break;
+	case 27 ... 28:
+		lock_cnt = 350;
+		break;
+	case 29 ... 30:
+		lock_cnt = 325;
+		break;
+	case 31 ... 33:
+		lock_cnt = 300;
+		break;
+	case 34 ... 36:
+		lock_cnt = 275;
+		break;
+	default:
+		lock_cnt = 250;
+		break;
+	}
+
+	*rpll_cp = pll_cp;
+	*rpll_res = pll_res;
+	*rlock_cnt = lock_cnt;
+	return 0;
+}
+
+/**
+ * zynq_pll_set_rate() - Change frequency of a PLL
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 reg, fbdiv, pll_res, pll_cp, lock_cnt;
+	unsigned long flags;
+
+	/*
+	 * Set a new rate to the PLL includes bypassing and resetting the PLL,
+	 * hence the connected subsystem will see old_f->bypass_f->new_f. Every
+	 * driver must register clock notifiers for its clock to make sure it is
+	 * asked for rate changes. This way it can make sure it can work with
+	 * new_f and do whatever is necessary to continue working after such a
+	 * change.
+	 */
+	/* Rate change is only possible if not bypassed */
+	if (clk->bypassed)
+		return -EINVAL;
+
+	fbdiv = DIV_ROUND_CLOSEST(rate, prate);
+	if (zynq_pll_get_pll_params(fbdiv, &pll_cp, &pll_res, &lock_cnt))
+		return -EINVAL;
+
+	spin_lock_irqsave(&clk->lock, flags);
+
+	/* Write new parameters */
+	reg = readl(clk->pll_ctrl);
+	reg &= ~PLLCTRL_FBDIV_MASK;
+	reg |= (fbdiv << PLLCTRL_FBDIV_SHIFT) & PLLCTRL_FBDIV_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	reg = (pll_res << PLLCFG_PLLRES_SHIFT) & PLLCFG_PLLRES_MASK;
+	reg |= (pll_cp << PLLCFG_PLLCP_SHIFT) & PLLCFG_PLLCP_MASK;
+	reg |= (lock_cnt << PLLCFG_LOCKCNT_SHIFT) & PLLCFG_LOCKCNT_MASK;
+	writel(reg, clk->pll_cfg);
+
+	/* bypass PLL */
+	reg = readl(clk->pll_ctrl);
+	reg |= PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+	/* reset PLL */
+	reg |= PLLCTRL_RESET_MASK;
+	writel(reg, clk->pll_ctrl);
+	reg &= ~PLLCTRL_RESET_MASK;
+	writel(reg, clk->pll_ctrl);
+	/* wait for PLL lock */
+	while (readl(clk->pll_status) & (1 << clk->lockbit)) ;
+	/* remove bypass */
+	reg &= ~PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	spin_unlock_irqrestore(&clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_pll_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *prate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 fbdiv;
+
+	if (clk->bypassed)
+		return *prate;
+
+	fbdiv = DIV_ROUND_CLOSEST(rate, *prate);
+	if (fbdiv < 13)
+		fbdiv = 13;
+	else if (fbdiv > 66)
+		fbdiv = 66;
+
+	return *prate * fbdiv;
+}
+
+/**
+ * zynq_pll_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_pll_recalc_rate(struct clk_hw *hw, unsigned long
+		parent_rate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 fbdiv;
+
+	if (clk->bypassed)
+		return parent_rate;
+
+	/* makes probably sense to redundantly save fbdiv in the struct
+	 * zynq_pll to save the IO access. */
+	fbdiv = (readl(clk->pll_ctrl) & PLLCTRL_FBDIV_MASK) >>
+		PLLCTRL_FBDIV_SHIFT;
+
+	return parent_rate * fbdiv;
+}
+
+/**
+ * zynq_pll_enable - Enable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static int zynq_pll_enable(struct clk_hw *hw)
+{
+	unsigned long flags = 0;
+	u32 reg;
+	struct zynq_pll *clk = to_zynq_pll(hw);
+
+	if (!clk->bypassed)
+		return 0;
+
+	pr_info("PLL: Enable\n");
+
+	/* Power up PLL and wait for lock before removing bypass */
+	spin_lock_irqsave(&clk->lock, flags);
+
+	reg = readl(clk->pll_ctrl);
+	reg &= ~(PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK);
+	writel(reg, clk->pll_ctrl);
+	while (readl(clk->pll_status) & (1 << clk->lockbit))
+		;
+
+	reg = readl(clk->pll_ctrl);
+	reg &= ~PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	spin_unlock_irqrestore(&clk->lock, flags);
+
+	clk->bypassed = 0;
+
+	return 0;
+}
+
+/**
+ * zynq_pll_disable - Disable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static void zynq_pll_disable(struct clk_hw *hw)
+{
+	unsigned long flags = 0;
+	u32 reg;
+	struct zynq_pll *clk = to_zynq_pll(hw);
+
+	if (clk->bypassed)
+		return;
+
+	pr_info("PLL: Bypass\n");
+
+	/* Set bypass bit and shut down PLL */
+	spin_lock_irqsave(&clk->lock, flags);
+
+	reg = readl(clk->pll_ctrl);
+	reg |= PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+	reg |= PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	spin_unlock_irqrestore(&clk->lock, flags);
+
+	clk->bypassed = 1;
+}
+
+/**
+ * zynq_pll_is_enabled - Check if a clock is enabled
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 1 if the clock is enabled, 0 otherwise.
+ *
+ * Not sure this is a good idea, but since disabled means bypassed for
+ * this clock implementation we say we are always enabled.
+ */
+static int zynq_pll_is_enabled(struct clk_hw *hw)
+{
+	return 1;
+}
+
+static const struct clk_ops zynq_pll_ops = {
+	.enable = zynq_pll_enable,
+	.disable = zynq_pll_disable,
+	.is_enabled = zynq_pll_is_enabled,
+	.set_rate = zynq_pll_set_rate,
+	.round_rate = zynq_pll_round_rate,
+	.recalc_rate = zynq_pll_recalc_rate
+};
+
+/**
+ * clk_register_zynq_pll() - Register PLL with the clock framework
+ * @np	Pointer to the DT device node
+ */
+static void clk_register_zynq_pll(struct device_node *np)
+{
+	struct zynq_pll *pll;
+	struct clk *clk;
+	int ret;
+	u32 reg;
+	u32 regs[3];
+	const char *parent_name;
+	unsigned long flags = 0;
+	struct clk_init_data initd = {
+		.ops = &zynq_pll_ops,
+		.num_parents = 1,
+		.flags = 0
+	};
+
+	ret = of_property_read_u32_array(np, "reg", regs, ARRAY_SIZE(regs));
+	if (WARN_ON(ret))
+		return;
+
+	if (of_property_read_string(np, "clock-output-names", &initd.name))
+		initd.name = np->name;
+
+	parent_name = of_clk_get_parent_name(np, 0);
+	initd.parent_names = &parent_name;
+
+	pll = kmalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll) {
+		pr_err("%s: Could not allocate Zynq PLL clk.\n", __func__);
+		return;
+	}
+
+	/* Populate the struct */
+	pll->hw.init = &initd;
+	pll->pll_ctrl = zynq_slcr_base + regs[0];
+	pll->pll_cfg = zynq_slcr_base + regs[1];
+	pll->pll_status = zynq_slcr_base + regs[2];
+	spin_lock_init(&pll->lock);
+	ret = of_property_read_u32(np, "lockbit", &pll->lockbit);
+	if (WARN_ON(ret))
+		goto free_pll;
+
+
+	if (readl(pll->pll_ctrl) & PLLCTRL_BYPASS_MASK)
+		pll->bypassed = 1;
+	else
+		pll->bypassed = 0;
+
+	spin_lock_irqsave(&pll->lock, flags);
+
+	reg = readl(pll->pll_ctrl);
+	reg &= ~PLLCTRL_BPQUAL_MASK;
+	writel(reg, pll->pll_ctrl);
+
+	spin_unlock_irqrestore(&pll->lock, flags);
+
+	clk = clk_register(NULL, &pll->hw);
+	if (WARN_ON(IS_ERR(clk)))
+		goto free_pll;
+
+	WARN_ON(of_clk_add_provider(np, of_clk_src_simple_get, clk));
+	/*
+	 * at least until all clock lookups and init is converted to DT add a
+	 * clkdev to help clk lookups
+	 */
+	clk_register_clkdev(clk, NULL, initd.name);
+
+	return;
+
+free_pll:
+	kfree(pll);
+}
+
+
+static DEFINE_SPINLOCK(armclk_lock);
+static DEFINE_SPINLOCK(ddrclk_lock);
+static DEFINE_SPINLOCK(dciclk_lock);
+static DEFINE_SPINLOCK(pcapclk_lock);
+static DEFINE_SPINLOCK(smcclk_lock);
+static DEFINE_SPINLOCK(lqspiclk_lock);
+static DEFINE_SPINLOCK(gem0clk_lock);
+static DEFINE_SPINLOCK(gem1clk_lock);
+static DEFINE_SPINLOCK(fpga0clk_lock);
+static DEFINE_SPINLOCK(fpga1clk_lock);
+static DEFINE_SPINLOCK(fpga2clk_lock);
+static DEFINE_SPINLOCK(fpga3clk_lock);
+static DEFINE_SPINLOCK(canclk_lock);
+static DEFINE_SPINLOCK(sdioclk_lock);
+static DEFINE_SPINLOCK(uartclk_lock);
+static DEFINE_SPINLOCK(spiclk_lock);
+static DEFINE_SPINLOCK(dbgclk_lock);
+static DEFINE_SPINLOCK(aperclk_lock);
+
+
+/* Clock parent arrays */
+static const char *cpu_parents[] __initdata = {"armpll", "armpll",
+	"ddrpll", "iopll"};
+static const char *def_periph_parents[] __initdata = {"iopll", "iopll",
+	"armpll", "ddrpll"};
+static const char *gem_parents[] __initdata = {"iopll", "iopll", "armpll",
+	"ddrpll", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO"};
+static const char *dbg_parents[] __initdata = {"iopll", "iopll", "armpll",
+	"ddrpll", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC"};
+static const char *dci_parents[] __initdata = {"ddrpll"};
+static const char *clk621_parents[] __initdata = {"CPU_MASTER_CLK"};
+
+/**
+ * zynq_clkdev_add() - Add a clock device
+ * @con_id: Connection identifier
+ * @dev_id: Device identifier
+ * @clk: Struct clock to associate with given connection and device.
+ *
+ * Create a clkdev entry for a given device/clk
+ */
+static void __init zynq_clkdev_add(const char *con_id, const char *dev_id,
+		struct clk *clk)
+{
+	if (clk_register_clkdev(clk, con_id, dev_id))
+		pr_warn("Adding clkdev failed.");
+}
+
+static const struct of_device_id clk_match[] __initconst = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "xlnx,zynq-pll", .data = clk_register_zynq_pll, },
+	{}
+};
+
+/**
+ * zynq_clock_init() - Clock initalization
+ *
+ * Register clocks and clock devices with the common clock framework.
+ * To avoid enabling unused clocks, only leaf clocks are present for which the
+ * drivers supports the common clock framework.
+ */
+void __init zynq_clock_init(void __iomem *slcr_base)
+{
+	struct clk *clk;
+
+	pr_info("Zynq clock init\n");
+
+	zynq_slcr_base = slcr_base;
+	of_clk_init(clk_match);
+
+	/* CPU clocks */
+	clk = clk_register_zynq_d1m("CPU_MASTER_CLK", SLCR_ARM_CLK_CTRL,
+			cpu_parents, 4, &armclk_lock);
+	clk = clk_register_gate(NULL, "CPU_6OR4X_CLK", "CPU_MASTER_CLK",
+			CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED,
+			SLCR_ARM_CLK_CTRL, 24, 0, &armclk_lock);
+	zynq_clkdev_add(NULL, "CPU_6OR4X_CLK", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_fixed_factor(NULL, "CPU_3OR2X_DIV_CLK",
+			"CPU_MASTER_CLK", 0, 1, 2);
+	clk = clk_register_gate(NULL, "CPU_3OR2X_CLK", "CPU_3OR2X_DIV_CLK",
+			CLK_IGNORE_UNUSED, SLCR_ARM_CLK_CTRL, 25, 0,
+			&armclk_lock);
+	zynq_clkdev_add(NULL, "smp_twd", clk);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_zynq_clk621("CPU_1X_DIV_CLK", SLCR_ARM_CLK_CTRL,
+		SLCR_621_TRUE, 4, 2, clk621_parents, 1, &armclk_lock);
+	clk = clk_register_zynq_clk621("CPU_2X_DIV_CLK", SLCR_ARM_CLK_CTRL,
+		SLCR_621_TRUE, 2, 1, clk621_parents, 1, &armclk_lock);
+	clk = clk_register_gate(NULL, "CPU_2X_CLK", "CPU_2X_DIV_CLK",
+			CLK_IGNORE_UNUSED, SLCR_ARM_CLK_CTRL, 26, 0,
+			&armclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_gate(NULL, "CPU_1X_CLK", "CPU_1X_DIV_CLK",
+			CLK_IGNORE_UNUSED, SLCR_ARM_CLK_CTRL, 27, 0,
+			&armclk_lock);
+	zynq_clkdev_add(NULL, "CPU_1X_CLK", clk);
+	clk_register_clkdev(clk, "apb_pclk", NULL);
+	clk_prepare(clk);
+	clk_enable(clk);
+	/* DDR clocks */
+	clk = clk_register_divider(NULL, "DDR_2X_DIV_CLK", "ddrpll", 0,
+			SLCR_DDR_CLK_CTRL, 26, 6, CLK_DIVIDER_ONE_BASED,
+			&ddrclk_lock);
+	clk = clk_register_gate(NULL, "DDR_2X_CLK", "DDR_2X_DIV_CLK", 0,
+			SLCR_DDR_CLK_CTRL, 1, 0, &ddrclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_divider(NULL, "DDR_3X_DIV_CLK", "ddrpll", 0,
+			SLCR_DDR_CLK_CTRL, 20, 6, CLK_DIVIDER_ONE_BASED,
+			&ddrclk_lock);
+	clk = clk_register_gate(NULL, "DDR_3X_CLK", "DDR_3X_DIV_CLK", 0,
+			SLCR_DDR_CLK_CTRL, 0, 0, &ddrclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	clk = clk_register_zynq_gd2m("DCI_CLK", SLCR_DCI_CLK_CTRL, dci_parents,
+			1, &dciclk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+
+	/* Peripheral clocks */
+	clk = clk_register_zynq_gd1m("LQSPI_CLK", SLCR_LQSPI_CLK_CTRL,
+			def_periph_parents, &lqspiclk_lock);
+	zynq_clkdev_add(NULL, "LQSPI", clk);
+
+	clk = clk_register_zynq_gd1m("SMC_CLK", SLCR_SMC_CLK_CTRL,
+			def_periph_parents, &smcclk_lock);
+	zynq_clkdev_add(NULL, "SMC", clk);
+
+	clk = clk_register_zynq_gd1m("PCAP_CLK", SLCR_PCAP_CLK_CTRL,
+			def_periph_parents, &pcapclk_lock);
+	zynq_clkdev_add(NULL, "PCAP", clk);
+
+	clk = clk_register_zynq_gd2m("GEM0_CLK", SLCR_GEM0_CLK_CTRL,
+			gem_parents, 8, &gem0clk_lock);
+	zynq_clkdev_add(NULL, "GEM0", clk);
+	clk = clk_register_zynq_gd2m("GEM1_CLK", SLCR_GEM1_CLK_CTRL,
+			gem_parents, 8, &gem1clk_lock);
+	zynq_clkdev_add(NULL, "GEM1", clk);
+
+	clk = clk_register_zynq_d2m("FPGA0_CLK", SLCR_FPGA0_CLK_CTRL,
+			def_periph_parents, &fpga0clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA0", clk);
+	clk = clk_register_zynq_d2m("FPGA1_CLK", SLCR_FPGA1_CLK_CTRL,
+			def_periph_parents, &fpga1clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA1", clk);
+	clk = clk_register_zynq_d2m("FPGA2_CLK", SLCR_FPGA2_CLK_CTRL,
+			def_periph_parents, &fpga2clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA2", clk);
+	clk = clk_register_zynq_d2m("FPGA3_CLK", SLCR_FPGA3_CLK_CTRL,
+			def_periph_parents, &fpga3clk_lock);
+	clk_prepare(clk);
+	clk_enable(clk);
+	zynq_clkdev_add(NULL, "FPGA3", clk);
+	clk = clk_register_zynq_d2m("CAN_MASTER_CLK", SLCR_CAN_CLK_CTRL,
+			def_periph_parents, &canclk_lock);
+
+	clk = clk_register_zynq_d1m("SDIO_MASTER_CLK", SLCR_SDIO_CLK_CTRL,
+			def_periph_parents, 4, &sdioclk_lock);
+	clk = clk_register_zynq_d1m("UART_MASTER_CLK", SLCR_UART_CLK_CTRL,
+			def_periph_parents, 4, &uartclk_lock);
+	clk = clk_register_zynq_d1m("SPI_MASTER_CLK", SLCR_SPI_CLK_CTRL,
+			def_periph_parents, 4, &spiclk_lock);
+	clk = clk_register_zynq_d1m("DBG_MASTER_CLK", SLCR_DBG_CLK_CTRL,
+			dbg_parents, 8, &dbgclk_lock);
+
+	/*
+	 * clk = clk_register_gate(NULL, "CAN0_CLK", "CAN_MASTER_CLK",
+	 *	CLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL,
+	 *	0, 0, &canclk_lock);
+	 * zynq_clkdev_add(NULL, "CAN0", clk);
+	 * clk = clk_register_gate(NULL, "CAN1_CLK", "CAN_MASTER_CLK",
+	 *	CLK_SET_RATE_PARENT, SLCR_CAN_CLK_CTRL,
+	 *	1, 0, &canclk_lock);
+	 * zynq_clkdev_add(NULL, "CAN1", clk);
+	 */
+
+	clk = clk_register_gate(NULL, "SDIO0_CLK", "SDIO_MASTER_CLK",
+			CLK_SET_RATE_PARENT, SLCR_SDIO_CLK_CTRL, 0, 0,
+			&sdioclk_lock);
+	zynq_clkdev_add(NULL, "SDIO0", clk);
+	clk = clk_register_gate(NULL, "SDIO1_CLK", "SDIO_MASTER_CLK",
+			CLK_SET_RATE_PARENT, SLCR_SDIO_CLK_CTRL, 1, 0,
+			&sdioclk_lock);
+	zynq_clkdev_add(NULL, "SDIO1", clk);
+
+	clk = clk_register_gate(NULL, "UART0_CLK", "UART_MASTER_CLK",
+			CLK_SET_RATE_PARENT, SLCR_UART_CLK_CTRL, 0, 0,
+			&uartclk_lock);
+	zynq_clkdev_add(NULL, "UART0", clk);
+	clk = clk_register_gate(NULL, "UART1_CLK", "UART_MASTER_CLK",
+			CLK_SET_RATE_PARENT, SLCR_UART_CLK_CTRL, 1, 0,
+			&uartclk_lock);
+	zynq_clkdev_add(NULL, "UART1", clk);
+
+	clk = clk_register_gate(NULL, "SPI0_CLK", "SPI_MASTER_CLK",
+			CLK_SET_RATE_PARENT, SLCR_SPI_CLK_CTRL, 0, 0,
+			&spiclk_lock);
+	zynq_clkdev_add(NULL, "SPI0", clk);
+	clk = clk_register_gate(NULL, "SPI1_CLK", "SPI_MASTER_CLK",
+			CLK_SET_RATE_PARENT, SLCR_SPI_CLK_CTRL, 1, 0,
+			&spiclk_lock);
+	zynq_clkdev_add(NULL, "SPI1", clk);
+	/*
+	 * clk = clk_register_gate(NULL, "DBGTRC_CLK", "DBG_MASTER_CLK",
+	 *		CLK_SET_RATE_PARENT, SLCR_DBG_CLK_CTRL,	0, 0,
+	 *		&dbgclk_lock);
+	 * zynq_clkdev_add(NULL, "DBGTRC", clk);
+	 * clk = clk_register_gate(NULL, "DBG1X_CLK", "DBG_MASTER_CLK",
+	 *		CLK_SET_RATE_PARENT, SLCR_DBG_CLK_CTRL, 1, 0,
+	 *		&dbgclk_lock);
+	 * zynq_clkdev_add(NULL, "DBG1X", clk);
+	 */
+
+	/* One gated clock for all APER clocks. */
+	/*
+	 * clk = clk_register_gate(NULL, "DMA_CPU2X", "CPU_2X_CLK", 0,
+	 *		SLCR_APER_CLK_CTRL, 0, 0, &aperclk_lock);
+	 * zynq_clkdev_add(NULL, "DMA_APER", clk);
+	 */
+	clk = clk_register_gate(NULL, "USB0_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 2, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "USB0_APER", clk);
+	clk = clk_register_gate(NULL, "USB1_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 3, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "USB1_APER", clk);
+	clk = clk_register_gate(NULL, "GEM0_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 6, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "GEM0_APER", clk);
+	clk = clk_register_gate(NULL, "GEM1_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 7, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "GEM1_APER", clk);
+	clk = clk_register_gate(NULL, "SDI0_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 10, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "SDIO0_APER", clk);
+	clk = clk_register_gate(NULL, "SDI1_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 11, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "SDIO1_APER", clk);
+	clk = clk_register_gate(NULL, "SPI0_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 14, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "SPI0_APER", clk);
+	clk = clk_register_gate(NULL, "SPI1_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 15, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "SPI1_APER", clk);
+	/*
+	 * clk = clk_register_gate(NULL, "CAN0_CPU1X", "CPU_1X_CLK", 0,
+	 *		SLCR_APER_CLK_CTRL, 16, 0, &aperclk_lock);
+	 * zynq_clkdev_add(NULL, "CAN0_APER", clk);
+	 * clk = clk_register_gate(NULL, "CAN1_CPU1X", "CPU_1X_CLK", 0,
+	 *		SLCR_APER_CLK_CTRL, 17, 0, &aperclk_lock);
+	 * zynq_clkdev_add(NULL, "CAN1_APER", clk);
+	 */
+	clk = clk_register_gate(NULL, "I2C0_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 18, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "I2C0_APER", clk);
+	clk = clk_register_gate(NULL, "I2C1_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 19, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "I2C1_APER", clk);
+	clk = clk_register_gate(NULL, "UART0_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 20, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "UART0_APER", clk);
+	clk = clk_register_gate(NULL, "UART1_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 21, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "UART1_APER", clk);
+	clk = clk_register_gate(NULL, "GPIO_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 22, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "GPIO_APER", clk);
+	clk = clk_register_gate(NULL, "LQSPI_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 23, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "LQSPI_APER", clk);
+	clk = clk_register_gate(NULL, "SMC_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 24, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "SMC_APER", clk);
+}
diff --git a/drivers/clk/zynq/clk621.c b/drivers/clk/zynq/clk621.c
new file mode 100644
index 0000000..dcf3918
--- /dev/null
+++ b/drivers/clk/zynq/clk621.c
@@ -0,0 +1,171 @@
+/*
+ * A try to model the Zynq CPU_1X and CPU_2X clocks. These clocks depend on the
+ * setting in the clk621_true register. They have the same clock parent
+ * (CPU_MASTER_CLK/CPU_6OR4X) but a common 'divider'.
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk/zynq.h>
+
+/**
+ * struct zynq_clk621
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @clkctrl:	Pointer to clock control register
+ * @clk621:	Pointer to CLK_621_TRUE register
+ * @basediv:	Base clock divider
+ * @divadd:	Clock divider increment for 621 mode
+ * @lock:	Register lock
+ */
+struct zynq_clk621 {
+	struct clk_hw	hw;
+	void __iomem	*clkctrl;
+	void __iomem	*clk621;
+	unsigned int	basediv;
+	unsigned int	divadd;
+	spinlock_t	*lock;
+};
+#define to_zynq_clk621(_hw) container_of(_hw,\
+		struct zynq_clk621, hw);
+#define CLK621_MASK 1
+#define CLK621_SHIFT 0
+
+/**
+ * zynq_clk621_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_clk621_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *prate)
+{
+	unsigned long rerror1;
+	unsigned long rerror2;
+	long rate1;
+	long rate2;
+	struct zynq_clk621 *clk = to_zynq_clk621(hw);
+
+	rate1 = *prate / clk->basediv;
+	rate2 = *prate / (clk->basediv + clk->divadd);
+
+	if (rate1 > rate)
+		rerror1 = rate1 - rate;
+	else
+		rerror1 = rate - rate1;
+	if (rate2 > rate)
+		rerror2 = rate2 - rate;
+	else
+		rerror2 = rate - rate1;
+	if (rerror1 > rerror2)
+		return rate2;
+	else
+		return rate1;
+}
+
+/**
+ * zynq_clk621_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_clk621_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	unsigned int div;
+	struct zynq_clk621 *clk = to_zynq_clk621(hw);
+
+	div = clk->basediv;
+
+	if ((readl(clk->clk621) & CLK621_MASK) >> CLK621_SHIFT)
+		div += clk->divadd;
+	return parent_rate / div;
+}
+
+
+/**
+ * zynq_clk621_set_rate() - Change clock frequncy
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ *
+ * I doubt we can safely set a new rate. Changing the rate of one of these
+ * clocks will also affect the other. We cannot model this kind of dependency on
+ * the same hierarchical level
+ */
+static int zynq_clk621_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	return -EINVAL;
+}
+
+static const struct clk_ops zynq_clk621_ops = {
+	.set_rate = zynq_clk621_set_rate,
+	.round_rate = zynq_clk621_round_rate,
+	.recalc_rate = zynq_clk621_recalc_rate
+};
+
+/**
+ * clk_register_zynq_clk621() - Register a clk621 with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @clk621:	Pointer to CLK_621_TRUE register
+ * @basediv:	Base clock divider
+ * @divadd:	Clock divider increment for 621 mode
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_clk621(const char *name,
+		void __iomem *clkctrl, void __iomem *clk621,
+		unsigned int basediv,
+		unsigned int divadd, const char **pnames, u8 num_parents,
+		spinlock_t *lock)
+{
+	struct clk *ret;
+	struct zynq_clk621 *clk;
+	struct clk_init_data initd = {
+		.name = name,
+		.ops = &zynq_clk621_ops,
+		.parent_names = pnames,
+		.num_parents = num_parents,
+		.flags = 0
+	};
+
+	clk = kmalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk) {
+		pr_err("%s: could not allocate Zynq clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* Populate the struct */
+	clk->hw.init = &initd;
+	clk->clkctrl = clkctrl;
+	clk->clk621 = clk621;
+	clk->basediv = basediv;
+	clk->divadd = divadd;
+	clk->lock = lock;
+
+	ret = clk_register(NULL, &clk->hw);
+
+	if (IS_ERR(ret))
+		kfree(clk);
+
+	return ret;
+}
diff --git a/drivers/clk/zynq/peripheral_clk.c b/drivers/clk/zynq/peripheral_clk.c
new file mode 100644
index 0000000..ea33d68
--- /dev/null
+++ b/drivers/clk/zynq/peripheral_clk.c
@@ -0,0 +1,515 @@
+/**
+ * Xilinx Zynq Clock Implementations for Peripheral clocks.
+ *
+ * zynq_periphclk_* where * is one of:
+ * d1m: 1 divisor register, muxable
+ * d2m: 2 divisor registers, muxable
+ * gd1m: 1 divisor register, muxable, gateable
+ * gd2m: 2 divisor registers, muxable, gateable
+ *
+ *
+ *  Copyright (C) 2012 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/clk/zynq.h>
+
+/**
+ * struct zynq_periph_clk
+ * @hw:		handle between common and hardware-specific interfaces
+ * @clkctrl:	CLK control register
+ * @lock:	register lock
+ */
+struct zynq_periph_clk {
+	struct clk_hw	hw;
+	void __iomem	*clkctrl;
+	spinlock_t	*lock;
+};
+#define to_zynq_periph_clk(_hw)\
+	container_of(_hw, struct zynq_periph_clk, hw)
+#define CLKCTRL_DIV_MASK	0x3f00
+#define CLKCTRL_DIV_SHIFT	8
+#define CLKCTRL_DIV1_MASK	CLKCTRL_DIV_MASK
+#define CLKCTRL_DIV1_SHIFT	CLKCTRL_DIV_SHIFT
+#define CLKCTRL_DIV2_MASK	0x3f00000
+#define CLKCTRL_DIV2_SHIFT	20
+/*
+ * This is a hack: We have clocks with 0 - 3 bit muxes. If present they start
+ * all in the corresponding clk_ctrl reg. If narrower than 3 bits the bit fiels
+ * is write ignore/read zero. Alternatively we could save the mask and shift
+ * values in the zynq_periph_clk_* struct, like the clk-mux implementation.
+ */
+#define CLKCTRL_CLKSRC_MASK	0x70
+#define CLKCTRL_CLKSRC_SHIFT	4
+#define CLKCTRL_ENABLE_MASK	1
+#define CLKCTRL_ENABLE_SHIFT	0
+
+/* Clock gating ops for peripheral clocks featuring 1 gate */
+/**
+ * zynq_periphclk_gate1_enable - Enable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static int zynq_periphclk_gate1_enable(struct clk_hw *hw)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	spin_lock_irqsave(clk->lock, flags);
+	reg = readl(clk->clkctrl);
+	reg |= CLKCTRL_ENABLE_MASK;
+	writel(reg, clk->clkctrl);
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_gate1_disable - Disable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static void zynq_periphclk_gate1_disable(struct clk_hw *hw)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	spin_lock_irqsave(clk->lock, flags);
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_ENABLE_MASK;
+	writel(reg, clk->clkctrl);
+	spin_unlock_irqrestore(clk->lock, flags);
+}
+
+/**
+ * zynq_periphclk_gate1_is_enabled - Check if a clock is enabled
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 1 if the clock is enabled, 0 otherwise.
+ */
+static int zynq_periphclk_gate1_is_enabled(struct clk_hw *hw)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	/* do we need lock for read? */
+	spin_lock_irqsave(clk->lock, flags);
+	reg = readl(clk->clkctrl);
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return (reg & CLKCTRL_ENABLE_MASK) >> CLKCTRL_ENABLE_SHIFT;
+}
+
+/* Rate set/get functions for peripheral clocks with a single divisor */
+/**
+ * zynq_periphclk_div1_set_rate() - Change clock frequncy
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_periphclk_div1_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	u32 div = DIV_ROUND_CLOSEST(prate, rate);
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	if ((div < 1) || (div > 0x3f))
+		return -EINVAL;
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_DIV_MASK;
+	reg |= div << CLKCTRL_DIV_SHIFT;
+	writel(reg, clk->clkctrl);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_div1_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_periphclk_div1_round_rate(struct clk_hw *hw,
+		unsigned long rate, unsigned long *prate)
+{
+	long div;
+
+	div = DIV_ROUND_CLOSEST(*prate, rate);
+	if (div < 1)
+		div = 1;
+	if (div > 0x3f)
+		div = 0x3f;
+
+	return *prate / div;
+}
+
+/**
+ * zynq_periphclk_div1_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_periphclk_div1_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	u32 div;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	/*
+	 * makes probably sense to redundantly save div in the struct
+	 * zynq_periphclk_gd1m to save the IO access. Do we need spinlock for
+	 * read access?
+	 */
+	div = (readl(clk->clkctrl) & CLKCTRL_DIV_MASK) >> CLKCTRL_DIV_SHIFT;
+	if (div < 1)
+		div = 1;
+
+	return parent_rate / div;
+}
+
+/* Rate set/get functions for peripheral clocks with two divisors */
+/**
+ * zynq_periphclk_get_best_divs2 - Calculate best divisors values
+ * @inputrate: Clock input frequency
+ * @targetrate: Desired output frequency
+ * @div1: Value for divisor 1 (return value)
+ * @div2: Value for divisor 2 (return value)
+ * Returns the resulting frequency or zero if no valid divisors are found.
+ *
+ * Calculate the best divisors values to achieve a given target frequency for a
+ * given input frequency for clocks with two dividers fields
+ */
+static unsigned long
+zynq_periphclk_get_best_divs2(const unsigned long inputrate,
+		const unsigned long targetrate, u32 *div1, u32 *div2)
+{
+	u32 d1;
+	u32 d2;
+	unsigned long calcrate;
+	unsigned long bestrate = 0;
+	unsigned int error;
+	unsigned int besterror = ~0;
+
+	/* Probably micro-optimizing, but probably worth thinking about reducing
+	 * the iterations and/or getting rid of some divisions */
+	for (d1 = 1; d1 <= 0x3f; d1++) {
+		d2 = DIV_ROUND_CLOSEST(inputrate / d1, targetrate);
+		if ((d2 < 1) || (d2 > 0x3f))
+			continue;
+		calcrate = (inputrate / d1) / d2;
+
+		if (calcrate > targetrate)
+			error = calcrate - targetrate;
+		else
+			error = targetrate - calcrate;
+
+		if (error < besterror) {
+			*div1 = d1;
+			*div2 = d2;
+			bestrate = calcrate;
+			besterror = error;
+		}
+	}
+
+	return bestrate;
+}
+
+/**
+ * zynq_periphclk_div2_set_rate() - Change clock frequncy
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_periphclk_div2_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	u32 div1;
+	u32 div2;
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	if (!zynq_periphclk_get_best_divs2(prate, rate, &div1, &div2))
+		return -EINVAL;
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_DIV1_MASK;
+	reg &= ~CLKCTRL_DIV2_MASK;
+	reg |= div1 << CLKCTRL_DIV1_SHIFT;
+	reg |= div2 << CLKCTRL_DIV2_SHIFT;
+	writel(reg, clk->clkctrl);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_div2_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_periphclk_div2_round_rate(struct clk_hw *hw,
+		unsigned long rate, unsigned long *prate)
+{
+	u32 div1;
+	u32 div2;
+	long ret;
+
+	ret = zynq_periphclk_get_best_divs2(*prate, rate, &div1, &div2);
+	if (!ret)
+		return -EINVAL;
+
+	return ret;
+}
+
+/**
+ * zynq_periphclk_div1_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_periphclk_div2_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	u32 div1;
+	u32 div2;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	/*
+	 * makes probably sense to redundantly save div in the struct
+	 * zynq_periphclk_gd1m to save the IO access. Should we use spinlock for
+	 * reading?
+	 */
+	div1 = (readl(clk->clkctrl) & CLKCTRL_DIV1_MASK) >> CLKCTRL_DIV1_SHIFT;
+	div2 = (readl(clk->clkctrl) & CLKCTRL_DIV2_MASK) >> CLKCTRL_DIV2_SHIFT;
+	if (div1 < 1)
+		div1 = 1;
+	if (div2 < 1)
+		div2 = 1;
+
+	return (parent_rate / div1) / div2;
+}
+
+/* Muxing functions for peripheral clocks */
+/**
+ * zynq_periphclk_set_parent() - Reparent clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @index:	Index of new parent.
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_periphclk_set_parent(struct clk_hw *hw, u8 index)
+{
+	u32 reg;
+	unsigned long flags = 0;
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	spin_lock_irqsave(clk->lock, flags);
+
+	reg = readl(clk->clkctrl);
+	reg &= ~CLKCTRL_CLKSRC_MASK;
+	reg |= index << CLKCTRL_CLKSRC_SHIFT;
+	writel(reg, clk->clkctrl);
+
+	spin_unlock_irqrestore(clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_periphclk_get_parent() - Reparent clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns the index of the current clock parent.
+ */
+static u8 zynq_periphclk_get_parent(struct clk_hw *hw)
+{
+	struct zynq_periph_clk *clk =
+		to_zynq_periph_clk(hw);
+
+	return (readl(clk->clkctrl) & CLKCTRL_CLKSRC_MASK) >>
+		CLKCTRL_CLKSRC_SHIFT;
+}
+
+/* Clk register functions */
+/**
+ * clk_register_zynq_common() - Register a clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @ops:	Pointer to the struct clock_ops
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+static struct clk *clk_register_zynq_common(const char *name,
+		void __iomem *clkctrl, const struct clk_ops *ops,
+		const char **pnames, u8 num_parents, spinlock_t *lock)
+{
+	struct clk *ret;
+	struct zynq_periph_clk *clk;
+	struct clk_init_data initd = {
+		.name = name,
+		.ops = ops,
+		.parent_names = pnames,
+		.num_parents = num_parents,
+		.flags = 0
+	};
+
+	clk = kmalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk) {
+		pr_err("%s: could not allocate Zynq clock\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* Populate the struct */
+	clk->hw.init = &initd;
+	clk->clkctrl = clkctrl;
+	clk->lock = lock;
+
+	ret = clk_register(NULL, &clk->hw);
+	if (IS_ERR(ret))
+		kfree(clk);
+
+	return ret;
+}
+
+/* Clock ops structs for the different peripheral clock types */
+static const struct clk_ops zynq_periphclk_gd1m_ops = {
+	.enable = zynq_periphclk_gate1_enable,
+	.disable = zynq_periphclk_gate1_disable,
+	.is_enabled = zynq_periphclk_gate1_is_enabled,
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div1_set_rate,
+	.round_rate = zynq_periphclk_div1_round_rate,
+	.recalc_rate = zynq_periphclk_div1_recalc_rate
+};
+
+static const struct clk_ops zynq_periphclk_gd2m_ops = {
+	.enable = zynq_periphclk_gate1_enable,
+	.disable = zynq_periphclk_gate1_disable,
+	.is_enabled = zynq_periphclk_gate1_is_enabled,
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div2_set_rate,
+	.round_rate = zynq_periphclk_div2_round_rate,
+	.recalc_rate = zynq_periphclk_div2_recalc_rate
+};
+
+static const struct clk_ops zynq_periphclk_d2m_ops = {
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div2_set_rate,
+	.round_rate = zynq_periphclk_div2_round_rate,
+	.recalc_rate = zynq_periphclk_div2_recalc_rate
+};
+
+static const struct clk_ops zynq_periphclk_d1m_ops = {
+	.set_parent = zynq_periphclk_set_parent,
+	.get_parent = zynq_periphclk_get_parent,
+	.set_rate = zynq_periphclk_div1_set_rate,
+	.round_rate = zynq_periphclk_div1_round_rate,
+	.recalc_rate = zynq_periphclk_div1_recalc_rate
+};
+
+/* Clock register functions for the different peripheral clock types */
+/**
+ * clk_register_zynq_gd1m() - Register a gd1m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_gd1m(const char *name,
+		void __iomem *clkctrl, const char **pnames, spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_gd1m_ops,
+			pnames, 4, lock);
+}
+
+/**
+ * clk_register_zynq_gd2m() - Register a gd2m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_gd2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_gd2m_ops,
+			pnames, num_parents, lock);
+}
+
+/**
+ * clk_register_zynq_d2m() - Register a d2m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_d2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_d2m_ops,
+			pnames, 4, lock);
+}
+
+/**
+ * clk_register_zynq_d1m() - Register a d1m clock with the clock framework
+ * @name:	Clock name
+ * @clkctrl:	Pointer to clock control register
+ * @pnames:	Array of names of clock parents
+ * @num_parents:Number of parents
+ * @lock:	Register lock
+ * Returns clk_register() return value or errpointer.
+ */
+struct clk *clk_register_zynq_d1m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock)
+{
+	return clk_register_zynq_common(name, clkctrl, &zynq_periphclk_d1m_ops,
+			pnames, num_parents, lock);
+}
diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
index a0b3661..da26ab7 100644
--- a/drivers/cpufreq/Kconfig.arm
+++ b/drivers/cpufreq/Kconfig.arm
@@ -83,3 +83,13 @@ config ARM_SPEAR_CPUFREQ
 	default y
 	help
 	  This adds the CPUFreq driver support for SPEAr SOCs.
+
+config ARM_ZYNQ_CPUFREQ
+	bool "Xilinx Zynq"
+	depends on ARCH_ZYNQ
+	default n
+	select CPU_FREQ_TABLE
+	select PM_OPP
+	help
+	  This adds the CPUFreq driver for Xilinx Zynq SoCs.
+
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index fadc4d4..a263c6c 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_ARM_EXYNOS4X12_CPUFREQ)	+= exynos4x12-cpufreq.o
 obj-$(CONFIG_ARM_EXYNOS5250_CPUFREQ)	+= exynos5250-cpufreq.o
 obj-$(CONFIG_ARM_OMAP2PLUS_CPUFREQ)     += omap-cpufreq.o
 obj-$(CONFIG_ARM_SPEAR_CPUFREQ)		+= spear-cpufreq.o
+obj-$(CONFIG_ARM_ZYNQ_CPUFREQ)     	+= zynq-cpufreq.o
 
 ##################################################################################
 # PowerPC platform drivers
diff --git a/drivers/cpufreq/zynq-cpufreq.c b/drivers/cpufreq/zynq-cpufreq.c
new file mode 100644
index 0000000..a5c18ff
--- /dev/null
+++ b/drivers/cpufreq/zynq-cpufreq.c
@@ -0,0 +1,255 @@
+/*
+ * CPU frequency scaling for Zynq
+ *
+ * Based on drivers/cpufreq/omap-cpufreq.c,
+ * Copyright (C) 2005 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/module.h>
+#include <linux/opp.h>
+#include <linux/platform_device.h>
+#include <asm/smp_plat.h>
+#include <asm/cpu.h>
+
+#ifdef CONFIG_SMP
+struct lpj_info {
+	unsigned long	ref;
+	unsigned int	freq;
+};
+
+static DEFINE_PER_CPU(struct lpj_info, lpj_ref);
+static struct lpj_info global_lpj_ref;
+#endif
+
+static atomic_t freq_table_users = ATOMIC_INIT(0);
+static struct cpufreq_frequency_table *freq_table;
+static struct device *mpu_dev;
+static struct clk *cpuclk;
+
+static int zynq_verify_speed(struct cpufreq_policy *policy)
+{
+	if (!freq_table)
+		return -EINVAL;
+	return cpufreq_frequency_table_verify(policy, freq_table);
+}
+
+static unsigned int zynq_getspeed(unsigned int cpu)
+{
+	unsigned long rate;
+
+	if (cpu >= num_present_cpus())
+		return 0;
+
+	rate = clk_get_rate(cpuclk) / 1000;
+	return rate;
+}
+
+static int zynq_target(struct cpufreq_policy *policy,
+		       unsigned int target_freq,
+		       unsigned int relation)
+{
+	unsigned int i;
+	int ret = 0;
+	struct cpufreq_freqs freqs;
+
+	if (!freq_table) {
+		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
+				policy->cpu);
+		return -EINVAL;
+	}
+
+	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
+			relation, &i);
+	if (ret) {
+		dev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",
+			__func__, policy->cpu, target_freq, ret);
+		return ret;
+	}
+	freqs.new = freq_table[i].frequency;
+	if (!freqs.new) {
+		dev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,
+			policy->cpu, target_freq);
+		return -EINVAL;
+	}
+
+	freqs.old = zynq_getspeed(policy->cpu);
+	freqs.cpu = policy->cpu;
+
+	if (freqs.old == freqs.new && policy->cur == freqs.new)
+		return ret;
+
+	/* notifiers */
+	for_each_cpu(i, policy->cpus) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	}
+
+	dev_dbg(mpu_dev, "cpufreq-zynq: %u MHz --> %u MHz\n",
+			freqs.old / 1000, freqs.new / 1000);
+
+	ret = clk_set_rate(cpuclk, freqs.new * 1000);
+
+	freqs.new = zynq_getspeed(policy->cpu);
+#ifdef CONFIG_SMP
+	/*
+	 * Note that loops_per_jiffy is not updated on SMP systems in
+	 * cpufreq driver. So, update the per-CPU loops_per_jiffy value
+	 * on frequency transition. We need to update all dependent CPUs.
+	 */
+	for_each_cpu(i, policy->cpus) {
+		struct lpj_info *lpj = &per_cpu(lpj_ref, i);
+		if (!lpj->freq) {
+			lpj->ref = per_cpu(cpu_data, i).loops_per_jiffy;
+			lpj->freq = freqs.old;
+		}
+
+		per_cpu(cpu_data, i).loops_per_jiffy =
+			cpufreq_scale(lpj->ref, lpj->freq, freqs.new);
+	}
+
+	/* And don't forget to adjust the global one */
+	if (!global_lpj_ref.freq) {
+		global_lpj_ref.ref = loops_per_jiffy;
+		global_lpj_ref.freq = freqs.old;
+	}
+	loops_per_jiffy = cpufreq_scale(global_lpj_ref.ref, global_lpj_ref.freq,
+					freqs.new);
+#endif
+
+	/* notifiers */
+	for_each_cpu(i, policy->cpus) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+
+	return ret;
+}
+
+static inline void freq_table_free(void)
+{
+	if (atomic_dec_and_test(&freq_table_users))
+		opp_free_cpufreq_table(mpu_dev, &freq_table);
+}
+
+static int __cpuinit zynq_cpu_init(struct cpufreq_policy *policy)
+{
+	int result = 0;
+
+	cpuclk = clk_get_sys("CPU_6OR4X_CLK", NULL);
+	if (IS_ERR(cpuclk)) {
+		pr_warn("Xilinx: cpufreq: Clock not found.");
+		return PTR_ERR(cpuclk);
+	}
+
+	if (policy->cpu >= num_possible_cpus()) {
+		result = -EINVAL;
+		goto fail_ck;
+	}
+
+	policy->cur = policy->min = policy->max = zynq_getspeed(policy->cpu);
+
+	if (!freq_table)
+		result = opp_init_cpufreq_table(mpu_dev, &freq_table);
+
+	if (result) {
+		dev_err(mpu_dev, "%s: cpu%d: failed creating freq table[%d]\n",
+				__func__, policy->cpu, result);
+		goto fail_ck;
+	}
+
+	atomic_inc(&freq_table_users);
+
+	result = cpufreq_frequency_table_cpuinfo(policy, freq_table);
+	if (result)
+		goto fail_table;
+
+	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
+
+	policy->min = policy->cpuinfo.min_freq;
+	policy->max = policy->cpuinfo.max_freq;
+	policy->cur = zynq_getspeed(policy->cpu);
+
+	/*
+	 * On Zynq configuartion, both processors share the voltage
+	 * and clock. So both CPUs needs to be scaled together and hence
+	 * needs software co-ordination. Use cpufreq affected_cpus
+	 * interface to handle this scenario. Additional is_smp() check
+	 * is to keep SMP_ON_UP build working.
+	 */
+	if (is_smp()) {
+		policy->shared_type = CPUFREQ_SHARED_TYPE_ANY;
+		cpumask_setall(policy->cpus);
+	}
+
+	/* FIXME: what's the actual transition time? */
+	policy->cpuinfo.transition_latency = 300 * 1000;
+
+	return 0;
+
+fail_table:
+	freq_table_free();
+fail_ck:
+	clk_put(cpuclk);
+	return result;
+}
+
+static int zynq_cpu_exit(struct cpufreq_policy *policy)
+{
+	freq_table_free();
+	clk_put(cpuclk);
+	return 0;
+}
+
+static struct freq_attr *zynq_cpufreq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver zynq_cpufreq_driver = {
+	.flags		= CPUFREQ_STICKY,
+	.verify		= zynq_verify_speed,
+	.target		= zynq_target,
+	.get		= zynq_getspeed,
+	.init		= zynq_cpu_init,
+	.exit		= zynq_cpu_exit,
+	.name		= "Zynq cpufreq",
+	.attr		= zynq_cpufreq_attr,
+};
+
+static int __init zynq_cpufreq_init(void)
+{
+	struct device *dev = get_cpu_device(0);
+
+	if (!dev) {
+		pr_warn("%s: Error: device not found.", __func__);
+		return -EINVAL;
+	}
+	mpu_dev = dev;
+	return cpufreq_register_driver(&zynq_cpufreq_driver);
+}
+
+static void __exit zynq_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&zynq_cpufreq_driver);
+}
+
+MODULE_DESCRIPTION("cpufreq driver for Zynq");
+MODULE_LICENSE("GPL");
+module_init(zynq_cpufreq_init);
+module_exit(zynq_cpufreq_exit);
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index b151b7c..e77d1d0 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -499,6 +499,16 @@ config USB_SWITCH_FSA9480
 	  stereo and mono audio, video, microphone and UART data to use
 	  a common connector port.
 
+config SI570
+	tristate "Silicon Labs Si570 Clock Generator"
+	depends on I2C && SYSFS
+	help
+	  If you say yes here you get support for the Silicon Labs Si570
+	  digital clock generator.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called si570
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 2129377..8ed0f8c 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -49,3 +49,4 @@ obj-y				+= carma/
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
+obj-$(CONFIG_SI570)		+= si570.o
diff --git a/drivers/misc/si570.c b/drivers/misc/si570.c
new file mode 100644
index 0000000..201e3b1
--- /dev/null
+++ b/drivers/misc/si570.c
@@ -0,0 +1,576 @@
+/*
+ * Driver for Silicon Labs Si570/Si571 Programmable XO/VCXO
+ *
+ * Copyright (C) 2010, 2011 Ericsson AB.
+ * Copyright (C) 2011 Guenter Roeck.
+ *
+ * Author: Guenter Roeck <guenter.roeck@ericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/log2.h>
+#include <linux/slab.h>
+#include <linux/of_i2c.h>
+#include <linux/i2c/si570.h>
+
+/* Si570 registers */
+#define SI570_REG_HS_N1		7
+#define SI570_REG_N1_RFREQ0	8
+#define SI570_REG_RFREQ1	9
+#define SI570_REG_RFREQ2	10
+#define SI570_REG_RFREQ3	11
+#define SI570_REG_RFREQ4	12
+#define SI570_REG_CONTROL	135
+#define SI570_REG_FREEZE_DCO	137
+
+#define HS_DIV_SHIFT		5
+#define HS_DIV_MASK		0xe0
+#define HS_DIV_OFFSET		4
+#define N1_6_2_MASK		0x1f
+#define N1_1_0_MASK		0xc0
+#define RFREQ_37_32_MASK	0x3f
+
+#define SI570_FOUT_FACTORY_DFLT	156250000LL
+#define SI598_FOUT_FACTORY_DFLT	10000000LL
+
+#define SI570_MIN_FREQ		10000000L
+#define SI570_MAX_FREQ		1417500000L
+#define SI598_MAX_FREQ		525000000L
+
+#define FDCO_MIN		4850000000LL
+#define FDCO_MAX		5670000000LL
+#define FDCO_CENTER		((FDCO_MIN + FDCO_MAX) / 2)
+
+#define SI570_CNTRL_RECALL	(1 << 0)
+#define SI570_CNTRL_FREEZE_ADC	(1 << 4)
+#define SI570_CNTRL_FREEZE_M	(1 << 5)
+#define SI570_CNTRL_NEWFREQ	(1 << 6)
+#define SI570_CNTRL_RESET	(1 << 7)
+
+#define SI570_FREEZE_DCO	(1 << 4)
+#define SI570_UNFREEZE_DCO	0xEF
+
+struct si570_data {
+	struct attribute_group attrs;
+	struct mutex lock;
+	u64 max_freq;
+	u64 fout;		/* Factory default frequency */
+	u64 fxtal;		/* Factory xtal frequency */
+	unsigned int n1;
+	unsigned int hs_div;
+	u64 rfreq;
+	u64 frequency;
+};
+
+
+static struct i2c_client *si570_client;
+
+
+static int si570_get_defaults(struct i2c_client *client)
+{
+	struct si570_data *data = i2c_get_clientdata(client);
+	int reg1, reg2, reg3, reg4, reg5, reg6;
+	u64 fdco;
+
+	i2c_smbus_write_byte_data(client, SI570_REG_CONTROL,
+				  SI570_CNTRL_RECALL);
+
+	reg1 = i2c_smbus_read_byte_data(client, SI570_REG_HS_N1);
+	if (reg1 < 0)
+		return reg1;
+	reg2 = i2c_smbus_read_byte_data(client, SI570_REG_N1_RFREQ0);
+	if (reg2 < 0)
+		return reg2;
+	reg3 = i2c_smbus_read_byte_data(client, SI570_REG_RFREQ1);
+	if (reg3 < 0)
+		return reg3;
+	reg4 = i2c_smbus_read_byte_data(client, SI570_REG_RFREQ2);
+	if (reg4 < 0)
+		return reg4;
+	reg5 = i2c_smbus_read_byte_data(client, SI570_REG_RFREQ3);
+	if (reg5 < 0)
+		return reg5;
+	reg6 = i2c_smbus_read_byte_data(client, SI570_REG_RFREQ4);
+	if (reg6 < 0)
+		return reg6;
+
+	data->hs_div = ((reg1 & HS_DIV_MASK) >> HS_DIV_SHIFT) + HS_DIV_OFFSET;
+	data->n1 = ((reg1 & N1_6_2_MASK) << 2) + ((reg2 & N1_1_0_MASK) >> 6)
+	  + 1;
+	/* Handle invalid cases */
+	if (data->n1 > 1)
+		data->n1 &= ~1;
+
+	data->rfreq = reg2 & RFREQ_37_32_MASK;
+	data->rfreq = (data->rfreq << 8) + reg3;
+	data->rfreq = (data->rfreq << 8) + reg4;
+	data->rfreq = (data->rfreq << 8) + reg5;
+	data->rfreq = (data->rfreq << 8) + reg6;
+
+	/*
+	 * Accept optional precision loss to avoid arithmetic overflows.
+	 * Acceptable per Silicon Labs Application Note AN334.
+	 */
+	fdco = data->fout * data->n1 * data->hs_div;
+	if (fdco >= (1LL << 36))
+		data->fxtal = div64_u64((fdco << 24), (data->rfreq >> 4));
+	else
+		data->fxtal = div64_u64((fdco << 28), data->rfreq);
+
+	data->frequency = data->fout;
+
+	return 0;
+}
+
+/*
+ * Update rfreq registers
+ * This function must be called with update mutex lock held.
+ */
+static void si570_update_rfreq(struct i2c_client *client,
+			       struct si570_data *data)
+{
+	int status;
+	status = i2c_smbus_write_byte_data(client, SI570_REG_N1_RFREQ0,
+				  ((data->n1 - 1) << 6)
+				  | ((data->rfreq >> 32) & RFREQ_37_32_MASK));
+	if (status < 0)
+		dev_err(&client->dev,
+			"unable to write 0x%llX to REG_N1_RFREQ0: %d\n",
+			(((data->n1 - 1) << 6) | ((data->rfreq >> 32) &
+			RFREQ_37_32_MASK)) & 0xff, status);
+	status = i2c_smbus_write_byte_data(client, SI570_REG_RFREQ1,
+				  (data->rfreq >> 24) & 0xff);
+	if (status < 0)
+		dev_err(&client->dev,
+			"unable to write 0x%llX to REG_RFREQ1: %d\n",
+			(data->rfreq >> 24) & 0xff, status);
+	status = i2c_smbus_write_byte_data(client, SI570_REG_RFREQ2,
+				  (data->rfreq >> 16) & 0xff);
+	if (status < 0)
+		dev_err(&client->dev,
+			"unable to write 0x%llX to REG_RFREQ2: %d\n",
+			(data->rfreq >> 16) & 0xff, status);
+	status = i2c_smbus_write_byte_data(client, SI570_REG_RFREQ3,
+				  (data->rfreq >> 8) & 0xff);
+	if (status < 0)
+		dev_err(&client->dev,
+			"unable to write 0x%llX to REG_RFREQ3: %d\n",
+			(data->rfreq >> 8) & 0xff, status);
+	status = i2c_smbus_write_byte_data(client, SI570_REG_RFREQ4,
+				  data->rfreq & 0xff);
+	if (status < 0)
+		dev_err(&client->dev,
+			"unable to write 0x%llX to REG_RFREQ4: %d\n",
+			data->rfreq & 0xff, status);
+}
+
+/*
+ * Update si570 frequency for small frequency changes (< 3,500 ppm)
+ * This function must be called with update mutex lock held.
+ */
+static int si570_set_frequency_small(struct i2c_client *client,
+				     struct si570_data *data,
+				     unsigned long frequency)
+{
+	data->frequency = frequency;
+	/* This is a re-implementation of DIV_ROUND_CLOSEST
+	 * using the div64_u64 function lieu of letting the compiler
+	 * insert EABI calls
+	 */
+	data->rfreq = div64_u64((data->rfreq * frequency) +
+		div64_u64(data->frequency, 2), data->frequency);
+	i2c_smbus_write_byte_data(client, SI570_REG_CONTROL,
+				  SI570_CNTRL_FREEZE_M);
+	si570_update_rfreq(client, data);
+	i2c_smbus_write_byte_data(client, SI570_REG_CONTROL, 0);
+
+	return 0;
+}
+
+static const uint8_t si570_hs_div_values[] = { 11, 9, 7, 6, 5, 4 };
+
+/*
+ * Set si570 frequency.
+ * This function must be called with update mutex lock held.
+ */
+static int si570_set_frequency(struct i2c_client *client,
+			       struct si570_data *data,
+			       unsigned long frequency)
+{
+	int i, n1, hs_div;
+	u64 fdco, best_fdco = ULLONG_MAX;
+
+	for (i = 0; i < ARRAY_SIZE(si570_hs_div_values); i++) {
+		hs_div = si570_hs_div_values[i];
+		/* Calculate lowest possible value for n1 */
+		n1 = div64_u64(div64_u64(FDCO_MIN, (u64)hs_div),
+			(u64)frequency);
+		if (!n1 || (n1 & 1))
+			n1++;
+		while (n1 <= 128) {
+			fdco = (u64)frequency * (u64)hs_div * (u64)n1;
+			if (fdco > FDCO_MAX)
+				break;
+			if (fdco >= FDCO_MIN && fdco < best_fdco) {
+				data->n1 = n1;
+				data->hs_div = hs_div;
+				data->frequency = frequency;
+				data->rfreq = div64_u64((fdco << 28),
+					data->fxtal);
+				best_fdco = fdco;
+			}
+			n1 += (n1 == 1 ? 1 : 2);
+		}
+	}
+	if (best_fdco == ULLONG_MAX) {
+		dev_err(&client->dev, "error - best FDCO is out of range\n");
+		return -EINVAL;
+	}
+
+	/* The DCO reg should be accessed with a read-modify-write operation
+	 * per AN334
+	 */
+	i2c_smbus_write_byte_data(client, SI570_REG_FREEZE_DCO,
+				  SI570_FREEZE_DCO);
+	i2c_smbus_write_byte_data(client, SI570_REG_HS_N1,
+				  ((data->hs_div - HS_DIV_OFFSET) <<
+				   HS_DIV_SHIFT)
+				  | (((data->n1 - 1) >> 2) & N1_6_2_MASK));
+	si570_update_rfreq(client, data);
+	i2c_smbus_write_byte_data(client, SI570_REG_FREEZE_DCO,
+				  0);
+	i2c_smbus_write_byte_data(client, SI570_REG_CONTROL,
+				  SI570_CNTRL_NEWFREQ);
+	return 0;
+}
+
+/*
+ * Reset chip.
+ * This function must be called with update mutex lock held.
+ */
+static int si570_reset(struct i2c_client *client, struct si570_data *data)
+{
+	i2c_smbus_write_byte_data(client, SI570_REG_CONTROL,
+				  SI570_CNTRL_RESET);
+	usleep_range(1000, 5000);
+	return si570_set_frequency(client, data, data->frequency);
+}
+
+static ssize_t show_frequency_attr(struct device *dev,
+			      struct device_attribute *devattr,
+			      char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct si570_data *data = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%llu\n", data->frequency);
+}
+
+int get_frequency_si570(struct device *dev, unsigned long *freq)
+{
+	int err;
+	char buf[10+1];
+
+	if ((!dev) || (to_i2c_client(dev) != si570_client))
+		return -EINVAL;
+
+	show_frequency_attr(dev, NULL, buf);
+
+	err = strict_strtoul(buf, 10, freq);
+	if (err)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL(get_frequency_si570);
+
+static ssize_t set_frequency_attr(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct si570_data *data = i2c_get_clientdata(client);
+	unsigned long val;
+	int err;
+
+	err = strict_strtoul(buf, 10, &val);
+	if (err)
+		return err;
+
+	if (val < SI570_MIN_FREQ || val > data->max_freq) {
+		dev_err(&client->dev,
+			"requested frequency %lu Hz is out of range\n", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&data->lock);
+
+	if (div64_u64(abs(val - data->frequency) * 10000LL,
+		data->frequency) < 35)
+		err = si570_set_frequency_small(client, data, val);
+	else
+		err = si570_set_frequency(client, data, val);
+	mutex_unlock(&data->lock);
+	if (err) {
+		dev_warn(&client->dev,
+			"unable to set output frequency %lu Hz: %d\n",
+			val, err);
+		return err;
+	}
+
+	dev_info(&client->dev,
+		"set new output frequency %lu Hz\n", val);
+
+	return count;
+}
+
+int set_frequency_si570(struct device *dev, unsigned long freq)
+{
+	char buf[10+1];
+
+	if ((!dev) || (to_i2c_client(dev) != si570_client))
+		return -EINVAL;
+
+	sprintf(buf, "%lu", freq);
+
+	return set_frequency_attr(dev, NULL, buf,  0);
+}
+EXPORT_SYMBOL(set_frequency_si570);
+
+static ssize_t show_reset_attr(struct device *dev,
+			  struct device_attribute *devattr,
+			  char *buf)
+{
+	return sprintf(buf, "%d\n", 0);
+}
+
+static ssize_t set_reset_attr(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct si570_data *data = i2c_get_clientdata(client);
+	unsigned long val;
+	int err;
+
+	err = strict_strtoul(buf, 10, &val);
+	if (err)
+		return err;
+	if (val == 0)
+		goto done;
+
+	mutex_lock(&data->lock);
+	err = si570_reset(client, data);
+	mutex_unlock(&data->lock);
+	if (err)
+		return err;
+done:
+	return count;
+}
+
+int reset_si570(struct device *dev, int id)
+{
+	char buf[4];
+
+	if ((!dev) || (to_i2c_client(dev) != si570_client))
+		return -EINVAL;
+
+	sprintf(buf, "%lu", (unsigned long)id);
+	return set_reset_attr(dev, NULL, buf, 0);
+}
+EXPORT_SYMBOL(reset_si570);
+
+struct i2c_client *get_i2c_client_si570(void)
+{
+	return si570_client;
+}
+EXPORT_SYMBOL(get_i2c_client_si570);
+
+static DEVICE_ATTR(frequency, S_IWUSR | S_IRUGO, show_frequency_attr, set_frequency_attr);
+static DEVICE_ATTR(reset, S_IWUSR | S_IRUGO, show_reset_attr, set_reset_attr);
+
+static struct attribute *si570_attr[] = {
+	&dev_attr_frequency.attr,
+	&dev_attr_reset.attr,
+	NULL
+};
+
+static const struct i2c_device_id si570_id[] = {
+	{ "si570", 0 },
+	{ "si571", 0 },
+	{ "si598", 1 },
+	{ "si599", 1 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, si570_id);
+
+static int si570_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct si570_platform_data *pdata = client->dev.platform_data;
+	struct si570_data *data;
+	int err;
+	unsigned long initial_fout;
+	u32 tmp;
+
+	data = kzalloc(sizeof(struct si570_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	if (id->driver_data) {
+		data->fout = SI598_FOUT_FACTORY_DFLT;
+		data->max_freq = SI598_MAX_FREQ;
+	} else {
+		data->fout = SI570_FOUT_FACTORY_DFLT;
+		data->max_freq = SI570_MAX_FREQ;
+	}
+
+	if (pdata && pdata->factory_fout)
+		data->fout = pdata->factory_fout;
+
+	if (client->dev.of_node &&
+		(of_property_read_u32(client->dev.of_node, "factory-fout",
+			&tmp) < 0))
+		dev_warn(&client->dev,
+			"DTS does not contain factory-fout, using default\n");
+	else
+		data->fout = tmp;
+
+	i2c_set_clientdata(client, data);
+	err = si570_get_defaults(client);
+	if (err < 0)
+		goto exit_free;
+
+	mutex_init(&data->lock);
+
+	/* Register sysfs hooks */
+	data->attrs.attrs = si570_attr;
+	err = sysfs_create_group(&client->dev.kobj, &data->attrs);
+	if (err)
+		goto exit_free;
+
+	/* Display a message indicating that we've successfully registered */
+	dev_info(&client->dev,
+		"registered %s with default frequency %llu Hz\n",
+		id->name, data->fout);
+
+	/* Read the requested initial fout from either platform data or the
+	 * device tree
+	 */
+	initial_fout = 0;
+	if (pdata && pdata->initial_fout) {
+		initial_fout = pdata->initial_fout;
+	}
+	if (client->dev.of_node) {
+		of_property_read_u32(client->dev.of_node, "initial-fout",
+			(u32 *)&initial_fout);
+		if (pdata && pdata->initial_fout &&
+			(pdata->initial_fout != initial_fout)) {
+			dev_warn(&client->dev,
+				"OF initial fout %lu overrides platform data fout %lu\n",
+				initial_fout,
+				pdata->initial_fout);
+		}
+	}
+
+	if (initial_fout != 0) {
+		if (initial_fout < SI570_MIN_FREQ ||
+			initial_fout > data->max_freq) {
+			dev_err(&client->dev,
+				"requested initial frequency %lu is out of range, using default\n",
+				initial_fout);
+			return 0;
+		}
+
+		mutex_lock(&data->lock);
+
+		if (div64_u64(abs(initial_fout - data->frequency) *
+			10000LL, data->frequency) < 35)
+			err = si570_set_frequency_small(client, data,
+				initial_fout);
+		else
+			err = si570_set_frequency(client, data,
+				initial_fout);
+		mutex_unlock(&data->lock);
+		if (err) {
+			dev_warn(&client->dev,
+				"unable to set initial output frequency %lu: %d\n",
+				initial_fout, err);
+			return err;
+		}
+
+		dev_info(&client->dev,
+			"set initial output frequency %lu Hz\n",
+			initial_fout);
+	}
+
+	si570_client = client;
+
+	return 0;
+
+exit_free:
+	kfree(data);
+exit:
+	return err;
+}
+
+static int si570_remove(struct i2c_client *client)
+{
+	struct si570_data *data = i2c_get_clientdata(client);
+
+	sysfs_remove_group(&client->dev.kobj, &data->attrs);
+	kfree(data);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id i2c_si570_of_match[] = {
+	{ .compatible = "si570" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, i2c_si570_of_match);
+#endif
+
+static struct i2c_driver si570_driver = {
+	.driver = {
+		.name	= "si570",
+		.of_match_table = of_match_ptr(i2c_si570_of_match),
+	},
+	.probe		= si570_probe,
+	.remove		= si570_remove,
+	.id_table	= si570_id,
+};
+
+static int __init si570_init(void)
+{
+	return i2c_add_driver(&si570_driver);
+}
+
+static void __exit si570_exit(void)
+{
+	i2c_del_driver(&si570_driver);
+}
+
+MODULE_AUTHOR("Guenter Roeck <guenter.roeck@ericsson.com>");
+MODULE_DESCRIPTION("Si570 driver");
+MODULE_LICENSE("GPL");
+
+module_init(si570_init);
+module_exit(si570_exit);
diff --git a/include/linux/clk/zynq.h b/include/linux/clk/zynq.h
index 56be7cd..a501169 100644
--- a/include/linux/clk/zynq.h
+++ b/include/linux/clk/zynq.h
@@ -1,24 +1,39 @@
 /*
- * Copyright (C) 2012 National Instruments
+ *  Copyright (C) 2012 Xilinx
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #ifndef __LINUX_CLK_ZYNQ_H_
 #define __LINUX_CLK_ZYNQ_H_
 
-void __init xilinx_zynq_clocks_init(void __iomem *slcr);
+void __init zynq_clock_init(void __iomem *slcr);
+
+struct clk *clk_register_zynq_gd1m(const char *name,
+		void __iomem *clkctrl, const char **pnames,
+		spinlock_t *lock);
+struct clk *clk_register_zynq_gd2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock);
+struct clk *clk_register_zynq_d2m(const char *name,
+		void __iomem *clkctrl, const char **pnames, spinlock_t *lock);
+struct clk *clk_register_zynq_d1m(const char *name,
+		void __iomem *clkctrl, const char **pnames, u8 num_parents,
+		spinlock_t *lock);
+
+struct clk *clk_register_zynq_clk621(const char *name,
+		void __iomem *clkctrl, void __iomem *clk621,
+		unsigned int basediv,
+		unsigned int divadd, const char **pnames, u8 num_parents,
+		spinlock_t *lock);
+
+//void __init xilinx_zynq_clocks_init(void __iomem *slcr);
 
 #endif
diff --git a/include/linux/i2c/si570.h b/include/linux/i2c/si570.h
new file mode 100644
index 0000000..f2cf285
--- /dev/null
+++ b/include/linux/i2c/si570.h
@@ -0,0 +1,31 @@
+/*
+ * si570.h - Configuration for si570 misc driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License only).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_SI570_H
+#define __LINUX_SI570_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+
+struct si570_platform_data {
+	u64 factory_fout;		/* Factory default output frequency */
+	unsigned long initial_fout;	/* Requested initial frequency */
+};
+
+int get_frequency_si570(struct device *dev, unsigned long *freq);
+int set_frequency_si570(struct device *dev, unsigned long freq);
+int reset_si570(struct device *dev, int id);
+struct i2c_client *get_i2c_client_si570(void);
+
+#endif /* __LINUX_SI570_H */
-- 
1.7.5.4

